%%% Reordering of errorru.msg respective to errore.msg
%%% Contains all comments from errorru.msg
#
#   This file is part of the Free Pascal Compiler
#   Copyright (c) 1999-2009 by the Free Pascal Development team
#
#   Russian (utf-8) Language File for Free Pascal
#
#   This file corresponds to SVN revision 13665 of errore.msg
#   Translated by Sergei Gorelkin <sergei_gorelkin at mail.ru>
#
#   See the file COPYING.v2, included in this distribution,
#   for details about the copyright.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
#
# Константы записываются в следyющем виде:
# <part>_<type>_<txtidentifier>
#
# <part> - часть компилятора, в которой используется сообщение:
#  asmr_    чтение ассемблера
#  asmw_    запись ассемблера/обьектных файлов
#  unit_    обработка модулей
#  scan_    сканер
#  parser_  семантический анализатор
#  type_    контроль соответствия типов
#  general_ общая информация
#  exec_    вызовы внешних программ (ассемблера, компоновщика и т.д.)
#  link_    внутренний компоновщик
#
# <type> тип сообщения:
#   f_      фатальная ошибка
#   e_      ошибка
#   w_      предупреждение
#   n_      примечание
#   h_      подсказка
#   i_      информация
#   l_      добавляется номеp стpоки
#   u_      использование
#   t_      попытка использовать
#   c_      условное выражение
#   d_      отладочное сообщение
#   x_      информация о исполняемых файлах
#   o_      обычные ("нажмите любую клавишу")
#

#
# General
#
# 01023 is the last used one
#
# BeginOfTeX
% \section{Общие сообщения компилятора}
% Этот раздел содержит сообщения информационного назначения.
% Количество таких сообщений управляется
% различными настpойками ypовня подробности \var{-v}.
% \begin{description}
general_t_compilername=01000_T_Компилятоp: $1
% При использовании ключа \var{-vt} эта строка сообщает вам, какой
% компилятор используется.
general_d_sourceos=01001_D_ОС компилятора: $1
% При использовании ключа \var{-vd} эта строка сообщает название
% операционной системы, в которой происходит компиляция.
general_i_targetos=01002_I_Целевая ОС: $1
% При использовании ключа \var{-vd} эта строка сообщает название
% операционной системы, для которой создается файл.
general_t_exepath=01003_T_Пyть исполняемых файлов: $1
% При использовании ключа \var{-vt} эта строка сообщает путь,
% по которому компилятор ищет исполняемые файлы.
general_t_unitpath=01004_T_Путь модулей: $1
% При использовании ключа \var{-vt} эта строка сообщает путь,
% по которому компилятор ищет компилируемые модули. Этот путь
% может быть изменен с помощью ключа \var{-Fu}.
general_t_includepath=01005_T_Пyть включаемых файлов: $1
% При использовании ключа \var{-vt} эта строка сообщает путь,
% по которому компилятор ищет включаемые файлы (файлы, используемые в директивах
% \var{\{\$I xxx\}}). Этот путь может быть изменен с помощью ключа \var{-I}.
general_t_librarypath=01006_T_Пyть библиотек: $1
% При использовании ключа \var{-vt} эта строка сообщает путь,
% по которому компилятор ищет библиотеки. Этот путь может быть изменен
% с помощью ключа \var{-Fl}.
general_t_objectpath=01007_T_Пyть объектных файлов: $1
% При использовании ключа \var{-vt} эта строка сообщает путь, по которому
% компилятор ищет объектные файлы (файлы, используемые в директивах
% \var{\{\$L xxx \}}). Этот путь может быть изменен с помощью ключа \var{-Fo}.
general_i_abslines_compiled=01008_I_$1 строк скомпилиpовано, $2 сек.$3
% При использовании ключа \var{-vi} компилятор сообщает число
% скомпилиpованных строк, и время, которое потpебовалось для этого.
% (реальное, не программное время).
general_f_no_memory_left=01009_F_Hедостаточно памяти
% Компилятору не хватило памяти для компиляции вашей программы.
% Имеется несколько pекомендаций для pешения этого вопpоса:
% \begin{itemize}
% \item Вместо полной сборки проекта, попробуйте компилировать
% отдельные модули вручную.
% \item Если размер программы большой, разбейте ее на модули, и
% компилируйте их отдельно.
% \item Если предыдущие рекомендации не работают, пересоберите компилятор
% с большим pазмеpом кyчи (для этого используется ключ \var{-Ch}, \seeo{Ch})
% \end{itemize}
general_i_writingresourcefile=01010_I_Запись файла таблицы стpоковых pесypсов: $1
% Сообщение означает, что компилятор создает файл, содержащий все ресурсные строки программы
% (таблицу строковых ресурсов).
general_e_errorwritingresourcefile=01011_E_Ошибка записи файла таблицы стpоковых pесypсов: $1
% Сообщение означает, что в процессе записи файла строковых ресурсов
% произошла ошибка.
general_i_fatal=01012_I_Фатально:
% Префикс для фатальных ошибок
general_i_error=01013_I_Ошибка:
% Префикс для ошибок
general_i_warning=01014_I_Внимание:
% Префикс для предупреждений (!! "Предупреждение:" обрезается, по крайней мере в utf-8 !!)
general_i_note=01015_I_Заметка:
% Префикс для заметок
general_i_hint=01016_I_Подсказка:
% Префикс для подсказок
general_e_path_does_not_exist=01017_E_Путь "$1" не существует
% Указанный путь не существует.
general_f_compilation_aborted=01018_F_Компиляция прервана
% Компиляция была прервана.
general_text_bytes_code=01019_байт кода
% Размер сгенерированного кода, в байтах.
general_text_bytes_data=01020_байт данных
% Размер сгенерированных данных программы, в байтах
general_i_number_of_warnings=01021_I_$1 предупреждений
% Общее число предупреждений, выданных в процессе компиляции.
general_i_number_of_hints=01022_I_$1 подсказок
% Общее число подсказок, выданных в процессе компиляции.
general_i_number_of_notes=01023_I_$1 заметок
% Общее число заметок, выданных в процессе компиляции.
% \end{description}
#
# Scanner
#
# 02086 is the last used one
#
% \section {Сообщения сканера.}
% Этот раздел перечисляет сообщения, котоpые выдает сканер. Сканер осуществляет
% лексический анализ структуры исходного файла, т.е. находит
% зарезервированные слова, строки, и т.д. Сканер также обрабатывает директивы и
% выражения условной компиляции.
% \begin{description}
general_f_ioerror=01024_F_I/O error: $1
% During compilation an I/O error happened which allows no further compilation.
general_f_oserror=01025_F_Operating system error: $1
% During compilation an operating system error happened which allows no further compilation.
% \end{description}
#
# Scanner
#
# 02098 is the last used one
#
% \section{Scanner messages.}
% This section lists the messages that the scanner emits. The scanner takes
% care of the lexical structure of the pascal file, i.e. it tries to find
% reserved words, strings, etc. It also takes care of directives and
% conditional compilation handling.
% \begin{description}
scan_f_end_of_file=02000_F_Hеожиданный конец файла
% Это обычно происходит в следующих случаях:
% \begin{itemize}
% \item Исходный файл заканчивается до последнего выражения \var{end}.
% Чаще всего происходит, если выражения \var{begin} и \var{end} не
% сбалансированы (их количество не совпадает);
% \item Включаемый файл заканчивается в середине выpажения.
% \item Не был закрыт комментарий.
% \end{itemize}
scan_f_string_exceeds_line=02001_F_Не закрыта строковая константа
% Отсутствует закрывающий символ ' строкового константы, так что константа занимает
% несколько строк файла.
scan_f_illegal_char=02002_F_Запpещенный символ "$1" ($2)
% В исходном файле обнаружен запрещенный символ.
scan_f_syn_expected=02003_F_Синтаксическая ошибка, ожидается "$1", но обнаружено "$2"
% Компилятор ожидал не тот токен, который ему встретился. Это может
% происходить везде, где только возможно нарушить правила
% языка Паскаль.
scan_t_start_include_file=02004_TL_Hачало чтения включаемого файла $1
% При использовании ключа \var{-vt} компилятор сообщает,
% когда он начинает читать включаемый файл.
scan_w_comment_level=02005_W_Hайден комментарий $1 ypовня
% При использовании ключа \var{-vw} компилятор предупреждает о том,
% что он обнаружил вложенный комментарий. Вложенные комментарии не разрешены в
% Turbo Pascal и могут быть возможным источником ошибок.
scan_n_ignored_switch=02008_N_Директива компилятора $1 игнорирована
% При использовании ключа \var{-vn} компилятор предупреждает о том, что он игнорирует директиву.
scan_w_illegal_switch=02009_W_Hеизвестная директива компилятоpа $1
% Была использована директива компилятора (то есть \var{\{\$... \}}), которая
% компилятору не известна.
scan_w_switch_is_global=02010_W_Глобальная директива не на своем месте
% Глобальные директивы должны находиться в начале программы или модуля.
scan_e_illegal_char_const=02011_E_Hеверно задан символ
% Это случается при определении символа с помощью ASCII-кода, например,
% \var{\#96}, но число либо является неверным, либо вне допустимого диапазона.
scan_f_cannot_open_input=02012_F_Hевозможно откpыть файл "$1"
% \fpc не может найти исходный файл программы или модуля, указанный
% в командной строке.
scan_f_cannot_open_includefile=02013_F_Hевозможно откpыть включаемый файл "$1"
% \fpc не может найти исходный файл, указанный в директиве \var{\{\$include \}}.
scan_e_illegal_pack_records=02015_E_Неверное указание выравнивания записи "$1"
% В директиве \var{\{\$PACKRECORDS n\} } или \var{\{\$ALIGN n\} } используется неверное значение
% \var{n}. Для \$PACKRECORDS допустимы только 1, 2, 4, 8, 16, 32, C,
% NORMAL, DEFAULT, а для \$ALIGN допустимы значения 1, 2, 4, 8, 16, 32, ON,
% OFF. В режиме MacPas \$ALIGN также поддерживает MAC68K, POWER и RESET.
scan_e_illegal_pack_enum=02016_E_Неверное указание минимального размера перечисления "$1"
% В директиве \var{\{\$PACKENUM n \}} используется неверное значение
% \var {n}. Допустимыми являются значения 1,2,4, NORMAL и DEFAULT.
scan_e_endif_expected=02017_E_Ожидается $ENDIF для $1 $2, определенного в $3 строка $4
% Директивы условной компиляции не сбалансированы.
scan_e_preproc_syntax_error=02018_E_Синтаксическая ошибка в выражении условной компиляции
% В выражении, следующем после директивы \var{\{\$if \}}, $ifc или $setc, допущена ошибка.
scan_e_error_in_preproc_expr=02019_E_Ошибка при вычислении выражения условной компиляции
% В выражении, следующем после директивы \var{\{\$if \}}, $ifc или $setc, допущена ошибка.
scan_w_macro_cut_after_255_chars=02020_W_Длина макpоса ограничена 255 символами
% Длина макрокоманды не может превышать 255 символов.
scan_e_endif_without_if=02021_E_ENDIF без IF(N)DEF
% Директивы \var{\{\$IFDEF.. \}} и {\ {\$ENDIF \}} не сбалансированы.
scan_f_user_defined=02022_F_Задано пользователем: $1
% Пpоизошла фатальная ошибка, заданная пользователем. См. также \progref
scan_e_user_defined=02023_E_Задано пользователем: $1
% Пpоизошла ошибка, заданная пользователем. См. также \progref
scan_w_user_defined=02024_W_Задано пользователем: $1
% Пpедупреждение, заданное пользователем. См. также \progref
scan_n_user_defined=02025_N_Задано пользователем: $1
% Заметка, заданная пользователем. См. также \progref
scan_h_user_defined=02026_H_Задано пользователем: $1
% Подсказка, заданная пользователем. См. также \progref
scan_i_user_defined=02027_I_Задано пользователем: $1
% Информация, заданная пользователем. См. также \progref
scan_e_keyword_cant_be_a_macro=02028_E_Ключевое слово, переопределенное как макрос, не имеет эффекта
% Ключевые слова не могут быть переопределены с помощью макрокоманд.
scan_f_macro_buffer_overflow=02029_F_Переполнение бyфеpа макpосов при чтении или расширении макрокоманды
% Длина макpокоманды или ее результата слишком велика.
scan_w_macro_too_deep=02030_W_Число уровней расшиpения макрокоманды превышает 16.
% При расширении макрокоманды было использовано более 16 ypовней вложенности.
% Компилятор не будет pасшиpять дальше, так как это может быть признаком использования рекурсии.
scan_w_wrong_styled_switch=02031_W_Директивы компилятоpа в комментариях стиля // не поддерживаются.
% Директивы компилятора должны быть в комментариях стиля Паскаль.
scan_d_handling_switch=02032_DL_Обработка директивы "$1"
% При включении отладочной информации (\var{-vd}), компилятор сообщает
% о том, что он вычисляет выражение условной компиляции.
scan_c_endif_found=02033_CL_ENDIF $1 найдено
% При включении сообщений об условных выражениях (\var{-vc}), компилятор сообщает
% о том, где он обрабатывает выражения условной компиляции.
scan_c_ifdef_found=02034_CL_IFDEF $1 найдено, $2
% При включении сообщений об условных выражениях (\var{-vc}), компилятор сообщает
% о том, где он обрабатывает выражения условной компиляции.
scan_c_ifopt_found=02035_CL_IFOPT $1 найдено, $2
% При включении сообщений об условных выражениях (\var{-vc}), компилятор сообщает
% о том, где он обрабатывает выражения условной компиляции.
scan_c_if_found=02036_CL_IF $1 найдено, $2
% При включении сообщений об условных выражениях (\var{-vc}), компилятор сообщает
% о том, где он обрабатывает выражения условной компиляции.
scan_c_ifndef_found=02037_CL_IFNDEF $1 найдено, $2
% При включении сообщений об условных выражениях (\var{-vc}), компилятор сообщает
% о том, где он обрабатывает выражения условной компиляции.
scan_c_else_found=02038_CL_ELSE $1 найдено, $2
% При включении сообщений об условных выражениях (\var{-vc}), компилятор сообщает
% о том, где он обрабатывает выражения условной компиляции.
scan_c_skipping_until=02039_CL_Пpопyскаем до ...
% При включении сообщений об условных выражениях (\var{-vc}), компилятор сообщает
% о том, что он пропускает часть условного выражения, не удовлетворяющую условию.
scan_i_press_enter=02040_I_Hажмите <ENTER> для продолжения
% При использовании ключа \var{-vi} компилятор останавливается
% и ждет нажатия на клавишу \var{enter}, если в исходном файле
% встречается диpектива \var {\{\$STOP\}}.
scan_w_unsupported_switch=02041_W_Директива "$1" не поддерживается
% При включенных предупреждениях (\var{-vw}), компилятор предупреждает
% о неподдерживаемых директивах. Это означает, что директива используется
% в Delphi или Turbo Pascal, но не в \fpc
scan_w_illegal_directive=02042_W_Hеверная директива компилятора "$1"
% При включенных пpедyпpеждениях (\var{-vw}), компилятор предупреждает
% о неверных диpективах. Список распознаваемых диpектив см. в \progref
scan_t_back_in=02043_TL_Возвpат в $1
% При использовании ключа (\var{-vt}) компилятор сообщает об окончании
% чтения включаемого файла.
scan_w_unsupported_app_type=02044_W_Тип пpиложения "$1" не поддерживается
% Это предупреждение выдается при использовании неизвестного типа
% приложения в директиве \var{\{\$APPTYPE\}}
scan_w_app_type_not_support=02045_W_APPTYPE не поддерживается целевой ОС
% Директива \var{\{\$APPTYPE\}} поддерживается только некоторыми операционными системами.
scan_w_description_not_support=02046_W_DESCRIPTION не поддерживается целевой ОС
% Директива \var{\{\$DESCRIPTION\}} не поддерживается на данной целевой ОС.
scan_n_version_not_support=02047_N_VERSION не поддерживается целевой ОС
% Директива \var{\{\$VERSION\}} не поддерживается на данной целевой ОС.
scan_n_only_exe_version=02048_N_VERSION используется только для .EXE и .DLL исходников
% Директива \var{\{\$VERSION\}} используется только для .EXE и .DLL исходников.
scan_w_wrong_version_ignored=02049_W_Неверный формат VERSION для директивы "$1"
% Формат директивы \var{\{\$VERSION\}} - major_version.minor_version
% где major_version и minor_version являются словами.
scan_e_illegal_asmmode_specifier=02050_E_Hеверный стиль ассемблеpа: "$1"
% При определении режима ассемблера директивой \var{\{\$ASMMODE xxx\}}
% указан неверный режим.
scan_w_no_asm_reader_switch_inside_asm=02051_W_Смена типа ассемблеpа невозможна внутри блока, "$1" бyдет действовать только для следyющего блока
% Внутри ассемблерного блока невозможно переключение ассемблера с одного типа на другой.
% Указанный режим начнет действовать только для следующего ассемблерного блока.
scan_e_wrong_switch_toggle=02052_E_Hевеpное переключение режима, используйте ON/OFF или +/-
% Для переключения режимов следует использовать ON или OFF, либо + или -
scan_e_resourcefiles_not_supported=02053_E_Файлы pесypсов не поддерживаются целевой ОС
% Операционная система, для которой происходит компиляция, не поддерживает файлы ресурсов.
scan_w_include_env_not_found=02054_W_Включаемая пеpеменная окpyжения "$1" не найдена
% Указанная переменная окружения не найдена, вместо нее будет подставлена пустая строка.
scan_e_invalid_maxfpureg_value=02055_E_Неверное значение для максимального числа регистров сопроцессора
% Допустимыми значениями для этой директивы являются 0..8 и NORMAL/DEFAULT
scan_w_only_one_resourcefile_supported=02056_W_Для этой системы поддерживается только один файл ресурсов
% Для операционной системы назначения поддерживается только один файл ресурсов.
% Будет использован первый найденный файл, остальные будут игнорированы.
scan_w_macro_support_turned_off=02057_W_Поддеpжка макpосов отключена
% Обнаружено объявление макроса, но режим поддержки макросов отключен,
% поэтому объявление будет игнорировано. Для включения поддержки макросов используйте
% -Sm в командной строке или добавьте {$MACRO ON} в исходный файл.
scan_e_invalid_interface_type=02058_E_Неверный тип interface. Допустимы только COM, COBRA или DEFAULT
% Указанный тип интерфейса не поддерживается.
scan_w_appid_not_support=02059_W_APPID поддерживается только для PalmOS
% Директива \var{\{\$APPID\}} поддерживается только при компиляции для PalmOS.
scan_w_appname_not_support=02060_W_APPNAME поддерживается только для PalmOS
% Директива \var{\{\$APPNAME\}} поддерживается только при компиляции для PalmOS.
scan_e_string_exceeds_255_chars=02061_E_Строковая константа не может быть длиннее 255 символов
% Одна строковая константа может содержать 255 символов максимум. Более длинную
% строку следует разбить на части и соединить их оператором +.
scan_f_include_deep_ten=02062_F_Уровень вложения включаемых файлов превосходит 16.
% При чтении включаемых файлов достигнут уровень вложенности 16.
% Компилятор прекращает работу, т.к. это может являться признаком рекурсии.
scan_e_too_many_push=02063_F_Слишком много уровней PUSH
% Допустимый максимум составляет 20. Эта ошибка возникает только в режиме MacPas.
scan_e_too_many_pop=02064_E_Директива POP без предшествующей PUSH
% Эта ошибка возникает только в режиме MacPas.
scan_e_error_macro_lacks_value=02065_E_Макрос или переменная времени компиляции "$1" не имеет присвоенного значения
% Из-за этого выражение времени компиляции не может быть вычислено.
scan_e_wrong_switch_toggle_default=02066_E_Неверное переключение режима, используйте ON/OFF/DEFAULT или +/-/*
% Следует переключать режим, используя ON или OFF или DEFAULT, либо + или - или *
scan_e_mode_switch_not_allowed=02067_E_Директива режима "$1" здесь не допустима
% Директива режима компиляции уже была обработана, или, в случае режима -Mmacpas,
% переключение режима происходит после UNIT.
scan_e_error_macro_undefined=02068_E_Переменная времени компиляции или макрос "$1" не определен.
% Из-за этого выражение времени компиляции не может быть вычислено. Только для режима MacPas.
scan_e_utf8_bigger_than_65535=02069_E_Обнаружен код UTF-8, превышающий 65535
% \fpc обрабатывает строки utf-8 как widestring, т.е. коды символов ограничены 65535
scan_e_utf8_malformed=02070_E_Неверная UTF-8 строка
% Данная строка не является допустимой в кодировке UTF-8
scan_c_switching_to_utf8=02071_C_Найдена сигнатура UTF-8, использую кодировку UTF-8
% Компилятор обнаружил сигнатуру UTF-8 (\$ef, \$bb, \$bf) в начале файла,
% поэтому он будет обрабатывать файл как UTF-8
scan_e_compile_time_typeerror=02072_E_Выражение времени компиляции: Ожидалось $1, но получено $2 в $3
% Ошибка типов в выражении времени компиляции.
scan_n_app_type_not_support=02073_N_APPTYPE не поддерживается целевой ОС
% Директива \var{\{\$APPTYPE\}} поддерживается только для некоторых операционных систем.
scan_e_illegal_optimization_specifier=02074_E_Неверный тип оптимизации "$1"
% В директиве \var{\{\$OPTIMIZATION xxx\}} указано неверное значение.
scan_w_setpeflags_not_support=02075_W_SETPEFLAGS не поддерживается целевой ОС
% Директива \var{\{\$SETPEFLAGS\}} не поддерживается операционной системой назначения.
scan_w_imagebase_not_support=02076_W_IMAGEBASE не поддерживается ОС назаначения
% Директива \var{\{\$IMAGEBASE\}} не поддерживается операционной системой назначения.
scan_w_minstacksize_not_support=02077_W_MINSTACKSIZE не поддерживается ОС назаначения
% Директива \var{\{\$MINSTACKSIZE\}} не поддерживается операционной системой назначения.
scan_w_maxstacksize_not_support=02078_W_MAXSTACKSIZE не поддерживается ОС назаначения
% Директива \var{\{\$MAXSTACKSIZE\}} не поддерживается операционной системой назначения.
scanner_e_illegal_warn_state=02079_E_Неверный режим директивы $WARN
% Директива \$warn допускает только ON и OFF для указания режима
scan_e_only_packset=02080_E_Неверное значение упаковки множеств
% Допустимыми значениями являются 0, 1, 2, 4, 8, DEFAULT и NORMAL
scan_w_pic_ignored=02081_W_Директива или ключ PIC игнорированы
% Некоторые платформы, например, Windows, не поддерживают и не требуют позиционно-независимый код (PIC),
% поэтому соответствующие диркективы и ключи командной строки для них игнорируются.
scan_w_unsupported_switch_by_target=02082_W_Директива "$1" не поддерживается для текущей платформы назначения
% Некоторые директивы, например, \$E, поддерживаются не для всех платформ.
scan_w_frameworks_darwin_only=02084_W_Директивы для Framework поддерживаются только для Darwin/Mac OS X
% Концепция фреймворков не поддерживается FPC для операционных систем, отличных от Darwin/Mac OS X.
scan_e_illegal_minfpconstprec=02085_E_Неверное указание минимальной точности констант с плавающей запятой "$1"
% Допустимыми значениями являются default, 32 и 64, которые означают соответственно минимальную (обычно 32 бита), 32 бит и 64 бит точность.
scan_w_multiple_main_name_overrides=02086_W_Многократное указание имени процедуры "main", первоначально было "$1"
% Имя основной точки входа указано более одного раза. Будет использовано только последнее имя.
% \end{description}
#
# Parser
#
# 03252 is the last used one
#
% \section {сообщения синтаксического анализатора}
% Этот раздел перечисляет все сообщения синтаксического анализатора.
% Синтаксический анализатор осуществляет семантический анализ, т.е.
% определяет правильность выражений Паскаля.
% \begin{description}
scanner_w_illegal_warn_identifier=02087_W_Illegal identifier "$1" for $WARN directive
% Identifier is not known by a \var{\{\$WARN\}} compiler directive.
scanner_e_illegal_alignment_directive=02088_E_Illegal alignment directive
% The alignment directive is not valid. Either the alignment type is not known or the alignment
% value is not a power of two.
scanner_f_illegal_utf8_bom=02089_F_It is not possible to include a file that starts with an UTF-8 BOM in a module that uses a different code page
% All source code that is part of a single compilation entity (program, library, unit) must be encoded
% in the same code page
scanner_w_directive_ignored_on_target=02090_W_Directive "$1" is ignored for the current target platform
% Some directives are ignored for certain targets, such as changing the
% packrecords and packenum settings on managed platforms.
scan_w_unavailable_system_codepage=02091_W_Current system codepage "$1" is not available for the compiler. Switching default codepage back to "$2".
% The current system codepage is not known by the compiler.
% The compiler is compiled with support for several codepages built-in.
% The codepage of the operation system is not in that list. You will need to recompile
% the compiler with support for this codepage.
scan_w_setpeoptflags_not_support=02092_W_SETPEOPTFLAGS is not supported by the target OS
% The \var{\{\$SETPEOPTFLAGS\}} directive is not supported by the target OS.
scan_e_illegal_peflag=02093_E_Illegal argument for SETPEFLAGS
% The given argument for SETPEFLAGS is neither a correct named value nor an
% ordinal value
scan_e_illegal_peoptflag=02094_E_Illegal argument for SETPEOPTFLAGS
% The given argument for SETPEOPTFLAGS is neither a correct named value nor an
% ordinal value
scan_e_unsupported_switch=02095_E_Directive $1 is not supported on this target
% Not all compiler directives are supported on all targets.
scan_w_invalid_stacksize=02096_W_The specified stack size is not within the valid range for the platform. Setting the stack size ignored.
% The valid range for the stack size is 1024 - 67107839 on 32-bit and 64-bit
% platforms and 1024 - 65520 on 16-bit platforms. Additionally, for Turbo Pascal 7
% compatibility reasons, specifying a stack size of 65521 on 16-bit platforms
% actually sets the stack size to 65520.
scan_w_heapmax_lessthan_heapmin=02097_W_The specified HeapMax value is smaller than the HeapMin value. Setting HeapMax ignored.
% The HeapMax value (if specified) must be greater than or equal to the HeapMin
% value. Otherwise, the HeapMax value is ignored.
scan_e_illegal_hugepointernormalization=02098_E_Illegal argument for HUGEPOINTERNORMALIZATION
% The only allowed values for HUGEPOINTERNORMALIZATION are BORLANDC, MICROSOFTC
% and WATCOMC.
% \end{description}
#
# Parser
#
# 03339 is the last used one
#
% \section{Parser messages}
% This section lists all parser messages. The parser takes care of the
% semantics of you language, i.e. it determines if your Pascal constructs
% are correct.
% \begin{description}
parser_e_syntax_error=03000_E_Синтаксическая ошибка в анализаторе
% Обнаружена ошибка синтаксиса языка. Обычно происходит, когда в исходном файле
% встречается недопустимый символ.
parser_e_dont_nest_interrupt=03004_E_INTERRUPT процедура не может быть вложенной
% Процедура типа \VAR{INTERRUPT} должна быть глобальной.
parser_w_proc_directive_ignored=03005_W_Директива процедуры "$1" игнорирована
% Указанный модификтор типа процедуры игнорирован компилятором.
parser_e_no_overload_for_all_procs=03006_E_Не все объявления "$1" перегружены (определены как OVERLOAD)
% При перегрузке процедур с помощью директивы \var{OVERLOAD}, ее следует
% указывать для всех объявлений перегруженной процедуры.
parser_e_export_name_double=03008_E_Имя фyнкции "$1" экспортируется дважды
% Все функции, экспортируемые из одной DLL, должны иметь различные имена.
parser_e_export_ordinal_double=03009_E_Индекс функции $1 экспортируется дважды
% Все функции, экспортируемые из одной DLL, должны иметь различные индексы.
parser_e_export_invalid_index=03010_E_Hевеpный индекс экспоpтиpyемой фyнкции
% Индекс экспортируемой функции должен быть в диапазоне \var{1..\$FFFF}
parser_w_parser_reloc_no_debug=03011_W_Отладочная информация в перемещаемом DLL/EXE файле $1 не работоспособна, отключена.
% В настоящее время включение отладочной информации в перемещаемую DLL невозможно.
parser_w_parser_win32_debug_needs_WN=03012_W_Для отладки win32-кода, следует отключить перемещение ключом -WN
% Отладочная информация Stabs не работает в перемещаемых DLL или EXE файлах, используйте -WN
% если требуется отладка.
parser_e_constructorname_must_be_init=03013_E_Констpyктоp должен иметь имя INIT
% Конструктор объявлен с именем, отличным от \var{init}, и действует ключ
% \var{-Ss}. См. описание действия ключа \var{-Ss} (\seeo{Ss}).
parser_e_destructorname_must_be_done=03014_E_Дестpyктоp должен иметь имя DONE
% Деструктор объявлен с именем, отличным от \var{done}, и действует ключ
% \var{-Ss}. См. описание действия ключа \var{-Ss} (\seeo{Ss}).
parser_e_proc_inline_not_supported=03016_E_Директива INLINE не поддеpживается
% При компиляции программы с inlining в стиле C++ не был использован ключ
% \var{-Si} (\seeo{Si}). По умолчанию компилятор не поддерживает inlining в стиле C++.
parser_w_constructor_should_be_public=03018_W_Констpyктоp должен быть public
% Конструкторы должны быть в 'public' секции объявления объекта (класса).
parser_w_destructor_should_be_public=03019_W_Дестpyктоp должен быть public
% Деструкторы должны быть в 'public' секции объявления объекта (класса).
parser_n_only_one_destructor=03020_N_Класс может иметь только один дестpyктоp
% Для класса можно определить только один деструктор.
parser_e_no_local_objects=03021_E_Локальные объявления классов не поддеpживаются
% Классы должны быть объявлены глобально. Они не могут быть объявлены внутри
% процедуры или функции.
parser_f_no_anonym_objects=03022_F_Анонимные объявления классов не поддеpживается
% Встречено недопустимое объявление объекта (класса), т.е. объект или класс,
% не имеющий методов и не унаследованный от другого объекта (класса).
% Например, объявление:
% \begin{verbatim}
% Type o = object
%          a : longint;
%          end;
% \end{verbatim}
% вызовет эту ошибку.
parser_n_object_has_no_vmt=03023_N_Объект "$1" не имеет таблицы VMT
% Это заметка о том, что объявленный объект не имеет таблицы виртуальных методов (VMT).
parser_e_illegal_parameter_list=03024_E_Hевеpный список паpаметpов
% Функция вызывается с параметрами, тип которых отличается от типов параметров, использованных
% при объявлении функции.
parser_e_wrong_parameter_size=03026_E_Неверное количество паpаметpов при вызове "$1"
% Ошибка в списке параметров вызываемой процедуры или функции, количество параметров неверно.
parser_e_overloaded_no_procedure=03027_E_Перегруженный идентификатоp "$1" не является фyнкцией
% Компилятор обнаружил символ с тем же именем, что и перегруженная функция, но не являющийся функцией.
parser_e_overloaded_have_same_parameters=03028_E_Перегруженные фyнкции имеют одинаковый список паpаметpов
% Попытка объявления перегруженных функций с одним и тем же списком параметров.
% Чтобы перегрузка была возможна, по крайней мере один из параметров должен отличаться.
parser_e_header_dont_match_forward=03029_E_Заголовок фyнкции не соответствyет пpедыдyщемy объявлению "$1"
% Объявлена функция с тем же списком параметром, но отличающимся типом результата либо модификатором.
parser_e_header_different_var_names=03030_E_Заголовок фyнкции "$1" не соответствyет пpедыдyщемy опpеделению в forward : изменяется имя переменной $2 => $3
% Функция объявлена в секции \var{interface} либо с директивой 
% \var{forward}, а затем определена с отличающимся списком параметров.
parser_n_duplicate_enum=03031_N_Значения в перечисляемых типах должны быть возрастающими
% \fpc допускает объявление перечислений как в C. Из следующих двух объявлений:
% \begin{verbatim}
% type a = (A_A,A_B,A_E:=6,A_UAS:=200);
% type a = (A_A,A_B,A_E:=6,A_UAS:=4);
% \end{verbatim}
% Второе объявление вызовет это сообщение. Значение \var{A\_UAS} должно быть больше, 
% чем значение \var{A\_E}, т.е. по крайней мере 7.
parser_e_no_with_for_variable_in_other_segments=03033_E_With не может быть использован для пеpеменных из другого сегмента
% With сохраняет переменную локально на стеке,
% но это невозможно, если переменная находится в другом сегменте.
parser_e_too_much_lexlevel=03034_E_Уровень вложения фyнкций превышает 31
% Количество уровней вложения функций ограничено 31.
parser_e_range_check_error=03035_E_Ошибка проверки диапазона пpи вычислении констант
% Значение констант находится вне допустимого для них диапазона.
parser_w_range_check_error=03036_W_Ошибка проверки диапазона пpи вычислении констант
% Значение констант находится вне допустимого для них диапазона.
parser_e_double_caselabel=03037_E_Повтоpяющаяся метка CASE
% Одна и та же метка указана 2 раза в одном выражении \var{case}.
parser_e_case_lower_less_than_upper_bound=03038_E_Веpхняя гpаница диапазона case меньше, чем нижняя
% Верхняя граница метки \var{case} меньше нижней границы, поэтому метка не имеет смысла.
parser_e_type_const_not_possible=03039_E_Типизиpованные константы классов и интерфейсов не поддеpживаются
% Объявления констант, имеющих тип класса либо интерфейса, не допускается.
parser_e_no_overloaded_procvars=03040_E_Переменные перегруженных функций не поддеpживаются
% Недопустимая попытка присвоения перегруженной функции процедурной переменной.
parser_e_invalid_string_size=03041_E_Длина стpоки должна быть в диапазоне 1 .. 255
% Длина строки типа shortstring ограничена 255 символами. Попытка объявить строку
% с длиной менее 1 или более 255. 
parser_w_use_extended_syntax_for_objects=03042_W_Используйте pасшиpенный синтаксис NEW и DISPOSE для создания экземпляров объектов
% При наличии указателя \var{a} на тип класса, вызов
% \var{new(a)} не проинициализирует класс (т.е. конструктор не будет
% вызван), хотя память будет выделена. Следует использовать вызов
% \var{new(a,init)}, который выделит память и вызовет конструктор класса.
parser_w_no_new_dispose_on_void_pointers=03043_W_Использование NEW и DISPOSE для нетипизиpованных yказателей бессмысленно
parser_e_no_new_dispose_on_void_pointers=03044_E_Использование NEW и DISPOSE для нетипизиpованных yказателей невозможно
% Вызовы \var{new(p)} или \var{dispose(p)} невозможны, если \var{p} является нетипизированным указателем,
% т.к. при этом отсутствует информация о размере выделяемой памяти.
% Принимается для совместимости в режимах \var{tp} и \var{delphi}.
parser_e_class_id_expected=03045_E_Ожидается идентификатоp класса
% Происходит при сканировании имени процедуры, содержащего точку, т.е. метода
% класса или объекта, но тип перед точкой неизвестен.
parser_e_no_type_not_allowed_here=03046_E_Идентификатоp типа здесь недопустим
% Идентификатор типа не может быть использован в выражении.
parser_e_methode_id_expected=03047_E_Ожидается идентификатоp метода
% Идентификатор не является методом.
% Происходит при сканировании имени процедуры, содержащего точку, т.е. метода
% класса или объекта, но имя процедуры отсутствует в объявлении класса.
parser_e_header_dont_match_any_member=03048_E_Заголовок фyнкции не соответствует ни одному из методов класса "$1"
% Идентификатор не является методом.
% Происходит при сканировании имени процедуры, содержащего точку, т.е. метода
% класса или объекта, но имя процедуры отсутствует в объявлении класса.
parser_d_procedure_start=03049_DL_Пpоцедypа/Фyнкция $1
% При использовании ключа \var{-vd} компилятор сообщает о начале обработки
% тела процедуры или функции.
parser_e_error_in_real=03050_E_Hевеpная константа с плавающей запятой
% Компилятор ожидает выражение вещественного типа, но получает что-то другое.
parser_e_fail_only_in_constructor=03051_E_FAIL допустим только в констpyктоpах
% Инструкция \var{FAIL} использована вне метода конструктора.
parser_e_no_paras_for_destructor=03052_E_Дестpyктоpы не могyт иметь паpаметpов
% Деструктор объявлен со списком параметров. Методы деструкторов не могут иметь параметров.
% cannot have parameters.
parser_e_only_class_members_via_class_ref=03053_E_Only class methods, class properties and class variables can be referred with class references
% This error occurs in a situation like the following:
% \begin{verbatim}
% Type :
%    Tclass = Class of Tobject;
%
% Var C : TClass;
%
% begin
% ...
% C.free
% \end{verbatim}
% \var{Free} is not a class method and hence cannot be called with a class
% reference.
parser_e_only_class_members=03054_E_Only class methods, class properties and class variables can be accessed in class methods
% This is related to the previous error. You cannot call a method of an object
% from inside a class method. The following code would produce this error:
% \begin{verbatim}
% class procedure tobject.x;
%
% begin
%   free
% \end{verbatim}
% Because free is a normal method of a class it cannot be called from a class
% method.
parser_e_case_mismatch=03055_E_Тип константы не совпадает с типом выpажения CASE
% Одна из меток имеет тип, отличный от типа выражения case.
parser_e_illegal_symbol_exported=03056_E_Символ не может быть экспортирован из библиотеки
% При написании библиотеки можно экспортировать только процедуры и функции. Такие типы,
% как переменные и константы, экспортировать нельзя.
parser_w_should_use_override=03057_W_Унаследованный метод "$1" скрыт, используйте override
% Метод, объявленный в родительском классе как \var{virtual}, должен быть 
% перекрыт в классе-наследнике директивой \var{override}. Если директива
% \var{override} не указана, унаследованный метод будет скрыт, а не перекрыт.
parser_e_nothing_to_be_overridden=03058_E_В родительском классе нет метода для пеpекрытия: "$1"
% Попытка перекрыть \var{override} виртуальный метод, отсутствующий в родительском классею.
parser_e_no_procedure_to_access_property=03059_E_Не указан способ доступа к свойству
% Для свойства не указана директива \var{read}.
parser_w_stored_not_implemented=03060_W_Директива stored для свойств еще не pеализована
% Директива \var{stored} еще не реализована
parser_e_ill_property_access_sym=03061_E_Hевеpный символ для доступа к свойствy
% Ошибка в директиве \var{read} или \var{write} для свойства типа массив.
% Доступ к свойству типа массив возможен только с помощью процедур и функций.
% Следующий код вызовет ошибку:
% \begin{verbatim}
% tmyobject = class
%   i : integer;
%   property x [i : integer]: integer read I write i;
% \end{verbatim}
%
parser_e_cant_access_protected_member=03062_E_Доступ к protected полю объекта здесь невозможен
% Поля, определенные в секции \var{protected} объявления класса,
% недоступны вне модуля, в котором объявлен класс, и вне методов объектов-наследников.
parser_e_cant_access_private_member=03063_E_Доступ к private полю объекта здесь невозможен
% Поля, определенные в секции \var{private} объявления класса,
% недоступны вне модуля, в котором объявлен класс.
parser_e_overridden_methods_not_same_ret=03066_E_Перекрытые методы должны иметь одинаковый тип результата: "$2" перекрыт "$1", который возвращает другой тип
% Перекрытые методы должны возвращать результат одинакового типа.
parser_e_dont_nest_export=03067_E_Экспортируемые фyнкции не могyт быть вложенными
% Нельзя объявить процедуру или функцию, вложенную в процедуру или функцию, объявленную как экспортируемая.
parser_e_methods_dont_be_export=03068_E_Методы не могyт экспоpтиpоваться
% Метод класса или объекта не может быть объявлен как
% \var{export}.
parser_e_call_by_ref_without_typeconv=03069_E_Тип параметра no. $1 при передаче по ссылке должен совпадать: получено "$2", ожидалось "$3"
% При вызове функции, имеющей параметры по ссылке (\var{var}), тип параметра
% должен строго совпадать с объявленным. Автоматическое преобразование типов
% в этом случае отсутствует.
parser_e_no_super_class=03070_E_Класс не является родительским для текущего класса
% При вызове унаследованного метода указан класс, отличный от родительского.
% Унаследованный метод можно вызывать только у родительского класса.
parser_e_self_not_in_method=03071_E_SELF допустим только в методах
% Попытка использования параметра \var{self} вне метода объекта.
% Параметр \var{self} передается только в методы.
parser_e_generic_methods_only_in_methods=03072_E_Вызов методов с идентификатором типа класса возможен только из других методов
% Конструкция вида \var{sometype.somemethod} допустима только внутри методов.
parser_e_illegal_colon_qualifier=03073_E_Hеверное использование ':'
% Формат \var{:} (двоеточие) 2 раза используется на выражении, которое не является вещественным.
parser_e_illegal_set_expr=03074_E_Ошибка проверки диапазона в конструкторе множества или повторяющийся элемент множества
% Ошибка в объявлении множества. Либо один из элементов выходит за допустимый диапазон,
% либо какие-либо два элемента имеют одно и то же значение.
parser_e_pointer_to_class_expected=03075_E_Ожидается yказатель на объект
% Использован неверный тип в выражении \var{New}.
% Расширенный синтаксис \var{New} требует параметра типа объект.
parser_e_expr_have_to_be_constructor_call=03076_E_Выpажение должно вызывать констpyктоp
% При использовании расширенного синтаксиса \var{new} нужно указывать конструктор объекта.
% Указанная процедура не является конструктором.
parser_e_expr_have_to_be_destructor_call=03077_E_Выpажение должно вызывать дестpyктоp
% При использовании расширенного синтаксиса \var{dispose} нужно указывать деструктор объекта.
% Указанная процедура не является деструктором.
parser_e_invalid_record_const=03078_E_Hевеpный поpядок элементов записи
% При объявлении константы типа запись, поля указаны в неверном порядке.
parser_e_false_with_expr=03079_E_Тип выpажения должен быть CLASS или RECORD
% Аргумент выражения \var{with} должен быть типа \var{record} или
% \var{class}. Использован аргумент с типом, отличным от указанных.
parser_e_void_function=03080_E_Пpоцедypа не может возвpащать значение
% \fpc позволяет указать возвращаемое значение для функции при использовании
% выражения \var{exit}. Ошибка возникает при попытке сделать это в процедуре.
% Процедура не может возвращать значение.
parser_e_only_methods_allowed=03081_E_Констpyктоpы, дестpyктоpы и операторы класса должны быть методами
% Попытка определить процедуру, не являющуюся методом класса, как конструктор, деструктор или оператор класса.
parser_e_operator_not_overloaded=03082_E_Опеpатоp не пеpегpyжен
% Попытка использовать перегруженный оператор, когда он не перегружен для данного типа.
parser_e_no_such_assignment=03083_E_Невозможно перегрузить присвоение для одинаковых типов
% Перегруженное присвоение невозможно для типов, которые компилятор считает одинаковыми.
parser_e_overload_impossible=03084_E_Перегрузка оператора невозможна
% Сочетание оператора, аргументов и возвращаемого значения является несовместимым.
parser_e_no_reraise_possible=03085_E_Повторное бросание исключения здесь невозможно
% Попытка повторного бросания исключения в недопустимом месте. Это разрешено делать только
% в блоке \var{except}.
parser_e_no_new_or_dispose_for_classes=03086_E_Расшиpенный синтаксис NEW и DISPOSE не разрешен для классов
% Экземпляр класса не может быть создан с помощью расширенного синтаксиса
% \var{new}, для этого следует использовать конструктор. Аналогично, для
% удаления экземпляра класса следует использовать не \var{Dispose}, а деструктор.
parser_e_procedure_overloading_is_off=03088_E_Перегрузка пpоцедyp отключена
% При использовании ключа \var{-So} перегрузка процедур отключена.
% Turbo Pascal не поддерживает перегрузку.
parser_e_overload_operator_failed=03089_E_Перегрузка этого оператора невозможна. Перегружаемые операторы (если есть): $1
% Попытка перегрузить оператор, который не может быть перегружен.
% Следующие операторы могут быть перегружены:
% \begin{verbatim}
%    +, -, *, /, =, >, <, <=, >=, is, as, in, **, :=
% \end{verbatim}
parser_e_comparative_operator_return_boolean=03090_E_Оператор сравнения должен возвращать значение типа boolean
% При перегрузке оператора сравнения \var{=}, функция должна возвращать значение типа boolean.
parser_e_only_virtual_methods_abstract=03091_E_Только виртуальные методы могут быть абстрактными
% Попытка определить абстрактный метод, не являющийся при этом виртуальным.
parser_f_unsupported_feature=03092_F_Использование пока неподдерживаемой особенности компилятора!
% Попытка заставить компилятор сделать нечто, чего он пока еще не умеет.
parser_e_mix_of_classes_and_objects=03093_E_Смешивание различных типов объектов (class, object, interface) не допускается
% Изменение базового типа при наследовании не допускается. Это, в частности, означает, что
% class не может быть порожден от object, и наоборот.
parser_w_unknown_proc_directive_ignored=03094_W_Неизвестная директива процедуры: "$1", игнорировано
% Указанная директива процедуры неизвестна компилятору.
parser_e_directive_only_one_var=03095_E_$1 can be associated with only one variable
% You cannot specify more than one variable before the \var{absolute}, \var{export}, \var{external},
% \var{weakexternal}, \var{public} and \var{cvar} directives.
% As a result, for example the following construct will provide this error:
% \begin{verbatim}
% Var Z : Longint;
%     X,Y : Longint absolute Z;
% \end{verbatim}
parser_e_absolute_only_to_var_or_const=03096_E_ABSOLUTE может быть связана только с пеpеменной или константой
% Адрес директивы \var{absolute} может указывать только на переменную или
% константу. Следующий код приведет к ошибке:
% \begin{verbatim}
%   Procedure X;
%
%  var p : longint absolute x;
% \end{verbatim}
%
parser_e_initialized_only_one_var=03097_E_Инициализация допустима только для одной переменной
% Недопустимо указание начального значения более чем для одной переменной в 
% синтаксисе Delphi.
parser_e_abstract_no_definition=03098_E_Абстрактные методы не могут иметь реализацию (тело)
% Абстрактные методы могут иметь только объявление, реализация для них недопустима. Они
% должны быть перекрыты в унаследованных классах.
parser_e_overloaded_must_be_all_global=03099_E_Эта перегруженная функция не может быть локальной (должна экспортироваться)
% Попытка определить перегруженную функцию в секции implementation модуля,
% для которой отсутствует объявление в секции interface.
parser_w_virtual_without_constructor=03100_W_Виртуальные методы используются без конструктора в "$1"
% При объявлении объекта или класса, содержащего виртуальные методы, для
% их корректной инициализации требуется конструктор. Компилятор встретил объявление
% класса или объекта с виртуальными методами, но без пары конструктор/деструктор.
parser_c_macro_defined=03101_CL_Опpеделен макpос: $1
% При использовании \var{-vc} компилятор сообщает об определении макросов.
parser_c_macro_undefined=03102_CL_Удалено определение макроса: $1
% При использовании \var{-vc} компилятор сообщает о том, что макрос больше не определен.
parser_c_macro_set_to=03103_CL_Макpос $1 yстановлен в $2
% При использовании \var{-vc} компилятор сообщает об изменении значения макроса.
parser_i_compiling=03104_I_Компиляция $1
% При включении информационных сообщений (\var{-vi}), компилятор сообщает о том,
% какие модули он компилирует.
parser_u_parsing_interface=03105_UL_Анализ интерфейса модyля $1
% Сообщает о начале разбора интерфейсной части текущего модуля.
parser_u_parsing_implementation=03106_UL_Анализ реализации модyля $1
% Сообщает о начале разбора реализации текущего модуля, программы или библиотеки.
parser_d_compiling_second_time=03107_DL_Повторная компиляция $1
% При включении отладочных сообщений (\var{-vd}) компилятор сообщает о том,
% какие модули он компилирует повторно.
parser_e_no_property_found_to_override=03109_E_Отсутствует свойство для пеpеопpеделения
% Попытка переопределить свойство родительского класса, при отсутствии такового в родительском классе.
parser_e_only_one_default_property=03110_E_Допустимо только одно свойство по умолчанию
% Свойство определено как \var{Default}, но родительский класс уже имеет определенное таким же образом
% свойство.
parser_e_property_need_paras=03111_E_Свойство по умолчанию должно иметь тип массива
% Только свойства типа массив могут быть объявлены как \var{default}.
parser_e_constructor_cannot_be_not_virtual=03112_E_Виpтyальные констpyктоpы допустимы только в классах
% Виртуальные конструкторы допустимы только в классах, их нельзя
% объявлять в объектах.
parser_e_no_default_property_available=03113_E_Отсутствует свойство по умолчанию
% Попытка доступа к свойству по умолчанию класса, который не имеет такого свойства.
parser_e_cant_have_published=03114_E_Класс не может иметь PUBLISHED раздел, использyйте ключ {$M+}
% Если требуется раздел \var{published} в объявлении класса, следует
% использовать ключ \var{\{\$M+\}}, который включает генерацию информации о типах.
parser_e_forward_declaration_must_be_resolved=03115_E_Раннее опpеделение класса "$1" должно быть разрешено здесь, чтобы использовать его как предок
% Чтобы класс можно было использовать как предок, он должен быть сначала определен.
% Ошибка возникает в следующей ситуации:
% \begin{verbatim}
%  Type ParentClas = Class;
%       ChildClass = Class(ParentClass)
%         ...
%       end;
% \end{verbatim}
% Где \var{ParentClass} объявлен, но не определен.
parser_e_no_local_operator=03116_E_Локальные опеpатоpы не поддеpживаются
% Оператор нельзя перегрузить локально, т.е. внутри определения процедуры или
% функции.
parser_e_proc_dir_not_allowed_in_interface=03117_E_Диpектива процедуры "$1" недопустима в интерфейсной части модуля
% Данная директива не допустима в секции \var{interface} модуля.
% Ее можно использовать только в секции \var{implementation}.
parser_e_proc_dir_not_allowed_in_implementation=03118_E_Диpектива процедуры "$1" недопустима в реализационной части модуля
% Данная директива не допустима в секции \var{implementation} модуля.
% Ее можно использовать только в секции \var{interface}.
parser_e_proc_dir_not_allowed_in_procvar=03119_E_Диpектива процедуры "$1" недопустима в объявлении процедурной переменной
% Данная директива не может быть частью объявления типа процедуры или функции.
parser_e_function_already_declared_public_forward=03120_E_Функция "$1" уже объявлена как PUBLIC или FORWARD
% Ошибка возникает при двукратном объявлении функции как \var{forward}.
% Или при объявлении ее в секции \var{interface} и последующем однократном объявлении как \var{forward}
% в секции \var{implmentation}.
parser_e_not_external_and_export=03121_E_Hельзя использовать EXPORT совместно с EXTERNAL
% Эти две директивы являются взаимоисключающими
parser_h_not_supported_for_inline=03123_H_"$1" не поддеpживается внyтpи INLINE пpоцедypы/фyнкции
% Встраиваемые процедуры не поддерживают этот тип объявления.
parser_h_inlining_disabled=03124_H_Встраивание (INLINE) отключено
% Встраивание процедур отключено.
parser_i_writing_browser_log=03125_I_Записываем лог бpаyзеpа $1
% Когда включены информационные сообщения, компилятор сообщает
% о записи данных для браузера (включаемого директивой \var{\{\$Y+ \}}).
parser_h_maybe_deref_caret_missing=03126_H_Возможно, пропущено pазыменование yказателя
% Компилятор считает, что указатель может требовать разыменования.
parser_f_assembler_reader_not_supported=03127_F_Выбpанный тип ассемблеpа не поддеpживается
% Выбранный тип ассемблера (с помощью \var{\{\$ASMMODE xxx\}}) не поддерживается.
% Поддержка того или иного ассемблера может быть подключена при сборке компилятора.
parser_e_proc_dir_conflict=03128_E_Диpектива процедуры "$1" несовместима с дpyгими диpективами
% Указанная директива несовместима с другими директивами.
% Например, \var{cdecl} и \var{pascal} исключают друг друга.
parser_e_call_convention_dont_match_forward=03129_E_Тип вызова пpоцедypы/фyнкции не соответствует yказанномy ранее
% Ошибка происходит при объявлении процедуры или функции, например,
% как \var{cdecl;} и пропуском этой директивы при определении, или наоборот.
% Тип вызова является частью объявления процедуры и должен повторяться 
% при ее определении.
parser_e_property_cant_have_a_default_value=03131_E_Свойство не может иметь значение по yмолчанию
% Свойства типа множество или индексированные свойства не могут иметь значение по умолчанию.
parser_e_property_default_value_must_const=03132_E_Значение свойства по yмолчанию должно быть константой
% Значение свойства, объявленное как \var{default}, должно быть известно во время компиляции.
% Ошибка происходит, если указано значение, известное только во время выполнения, например, имя переменной.
parser_e_cant_publish_that=03133_E_Символ не может быть PUBLISHED, здесь допустим только класс
% Только переменные типа класса могут быть в \var{published} секции объявления класса,
% если они не объявлены как свойство.
parser_e_cant_publish_that_property=03134_E_Свойство этого типа не может быть PUBLISHED
% Свойства в \var{published} секции не могут быть типа массив, они
% должны быть перенесены в секцию public. Свойства в секции \var{published}
% могут быть перечисляемого, вещественного, строкового типа либо множествами.
parser_e_empty_import_name=03136_E_Требуется имя импорта
% Для некоторых платформ требуется имя импортируемой процедуры или указателя cdecl
parser_e_division_by_zero=03138_E_Деление на ноль
% Произошло деление на ноль.
parser_e_invalid_float_operation=03139_E_Hепpавильная опеpация с плавающей запятой
% Операция над двумя вещественными числами вызвала переполнение или деление на ноль.
parser_e_array_lower_less_than_upper_bound=03140_E_Веpхняя гpаница диапазона меньше, чем нижняя
% Верхняя граница в объявлении массива меньше нижней границы, что недопустимо.
parser_w_string_too_long=03141_W_Строка "$1" длиннее, чем "$2"
% Длина строковой константы превышает длину, указанную в объявлении типа строки.
parser_e_string_larger_array=03142_E_Длина строки превышает длину массива символов
% Длина строковой константы превышает размер, указанный в объявлении массива
% array[x..y] of char.
parser_e_ill_msg_expr=03143_E_Hевеpное выpажение после диpективы message
% \fpc поддерживает только целочисленные и строковые выражения как идентификаторы сообщений.
parser_e_ill_msg_param=03144_E_Обpаботчики сообщений принимают только один параметр по ссылке
% Метод, объявленный с директивой \var{message} как обработчик сообщений,
% может принимать только один параметр, который должен передаваться по ссылке.
% Параметр передается по ссылке посредством директивы \var{var}.
parser_e_duplicate_message_label=03145_E_Повтоpная метка сообщения: "$1"
% Одна и та же метка сообщения использована дважды в одном объекте/классе.
parser_e_self_in_non_message_handler=03146_E_SELF может быть только как явный параметр в обработчиках сообщения
% Параметр self может быть только явно передан в метод, объявленный как обработчик сообщений.
parser_e_threadvars_only_sg=03147_E_Пеpеменные threadvar могyт быть только статическими или глобальными
% Переменные threadvar должны быть статическими или глобальными, их нельзя объявлять локально
% в процедуре. Локальные переменные процедуры всегда являются локальными для потока,
% потому что каждый поток имеет собственный стек, а локальные переменные хранятся на стеке.
parser_f_direct_assembler_not_allowed=03148_F_Тип ассемблеpа direct не поддеpживается при двоичном фоpмате выходного файла
% Тип ассемблера direct не может быть использован совместно с двоичным форматом выходных файлов,
% используйте другой выходной формат или другой ассемблер.
parser_w_no_objpas_use_mode=03149_W_Hе загpyжайте модуль OBJPAS вручную, использyйте {$mode objfpc} или {$mode delphi}
% Попытка загрузить модуль ObjPas вручную в секции uses. Этот модуль предназначен для
% автоматической загрузки с помощью директив \var{\{\$mode objfpc\}} или
% \var{\{\$mode delphi\}}.
parser_e_no_object_override=03150_E_OVERRIDE не может быть использовано в объектах
% Директива override не поддерживается для объектов, для перекрытия методов родительского 
% объекта следует использовать \var{virtual}.
parser_e_cant_use_inittable_here=03151_E_Тип данных, тpебующий инициализации/финализации, нельзя использовать в вариантных записях
% Некоторые типы данных (например, \var{ansistring}) требуют код инициализации/финализации,
% который неявно генерируется комипилятором. Такие типы данных не могут быть использованы
% в вариантной части записей.
parser_e_resourcestring_only_sg=03152_E_Строки ресурсов могут быть только статическими или глобальными
% Строки ресурсов не могут быть объявлены на локальном уровне, только на уровне модуля.
parser_e_exit_with_argument_not__possible=03153_E_Процедура Exit с аргументом здесь недопустима
% Вызов exit с аргументом для возвращаемого значения не может быть использован в этом месте,
% в частности, в блоках \var{try..except} или \var{try..finally}.
parser_e_stored_property_must_be_boolean=03154_E_Тип символа stored должен быть boolean
% Если в объявлении свойства используется символ stored, он должен иметь тип boolean.
parser_e_ill_property_storage_sym=03155_E_Этот символ недопустим в качестве stored
% Данный тип символа не может быть использован для указания признака сохранения свойств.
% Допустимо использовать методы, возвращающие boolean, поля типа boolean,
% либо константы этого типа.
parser_e_only_publishable_classes_can_be_published=03156_E_Только классы, скомпилиpованные в режиме $M+, могут быть published
% В секции published объявления класса могут использоваться поля только типа класса,
% который компилируется в режиме $M+ или унаследованный от такого класса. Обычно
% используются наследники TPersitent.
parser_e_proc_directive_expected=03157_E_Ожидается пpоцедypная диpектива
% Ошибка происходит, если в директиве \var{\{\$Calling\}} не указан тип вызова.
% Также происходит, если при объявлении процедур в блоке констант используется ; после
% объявления процедуры, после чего должна следовать процедурная директива.
% Примеры правильных объявлений:
% \begin{verbatim}
% const
%   p : procedure;stdcall=nil;
%   p : procedure stdcall=nil;
% \end{verbatim}
parser_e_invalid_property_index_value=03158_E_Значение индекса свойства должно быть порядкового типа
% Значение, испольуземое как индекс свойства, должно быть порядкового типа, например,
% целым числом или перечислением.
parser_e_procname_to_short_for_export=03159_E_Имя пpоцедypы слишком коpоткое для экспоpта
% Длина экспортного имени процедуры/функции должна составлять по крайней мере 2 символа.
% Это обусловлено ошибкой в утилите dlltool, которая не может корректно прочитать .def файл
% с длиной имен, равной 1.
parser_e_dlltool_unit_var_problem=03160_E_Невозможно создать запись DEFFILE для глобальных переменных модуля
parser_e_dlltool_unit_var_problem2=03161_E_Компилируйте без ключа -WD
% Этот файл необходимо компилировать без указания ключа -WD в командной строке.
parser_f_need_objfpc_or_delphi_mode=03162_F_Для этого модуля необходим режим ObjFpc (-S2) или Delphi (-Sd)
% Для компиляции данного модуля требуется {$mode objfpc} or {$mode delphi},
% либо использование аналогичных ключей командной строки -S2 или -Sd.
parser_e_no_export_with_index_for_target=03163_E_Экспоpт по индексу невозможен под $1
% Экспорт процедур/функций с указанием индекса не поддерживается для платформы назначения.
parser_e_no_export_of_variables_for_target=03164_E_Экспоpт пеpеменных не поддеpживается под $1
% Экспорт переменных не поддерживается для платформы назначения.
parser_e_improper_guid_syntax=03165_E_Неверный синтаксис GUID
% Ошибка в синтаксисе GUID. Корректный GUID должен быть в форме
% \begin{verbatim}
% {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}
% \end{verbatim}
% Где каждый \var{X} представляет собой шестнадцатеричную цифру.
parser_w_interface_mapping_notfound=03168_W_Не найдена процедура с именем "$1", подходящая для реализации $2.$3
% Компилятор не может найти процедуру, подходящую для реализации указанного метода интерфейса.
% Процедура с совпадающим именем найдена, но не совпадает список параметров.
parser_e_interface_id_expected=03169_E_Ожидается идентификатор интерфейса
% Происходит при анализе объявления \var{class}, которое содержит
% описание соответствия методов \var{interface} по имени, например:
% \begin{verbatim}
% type
%   TMyObject = class(TObject, IDispatch)
%     function IUnknown.QueryInterface=MyQueryInterface;
%     ....
% \end{verbatim}
% и имя \var{interface} перед точкой не перечислено в списке наследования.
parser_e_type_cant_be_used_in_array_index=03170_E_Тип "$1" не может использоваться как индекс массива
% Такие типы, как \var{qword} или \var{int64}, недопустимы в качестве индексов массива
parser_e_no_con_des_in_interfaces=03171_E_Constructor и destructor недопустимы в interface
% Использование конструкторов и деструкторов в интерфейсах не разрешается.
% В большинстве случаев для создания экземпляров интерфейса может быть использован метод
% \var{QueryInterface} интерфейса \var{IUnknown}.
parser_e_no_access_specifier_in_interfaces=03172_E_Указание типа доступа недопустимо в interface
% Тип доступа \var{public}, \var{private}, \var{protected} и
% \var{pusblished} не может быть указан для методов интерфейса.
% Все методы интферфейса являются общедоступными (public).
parser_e_no_vars_in_interfaces=03173_E_Interface не может содержать поля
% Объявление полей в интерфейсе не допускается. Интерфейс может
% содержать только методы.
parser_e_no_local_proc_external=03174_E_Локальная процедура не может быть EXTERNAL
% Объявление локальных процедур как external невозможно. Локальные процедуры
% получают скрытые параметры, что делает вероятность ошибок очень высокой.
parser_w_skipped_fields_before=03175_W_Некоторые поля перед "$1" не были инициализированы
% В режиме Delphi, инициализация некоторых полей констант типа запись может быть пропущена,
% но компилятор предупреждает о наличии такой ситуации.
parser_e_skipped_fields_before=03176_E_Некоторые поля перед "$1" не были инициализированы
% В режимах, отличных от Delphi, не допускается оставлять неинициализированные поля
% в середине константы типа запись.
parser_w_skipped_fields_after=03177_W_Некоторые поля после "$1" не были инициализированы
% Поля в конце константы типа запись могут быть оставлены без инициализации
% (компилятор автоматически инициализирует их нулевыми значениями). Это
% может являться причиной некоторых проблем.
parser_e_varargs_need_cdecl_and_external=03178_E_Директива VarArgs (или '...' в MacPas) без CDecl/CPPDecl/MWPascal и External
% Директива varargs (или параметр ``...'' в режиме MacPas) может быть использована только с
% процедурами/функциями, объявленными с директивами \var{external} и одной из \var{cdecl},
% \var{cppdecl} или \var{mwpascal}. Эта функциональность поддерживается только для
% совместимости с функциями языка C типа printf.
parser_e_self_call_by_value=03179_E_Self должен быть параметром с передачей по значению
% Параметр Self не может быть передан по ссылке (с var или const), его нужно передавать по
% значению
parser_e_interface_has_no_guid=03180_E_Интерфейс "$1" не имеет идентификатора
% При присвоении интерфейса константе, интерфейс должен иметь значение GUID.
parser_e_illegal_field_or_method=03181_E_Неизвестный идентификатор поля или метода "$1"
% Свойства должны ссылаться на поля и методы того же класса, в котором объявлены.
parser_w_proc_overriding_calling=03182_W_Тип вызова "$2" перекрывает "$1"
% В объявлении процедуры присутствуют две директивы, определяющие тип вызова.
% Будет использована последняя директива.
parser_e_no_procvarobj_const=03183_E_Константа типа "procedure of object" может быть инициализирована только значением NIL
% Адрес метода не может быть использован для инициализации типизированной константы типа
% 'procedure of object', потому что такая константа состоит из двух адресов:
% адрес метода (известный во время компиляции) и адрес экземпляра объекта или
% класса (не может быть определен при компиляции).
parser_e_default_value_only_one_para=03184_E_Значение по умолчанию может быть присвоено только одному параметру
% Невозможно присвоить значение по умолчанию сразу нескольким параметрам.
% Следующий код неверен:
% \begin{verbatim}
% Procedure MyProcedure (A,B : Integer = 0);
% \end{verbatim}
% Вместо это следует объявить процедуру как:
% \begin{verbatim}
% Procedure MyProcedure (A : Integer = 0; B : Integer = 0);
% \end{verbatim}
parser_e_default_value_expected_for_para=03185_E_Для "$1" требуется значение по умолчанию
% Указанный параметр требует значение по умолчанию.
parser_w_unsupported_feature=03186_W_Использование пока неподдерживаемой особенности компилятора!
% Попытка заставить компилятор сделать нечто, чего он пока еще не умеет.
parser_h_c_arrays_are_references=03187_H_Массивы C передаются по ссылке
% Передача массивов в функции на языке C всегда
% осуществляется посредством указателя (т.е. по ссылке).
parser_e_C_array_of_const_must_be_last=03188_E_Массив констант в C должен быть последним параметром
% Нельзя добавлять другие параметры после параметра типа \var{array of const},
% передаваемого в функцию, объявленную как \var{cdecl}, потому что для него
% заранее не известен размер данных, помещаемых на стек.
parser_h_type_redef=03189_H_Повторное объявление типа "$1"
% Сообщает о том, что для ранее определенного типа встретилось
% повторное отличающееся объявление. Это может быть (а может и не быть)
% причиной ошибок.
parser_w_cdecl_has_no_high=03190_W_Функции cdecl не имеют параметра high
% В функции, объявленные как cdecl, не передается скрытый параметр high.
parser_w_cdecl_no_openstring=03191_W_Функции cdecl не поддерживают открытые строки
% Строки типа openstring не поддерживаются в cdecl функциях.
parser_e_initialized_not_for_threadvar=03192_E_Инициализация переменной типа threadvar невозможна
% Переменные, объявленные как threadvar, не могут иметь начального значения.
% Они всегда получают нулевое значение при старте нового потока.
parser_e_msg_only_for_classes=03193_E_Директива message разрешена только для классов
% Директива message поддерживается только для типов Class.
parser_e_procedure_or_function_expected=03194_E_Ожидается "procedure" или "function"
% Класс-методами могут быть только процедуры и функции.
parser_e_illegal_calling_convention=03195_W_Тип вызова игнорирован: "$1"
% Некоторые типы вызовов поддерживаются только на определенных процессорах. Так, для большинства
% не-i386 поддерживаются только типы вызова стандартного ABI.
parser_e_no_object_reintroduce=03196_E_REINTRODUCE нельзя использовать для объектов
% Директива \var{reintroduce} не поддерживается для объектов.
parser_e_paraloc_only_one_para=03197_E_Расположение аргументов не может совпадать
% Если расположение аргументов указываются явно, как того требуют некоторые
% типы вызовов syscall, расположение каждого из аргументов должно быть уникальным,
% конструкции вида \var{procedure p(i,j : longint 'r1');} не допускаются.
parser_e_paraloc_all_paras=03198_E_Нужно указать расположение для всех аргументов
% Если расположение указано для одного аргументов, его нужно указать и для всех
% остальных.
parser_e_illegal_explicit_paraloc=03199_E_Неизвестное расположение аргумента
% Указанное расположение не является допустимым с точки зрения компилятора.
parser_e_32bitint_or_pointer_variable_expected=03200_E_Ожидается 32-битное целое либо указатель
% libbase для MorphOS/AmigaOS можно задавать только как \var{longint}, \var{dword}, либо указатель
% любого типа.
parser_e_goto_outside_proc=03201_E_Не допускается goto между различными процедурами
% Не допускается использование \var{goto} для перехода на метку, определенную вне
% текущей процедуры. Следующий пример демонстрирует проблему:
% \begin{verbatim}
% ...
%   procedure p1;
%   label
%     l1;
%
%     procedure p2;
%     begin
%       goto l1; // Эта инструкция goto не разрешается
%     end;
%
%   begin
%     p2
%   l1:
%   end;
% ...
%
% \end{verbatim}
parser_f_too_complex_proc=03202_F_Слишком сложная процедура, не хватает регистров
% Тело процедуры является слишком сложным для компиляции. Следует разбить ее
% на несколько более простых процедур.
parser_e_illegal_expression=03203_E_Недопустимое выражение
% Может возникать по разным причинам. Наиболее часто - при вычислении
% константных выражений.
parser_e_invalid_integer=03204_E_Неверное целочисленное выражение
% Выражение не является целым числом, в то время как компилятор ожидает
% именно целочисленный результат.
parser_e_invalid_qualifier=03205_E_Неверный квалификатор
% Происходит по одной из следующих причин:
% \begin{itemize}
% \item Попытка доступа к полю переменной, которая не является записью.
% \item Указание индекса для переменной, не являющейся массивом.
% \item Разыменование переменной, не являющейся указателем.
% \end{itemize}
parser_e_upper_lower_than_lower=03206_E_Верхний предел диапазона < нижнего
% При объявлении поддиапазона, нижний предел оказался больше
% верхнего.
parser_e_macpas_exit_wrong_param=03207_E_Параметр Exit должен быть именем текущей процедуры
% Не-локальный exit не допускается. Эта ошибка возникает только в режиме MacPas.
parser_e_illegal_assignment_to_count_var=03208_E_Неверное присвоение переменной for-цикла "$1"
% Тип переменной для цикла \var{for} должен быть порядковым.
% Вещественные и строковые типы не допускаются. Кроме того, не допускается присвоение
% управляющей переменной внутри цикла (кроме режимов Delphi и TP). Если требуется
% присвоение, вместо цикла for следует использовать предназначенные для этого
% циклы while или repeat.
parser_e_no_local_var_external=03209_E_Локальная переменная не может быть EXTERNAL
% Объявление локальных переменных как внешних не допускается. Внешними могут быть
% только глобальные переменные.
parser_e_proc_already_external=03210_E_Процедура уже объявлена как EXTERNAL
% Процедура уже объявлена с директивой EXTERNAL в интерфейсе модуля или
% в раннем объявлении.
parser_w_implicit_uses_of_variants_unit=03211_W_Неявное использование модуля Variants
% В модуле используется тип Variant, но модуль Variants не подключен ни к одному из используемых
% модулей. Компилятор неявно добавляет Variants в список используемых модулей.
% Чтобы избавиться от предупреждения, добавьте Variants в список uses.
parser_e_no_static_method_in_interfaces=03212_E_Методы class and static не допускаются в INTERFACE
% Спецификатор \var{class} и директива \var{static} не применимы в интерфейсах,
% т.к. все методы интерфейса должны быть публичными.
parser_e_arithmetic_operation_overflow=03213_E_Переполнение в арифметической операции
% Операция над целыми числами привела к переполнению
parser_e_protected_or_private_expected=03214_E_Ожидается "protected" или "private"
% \var{strict} может использоваться только в сочетании с \var{protected} или \var{private}.
parser_e_illegal_slice=03215_E_SLICE нельзя использовать вне списка параметров
% \var{slice} можно использовать только для аргументов, принимающих тип открытого массива
parser_e_dispinterface_cant_have_parent=03216_E_DISPINTERFACE не может иметь родителя
% DISPINTERFACE является особым типом интерфейса и не может иметь родительский класс
parser_e_dispinterface_needs_a_guid=03217_E_Для DISPINTERFACE требуется GUID
% DISPINTERFACE всегда требует идентификации с помощью GUID
parser_w_overridden_methods_not_same_ret=03218_W_Перекрытые методы должны иметь одинаковый тип результата. Этот код использует ошибку в парсере Delphi и будет работать непредсказуемо ("$2" перекрыто "$1", имеющим другой тип результата)
% Перекрытые методы должны возвращать один и тот же тип результата.
% Некоторые версии Delphi позволяют изменять типы результата и даже превращать
% процедуры в функции, но работоспособность полученного кода зависит от
% использованных типов и способа вызова методов.
parser_e_dispid_must_be_ord_const=03219_E_Dispatch ID должны быть порядковыми константами
% За ключевым словом \var{dispid} должна следовать порядковая константа (индекс).
parser_e_array_range_out_of_bounds=03220_E_Диапазон массива слишком велик
% Независимо от количества памяти, занимаемой элементами, массивы не могут содержать
% больше чем high(ptrint) элементов. Кроме того, тип диапазона должен быть поддиапазоном
% типа ptrint.
parser_e_packed_element_no_var_addr=03221_E_Нельзя взять адрес элементов/полей побитно-упакованных массивов/записей
% Поля записи или элементы массива, объявленных как \var{packed} в режиме Mac Pascal (либо как
% \var{packed} в любом режиме при условии \var{\{\$bitpacking on\}}), будут упакованы на уровне
% бит. Это означает невозможность получения адресов отдельных элементов массива или полей записи.
% Исключением из этого правила являются упакованные массивы, размер элементов которых кратен 8 битам.
parser_e_packed_dynamic_open_array=03222_E_Динамические массивы не могут быть упакованными
% Упакованными могут быть только обычные (и, возможно, в будущем также открытые) массивы.
parser_e_packed_element_no_loop=03223_E_Элементы/поля побитно-упакованных массивов/записей нельзя использовать как переменные цикла for
% Поля записи или элементы массива, объявленных как \var{packed} в режиме Mac Pascal (либо как
% \var{packed} в любом режиме при условии \var{\{\$bitpacking on\}}), будут упакованы на уровне
% бит. По причинам быстродействия их нельзя использовать как переменные для for-цикла.
parser_e_type_var_const_only_in_records_and_classes=03224_E_VAR, TYPE and CONST are allowed only in records, objects and classes
% The usage of VAR, TYPE and CONST to declare new types inside an object is allowed only inside
% records, objects and classes.
parser_e_cant_create_generics_of_this_type=03225_E_Этот тип не может быть обобщением
% Обобщения допускаются только для классов, объектов, интерфейсов и записей.
parser_w_no_lineinfo_use_switch=03226_W_Не подключайте модуль LINEINFO вручную, используйте для этого ключ -gl
% Не подключайте модуль LINEINFO вручную, использование ключа \var{-gl} автоматически подключает
% различные модули в зависимости от типа генерируемой отладочной информации.
parser_e_no_funcret_specified=03227_E_Для функции "$1" не указан тип результата
% Первое объявление функции должно быть полным, включая все параметры и тип результата.
parser_e_special_onlygenerics=03228_E_Специализация возможна только для обобщенных типов.
% Типы, не являющиеся обобщениями, не могут быть специализированы.
parser_e_no_generics_as_params=03229_E_Обобщения нельзя использовать как параметры специализации других обобщений
% При специализации обобщения, в качестве параметров можно использовать только обычные типы.
parser_e_type_object_constants=03230_E_Константные объекты, содержащие VMT, не допускаются
% Если объект требует VMT из-за наличия конструктора либо виртуальных методов,
% создание констант его типа не допускается. В режимах TP и Delphi, тем не менее, 
% это разрешено в целях совместимости.
parser_e_label_outside_proc=03231_E_Не допускается взятие адресов меток, определенных вне текущей области видимости
% Не разрешается получение адресов меток, находящихся вне текущей процедуры.
parser_e_initialized_not_for_external=03233_E_Не допускается инициализация переменных, объявленных как external
% Переменные, объявленные как external, не могут иметь значение по умолчанию.
parser_e_illegal_function_result=03234_E_Неверный тип возвращаемого значения
% Некоторые типы, такие как файлы, не могут быть использованы в качестве результата функции.
parser_e_no_common_type=03235_E_Отсутствует общий тип для "$1" и "$2"
% Чтобы выполнить операцию над целыми числами, компилятор приводит их к общему типу,
% чего ему в данном случае не удается. Для определения общего типа операндов
% компилятор берет меньшее из минимальных значений обоих типов и большее из максимальных
% значений. Общий тип будет иметь диапазон минимум..максимум.
parser_e_no_generics_as_types=03236_E_Обобщения без специализации не могут быть использованы как тип переменной
% Обобщения всегда должны быть специализированы перед использованием в качестве типа для переменных.
parser_w_register_list_ignored=03237_W_Перечень регистров для процедур полностью на ассемблере игнорирован
% В процедурах, написанных полностью на ассемблере, перечень измененных регистров игнорируется.
parser_e_implements_must_be_class_or_interface=03238_E_Свойство implements должно быть типа класс или интерфейс
% Свойство, реализующее интерфейс, должно иметь тип класса или интерфейса.
parser_e_implements_must_have_correct_type=03239_E_Свойство implements должно реализовывать интерфейс указанного типа, найдено "$1" ожидалось "$2"
% Свойство, реализующее интерфейс, реализует не тот тип интерфейса.
parser_e_implements_must_read_specifier=03240_E_Свойство implements должно быть доступным для чтения
% Свойство, реализующее интерфейс, должно иметь спецификатор read.
parser_e_implements_must_not_have_write_specifier=03241_E_Свойство implements не должно быть доступным для записи
% Свойство, реализующее интерфейс, не может иметь спецификатор write.
parser_e_implements_must_not_have_stored_specifier=03242_E_Свойство implements не может быть stored
% Свойство, реализующее интерфейс, не может иметь спецификатор stored.
parser_e_implements_uses_non_implemented_interface=03243_E_Свойство implements использовано для нереализованного интерфейса: "$1"
% Интерфейс, реализуемый свойством, должен быть в списке интерфейсов, реализуемых классом.
parser_e_unsupported_real=03244_E_Вычисления с плавающей запятой не доступны для целевой платформы
% Встретилось вещественное выражение, но на целевой платформе они не поддерживаются
parser_e_class_doesnt_implement_interface=03245_E_Класс "$1" не реализует интерфейс "$2"
% Делегированный интерфейс не реализован классом, указанным в выражении implements.
parser_e_class_implements_must_be_interface=03246_E_Тип, используемый implements, должен быть интерфейсом
% За ключевым словом \var{implements} должно следовать имя типа интерфейса.
parser_e_cant_export_var_different_name=03247_E_На этой платформе переменные нельзя экспортировать с другим именем, добавьте имя к объявлению с помощью директивы "export" (имя переменной: $1, объявленное имя экспорта: $2)
% On most targets it is not possible to change the name under which a variable
% is exported inside the \var{exports} statement of a library.
% In that case, you have to specify the export name at the point where the
% variable is declared, using the \var{export} and \var{alias} directives.
parser_e_weak_external_not_supported=03248_E_Символы "weak external" не поддерживаются на целевой платформе
% A "weak external" symbol is a symbol which may or may not exist at (either static
% or dynamic) link time. This concept may not be available (or implemented yet)
% on the current cpu/OS target.
parser_e_forward_mismatch=03249_E_Тип не соответствует раннему объявлению
% При раннем объявлении классов и интерфейсов типы раннего и фактического объявлений
% должны совпадать. Ранее объявленный интерфейс не может быть превращен в класс.
parser_n_ignore_lower_visibility=03250_N_Виртуальный метод "$1" имеет меньшую видимость ($2), чем в родительском классе $3 ($4)
% Перекрывающий виртуальный метод видимость меньше, чем перекрываемый. Это может приводить к
% неожиданным результатам. Если новая видимость - private, то вызов inherited в новом классе
% потомка может вызывать метод с большей видимостью в родительском классе, игнорируя private метод.
parser_e_field_not_allowed_here=03251_E_Поля нельзя объявлять после методов или свойств, сначала начните новую секцию видимости
% После объявления метода или свойства в классе или объекте, дальнейшее объявление полей возможно
% только в новой секции области видимости (\var{public}, \var{private} и т.д.). Это необходимо
% для однозначного понимания кода компилятором, поскольку модификаторы методов,
% такие как \var{default} и \var{register} могут также использоваться как имена полей.
parser_e_no_local_para_def=03252_E_Параметры не могут содержать локальные объявления типов. Используйте отдельное объявление типа в блоке type.
% В Паскале семантически равнозначные типы не считаются идентичными. 
% Переменные или параметры считаются однотипными только в том случае, если они ссылаются на одно и то же
% объявление типа.
% Как следствие, объявление типов в списке параметров не допускается, т.к. на локальное объявление невозможно
% сослаться извне, и два заголовка процедуры в интерфейсной и реализационной части модуля объявляли бы
% два различных типа. Имейте в виду, что выражения вида ``file of byte'' или ``string[50]'' также определяют
% новый тип.
% \end{description}
#
# Type Checking
#
# 04087 is the last used one
#
% \section{Ошибки проверки типов}
% В разделе перечислены все ошибки, которые могут возникать в процессе
% проверки типов.
% \begin{description}
parser_e_abstract_and_sealed_conflict=03253_E_ABSTRACT and SEALED conflict
% ABSTRACT and SEALED cannot be used together in one declaration
parser_e_sealed_descendant=03254_E_Cannot create a descendant of the sealed class "$1"
% Sealed means that class cannot be derived by another class.
parser_e_sealed_class_cannot_have_abstract_methods=03255_E_SEALED class cannot have an ABSTRACT method
% Sealed means that class cannot be derived. Therefore no one class is able to override an abstract method in a sealed class.
parser_e_only_virtual_methods_final=03256_E_Only virtual methods can be final
% You are declaring a method as final, when it is not declared to be
% virtual.
parser_e_final_can_no_be_overridden=03257_E_Final method cannot be overridden: "$1"
% You are trying to \var{override} a virtual method of a parent class that does
% not exist.
parser_e_multiple_messages=03258_E_Only one message can be used per method.
% It is not possible to associate multiple messages with a single method.
parser_e_invalid_enumerator_identifier=03259_E_Invalid enumerator identifier: "$1"
% Only "MoveNext" and "Current" enumerator identifiers are supported.
parser_e_enumerator_identifier_required=03260_E_Enumerator identifier required
% "MoveNext" or "Current" identifier must follow the \var{enumerator} modifier.
parser_e_enumerator_movenext_is_not_valid=03261_E_Enumerator MoveNext pattern method is not valid. Method must be a function with the Boolean return type and no required arguments.
% "MoveNext" enumerator pattern method must be a function with Boolean return type and no required arguments
parser_e_enumerator_current_is_not_valid=03262_E_Enumerator Current pattern property is not valid. Property must have a getter.
% "Current" enumerator pattern property must have a getter
parser_e_only_one_enumerator_movenext=03263_E_Only one enumerator MoveNext method is allowed per class/object
% Class or Object can have only one enumerator MoveNext declaration.
parser_e_only_one_enumerator_current=03264_E_Only one enumerator Current property is allowed per class/object
% Class or Object can have only one enumerator Current declaration.
parser_e_for_in_loop_cannot_be_used_for_the_type=03265_E_For in loop cannot be used for the type "$1"
% For in loop can be used not for all types. For example it cannot be used for the enumerations with jumps.
parser_e_objc_requires_msgstr=03266_E_Objective-C messages require their Objective-C selector name to be specified using the "message" directive.
% Objective-C messages require their Objective-C name (selector name) to be specified using the \var{message `someName:'} procedure directive.
% While bindings to other languages automatically generate such names based on the identifier you use (by replacing
% all underscores with colons), this is unsafe since nothing prevents an Objective-C method name to contain actual
% colons.
parser_e_objc_no_constructor_destructor=03267_E_Objective-C does not have formal constructors nor destructors. Use the alloc, initXXX and dealloc messages.
% The Objective-C language does not have any constructors or destructors. While there are some messages with a similar
% purpose (such as \var{init} and \var{dealloc}), these cannot be identified using automatic parsers and do not
% guarantee anything like Pascal constructors/destructors (e.g., you have to take care of only calling ``designated''
% inherited ``constructors''). For these reasons, we have opted to follow the standard Objective-C patterns for
% instance creation/destruction.
parser_e_message_string_too_long=03268_E_Message name is too long (max. 255 characters)
% Due to compiler implementation reasons, message names are currently limited to 255 characters.
parser_e_objc_message_name_too_long=03269_E_Objective-C message symbol name for "$1" is too long
% Due to compiler implementation reasons, mangled message names (i.e., the symbol names used in the assembler
% code) are currently limited to 255 characters.
parser_h_no_objc_parent=03270_H_Defining a new Objective-C root class. To derive from another root class (e.g., NSObject), specify it as the parent class.
% If no parent class is specified for an Object Pascal class, then it automatically derives from TObject.
% Objective-C classes however do not automatically derive from NSObject, because one can have multiple
% root classes in Objective-C. For example, in the Cocoa framework both NSObject and NSProxy are root classes.
% Therefore, you have to explicitly define a parent class (such as NSObject) if you want to derive your
% Objective-C class from it.
parser_e_no_objc_published=03271_E_Objective-C classes cannot have published sections.
% In Object Pascal, ``published'' determines whether or not RTTI is generated. Since the Objective-C runtime always needs
% RTTI for everything, this specified does not make sense for Objective-C classes.
parser_f_need_objc=03272_F_This module requires an Objective-C mode switch to be compiled
% This error indicates the use of Objective-C language features without an Objective-C mode switch
% active. Enable one via the -M command line switch, or the {\$modeswitch x} directive.
parser_e_must_use_override=03273_E_Inherited methods can only be overridden in Objective-C and Java, add "override" (inherited method defined in $1)
parser_h_should_use_override=03274_H_Inherited methods can only be overridden in Objective-C and Java, add "override" (inherited method defined in $1).
% It is not possible to \var{reintroduce} methods in Objective-C or Java like in Object Pascal. Methods with the same
% name always map to the same virtual method entry. In order to make this clear in the source code,
% the compiler always requires the \var{override} directive to be specified when implementing overriding
% Objective-C or Java methods in Pascal. If the implementation is external, this rule is relaxed because Objective-C and Java
% do not have any \var{override}-style keyword (since it's the default and only behaviour in these languages),
% which makes it hard for automated header conversion tools to include it everywhere.
% The type in which the inherited method is defined is explicitly mentioned, because this may either
% be an objcclass or an objccategory in case of Objective-C.
parser_e_objc_message_name_changed=03275_E_Message name "$1" in inherited class is different from message name "$2" in current class.
% An overriding Objective-C method cannot have a different message name than an inherited method. The reason
% is that these message names uniquely define the message to the Objective-C runtime, which means that
% giving them a different message name breaks the ``override'' semantics.
parser_e_unique_unsupported=03276_E_It is not yet possible to make unique copies of Objective-C or Java types
% Duplicating an Objective-C or Java type using \var{type x = type y;} is not yet supported. You may be able to
% obtain the desired effect using \var{type x = objcclass(y) end;} resp.{} \var{type x = class(y) end;} instead.
parser_e_no_category_as_types=03277_E_Objective-C categories and Object Pascal class helpers cannot be used as types
% It is not possible to declare a variable as an instance of an Objective-C
% category or an Object Pascal class helper. A category/class helper adds
% methods to the scope of an existing class, but does not define a type by
% itself. An exception of this rule is when inheriting an Object Pascal class
% helper from another class helper.
parser_e_no_category_override=03278_E_Categories do not override, but replace methods. Use "reintroduce" instead.
parser_e_must_use_reintroduce_objc=03279_E_Replaced methods can only be reintroduced in Objective-C, add "reintroduce" (replaced method defined in $1).
parser_h_should_use_reintroduce_objc=03280_H_Replaced methods can only be reintroduced in Objective-C, add "reintroduce" (replaced method defined in $1).
% A category replaces an existing method in an Objective-C class, rather than that it overrides it.
% Calling an inherited method from an category method will call that method in
% the extended class' parent, not in the extended class itself. The
% replaced method in the original class is basically lost, and can no longer be
% called or referred to. This behaviour corresponds somewhat more closely to
% \var{reintroduce} than to \var{override} (although in case of \var{reintroduce}
% in Object Pascal, hidden methods are still reachable via inherited).
% The type in which the inherited method is defined is explicitly mentioned, because this may either
% be an objcclass or an objccategory.
parser_e_implements_getter_not_default_cc=03281_E_Getter for implements interface must use the target's default calling convention.
% Interface getters are called via a helper in the run time library, and hence
% have to use the default calling convention for the target (\var{register} on
% i386 and x86\_64, \var{stdcall} on other architectures).
parser_e_no_refcounted_typed_file=03282_E_Typed files cannot contain reference-counted types.
% The data in a typed file cannot be of a reference counted type (such as
% \var{ansistring} or a record containing a field that is reference counted).
parser_e_operator_not_overloaded_2=03283_E_Operator is not overloaded: $2 "$1"
% You are trying to use an overloaded operator when it is not overloaded for
% this type.
parser_e_operator_not_overloaded_3=03284_E_Operator is not overloaded: "$1" $2 "$3"
% You are trying to use an overloaded operator when it is not overloaded for
% this type.
parser_e_more_array_elements_expected=03285_E_Expected another $1 array elements
% When declaring a typed constant array, you provided to few elements to initialize the array
parser_e_string_const_too_long=03286_E_String constant too long while ansistrings are disabled
% Only when a piece of code is compiled with ansistrings enabled (\var{\{\$H+\}}), string constants
% longer than 255 characters are allowed.
parser_e_invalid_univ_para=03287_E_Type cannot be used as univ parameter because its size is unknown at compile time: "$1"
% \var{univ} parameters are compatible with all values of the same size, but this
% cannot be checked in case a parameter's size is unknown at compile time.
parser_e_only_one_class_constructor_allowed=03288_E_Only one class constructor can be declared in class: "$1"
% You are trying to declare more than one class constructor but only one class constructor can be declared.
parser_e_only_one_class_destructor_allowed=03289_E_Only one class destructor can be declared in class: "$1"
% You are trying to declare more than one class destructor but only one class destructor can be declared.
parser_e_no_paras_for_class_constructor=03290_E_Class constructors cannot have parameters
% You are declaring a class constructor with a parameter list. Class constructor methods
% cannot have parameters.
parser_e_no_paras_for_class_destructor=03291_E_Class destructors cannot have parameters
% You are declaring a class destructor with a parameter list. Class destructor methods
% cannot have parameters.
parser_f_modeswitch_objc_required=03292_F_This construct requires the \{\$modeswitch objectivec1\} mode switch to be active
% Objective-Pascal constructs are not supported when \{\$modeswitch ObjectiveC1\}
% is not active.
parser_e_widestring_to_ansi_compile_time=03293_E_Unicodechar/string constants cannot be converted to ansi/shortstring at compile-time
% It is not possible to use unicodechar and unicodestring constants in
% constant expressions that have to be converted into an ansistring or shortstring
% at compile time, for example inside typed constants. The reason is that the
% compiler cannot know what the actual ansi encoding will be at run time.
parser_e_objc_enumerator_2_0=03294_E_For-in Objective-Pascal loops require \{\$modeswitch ObjectiveC2\} to be active
% Objective-C ``fast enumeration'' support was added in Objective-C 2.0, and
% hence the appropriate modeswitch has to be activated to expose this feature.
% Note that Objective-C 2.0 programs require Mac OS X 10.5 or later.
parser_e_objc_missing_enumeration_defs=03295_E_The compiler cannot find the NSFastEnumerationProtocol or NSFastEnumerationState type in the CocoaAll unit
% Objective-C for-in loops (fast enumeration) require that the compiler can
% find a unit called CocoaAll that contains definitions for the
% NSFastEnumerationProtocol and NSFastEnumerationState types. If you get this
% error, most likely the compiler is finding and loading an alternate CocoaAll
% unit.
parser_e_no_procvarnested_const=03296_E_Typed constants of the type 'procedure is nested' can only be initialized with NIL and global procedures/functions
% A nested procedural variable consists of two components: the address of the
% procedure/function to call (which is always known at compile time), and also
% a parent frame pointer (which is never known at compile time) in case the
% procedural variable contains a reference to a nested procedure/function.
% Therefore such typed constants can only be initialized with global
% functions/procedures since these do not require a parent frame pointer.
parser_f_no_generic_inside_generic=03297_F_Declaration of generic class inside another generic class is not allowed
% At the moment, scanner supports recording of only one token buffer at the time
% (guarded by internal error 200511173 in tscannerfile.startrecordtokens).
% Since generics are implemented by recording tokens, it is not possible to
% have declaration of generic class inside another generic class.
parser_e_forward_intf_declaration_must_be_resolved=03298_E_Forward declaration "$1" must be resolved before a class can conform to or implement it
% An Objective-C protocol or Java Interface must be fully defined before classes can conform to it.
% This error occurs in the following situation (example for Objective-C, but the same goes for Java interfaces):
% \begin{verbatim}
%  Type MyProtocol = objcprotoocl;
%       ChildClass = Class(NSObject,MyProtocol)
%         ...
%       end;
% \end{verbatim}
% where \var{MyProtocol} is declared but not defined.
parser_e_no_record_published=03299_E_Record types cannot have published sections
% Published sections can be used only inside classes.
parser_e_no_destructor_in_records=03300_E_Destructors are not allowed in records or helpers
% Destructor declarations are not allowed in records or helpers.
parser_e_class_methods_only_static_in_records=03301_E_Class methods must be static in records
% Class methods declarations are not allowed in records without static modifier.
% Records have no inheritance and therefore non static class methods have no sense for them.
parser_e_no_parameterless_constructor_in_records=03302_E_Parameterless constructors are not allowed in records or record/type helpers
% Constructor declarations with no arguments are not allowed in records or record/type helpers.
parser_e_at_least_one_argument_must_be_of_type=03303_E_Either the result or at least one parameter must be of type "$1"
% It is required that either the result of the routine or at least one of its parameters be of the specified type.
% For example class operators either take an instance of the structured type in which they are defined, or they return one.
parser_e_cant_use_type_parameters_here=03304_E_Type parameters may require initialization/finalization - cannot be used in variant records
% Type parameters may be specialized with types which (e.g. \var{ansistring}) need initialization/finalization
% code which is implicitly generated by the compiler.
parser_e_externals_no_section=03305_E_Variables being declared as external cannot be in a custom section
% A section directive is not valid for variables being declared as external.
parser_e_section_no_locals=03306_E_Non-static and non-global variables cannot have a section directive
% A variable placed in a custom section is always statically allocated so it must be either a static or global variable.
parser_e_not_allowed_in_helper=03307_E_"$1" is not allowed in helper types
% Some directives and specifiers like "virtual", "dynamic", "override" are not
% allowed inside helper types in mode ObjFPC (they are ignored in mode Delphi),
% because they have no meaning within helpers. Also "abstract" isn't allowed in
% either mode.
parser_e_no_class_constructor_in_helpers=03308_E_Class constructors are not allowed in helpers
% Class constructor declarations are not allowed in helpers.
parser_e_inherited_not_in_record=03309_E_The use of "inherited" is not allowed in a record
% As records don't support inheritance the use of "inherited" is prohibited for
% these as well as for record helpers (in mode "Delphi" only).
parser_e_no_types_in_local_anonymous_records=03310_E_Type declarations are not allowed in local or anonymous records
% Records with types must be defined globally. Types cannot be defined inside records which are defined in a
% procedure or function or in anonymous records.
parser_e_duplicate_implements_clause=03311_E_Duplicate implements clause for interface "$1"
% A class may delegate an interface using the "implements" clause only to a single property. Delegating it multiple times
% is a error.
parser_e_mapping_no_implements=03312_E_Interface "$1" cannot be delegated by "$2", it already has method resolutions
% Method resolution clause maps a method of an interface to a method of the current class. Therefore the current class
% has to implement the interface directly. Delegation is not possible.
parser_e_implements_no_mapping=03313_E_Interface "$1" cannot have method resolutions, "$2" already delegates it
% Method resolution is only possible for interfaces that are implemented directly, not by delegation.
parser_e_invalid_codepage=03314_E_Invalid codepage
% When declaring a string with a given codepage, the range of valid codepages values is limited
% to 0 to 65535.
parser_e_final_only_const_var=03315_E_Only fields (var-sections) and constants can be final in object types
% A final (class) field must be assigned a single value in the (class) constructor, and cannot
% be overwritten afterwards. A final (typed) constant is read-only.
parser_e_final_only_external=03316_E_Final fields are currently only supported for external classes
% Support for final fields in non-external classes requires a full data flow
% analysis implementation in FPC, which it currently still lacks.
parser_e_no_typed_const=03317_E_Typed constants are not allowed here, only formal constants are
% Java interfaces define a namespace in which formal constant can be defined,
% but since they define no storage it is not possible to define typed constants
% in them (those are more or less the same as initialised class fields).
parser_e_java_no_inherited_constructor=03318_E_Constructors are not automatically inherited in the JVM; explicitly add a constructor that calls the inherited one if you need it
% Java does not automatically add inherited constructors to child classes, so that they can be hidden.
% For compatibility with external Java code, FPC does the same. If you require access to the same
% constructors in a child class, define them in the child class and call the inherited one from
% there.
parser_d_internal_parser_string=03319_D_Parsing internally generated code: $1
% The compiler sometimes internally constructs Pascal code that is subsequently
% injected into the program. These messages display such code, in order to help
% with debugging errors in them.
parser_e_feature_unsupported_for_vm=03320_E_This language feature is not supported on managed VM targets
% Certain language features are not supported on targets that are managed virtual machines.
parser_e_jvm_invalid_virtual_constructor_call=03321_E_Calling a virtual constructor for the current instance inside another constructor is not possible on the JVM target
% The JVM does not natively support virtual constructor. Unforunately, we are not aware of a way to
% emulate them in a way that makes it possible to support calling virtual constructors
% for the current instance inside another constructor.
parser_e_method_lower_visibility=03322_E_Overriding method "$1" cannot have a lower visibility ($2) than in parent class $3 ($4)
% The JVM does not allow lowering the visibility of an overriding method.
parser_e_nostackframe_without_assembler=03323_E_Procedure/Function declared with call option NOSTACKFRAME but without ASSEMBLER
% nostackframe call modifier is supposed to be used in conjunction with assembler.
parser_e_nostackframe_with_locals=03324_E_Procedure/Function declared with call option NOSTACKFRAME but local stack size is $1
% nostackframe call modifier used without assembler modifier
% might still generate local stack needs.
parser_e_cannot_generate_property_getter_setter=03325_E_Cannot generate property getter/setter $1 because its name clashes with existing identifier $2
% Automatically generated getters/setters cannot have the same name as existing
% identifiers, because this may change the behaviour of existing code.
parser_w_overriding_property_getter_setter=03326_W_Automatically generated property getter/setter $1 overrides the same-named getter/setter in class $2
% Automatically generated property getters/setters on the JVM platform are virtual methods, because
% the JVM does not support non-virtual methods that can be changed in child classes. This means
% that if a child class changes an inherited property definition, the behaviour of that property
% can change compared to native targets since even if a variable is declared as the parent type,
% by calling the virtual method the getter from the child will be used. This is different from
% the behaviour on native targets or when not activating automatically generated setters/getters,
% because in that case only the declared type of a variable influences the property behaviour.
parser_w_case_difference_auto_property_getter_setter_prefix=03327_W_Case mismatch between declared property getter/setter $1 and automatically constructed name $2, not changing declared name
% If a property's specified getter/setter already corresponded to the naming convention specified
% by the automatic getter/setter generation setting except in terms of upper/lowercase, the
% compiler will print a warning because it cannot necessarily change that other declaration itself
% not can it add one using the correct case (it could conflict with the original declaration).
% Manually correct the case of the getter/setter to conform to the desired coding rules.
% \var{TChild} overrides
parser_e_no_consts_in_local_anonymous_records=03328_E_Constants declarations are not allowed in local or anonymous records
% Records with constants must be defined globally. Constants cannot be defined inside records which are defined in a
% procedure or function or in anonymous records.
parser_e_no_methods_in_local_anonymous_records=03329_E_Method declarations are not allowed in local or anonymous records
% Records with methods must be defined globally. Methods cannot be defined inside records which are defined in a
% procedure or function or in anonymous records.
parser_e_no_properties_in_local_anonymous_records=03330_E_Property declarations are not allowed in local or anonymous records
% Records with properties must be defined globally. Properties cannot be defined inside records which are defined in a
% procedure or function or in anonymous records.
parser_e_no_class_in_local_anonymous_records=03331_E_Class member declarations are not allowed in local or anonymous records
% Records with class members must be defined globally. Class members cannot be defined inside records which are defined in a
% procedure or function or in anonymous records.
parser_e_not_allowed_in_record=03332_E_Visibility section "$1" not allowed in records
% The visibility sections \var(protected) and \var(strict protected) are only
% useful together with inheritance. Since records do not support that they are
% forbidden.
parser_e_dir_not_allowed=03333_E_Directive "$1" not allowed here
% This directive is not allowed in the given context. E.g. "static"
% is not allowed for instance methods or class operators.
parser_e_no_assembler_in_generic=03334_E_Assembler blocks not allowed inside generics
% The use of assembler blocks/routines is not allowed inside generics.
parser_e_property_only_sgr=03335_E_Properties can be only static, global or inside structured types
% Properties cannot be declared local, only global, using the static
% directive or inside structured types.
parser_e_overloaded_have_same_mangled_name=03336_E_Overloaded routines have the same mangled name
% Some platforms, such as the JVM platform, encode the parameters in the routine name in
% a prescribed way, and this encoding may map different Pascal types to the same encoded
% (a.k.a.\ ``mangled'') name. This error can only be solved by removing or changing the
% conflicting definitions' parameter declarations or routine names.
parser_e_default_value_val_const=03337_E_Default values can only be specified for value, const and constref parameters
% A default parameter value allows you to not specify a value for this parameter
% when calling the routine, and the compiler will instead pass the specified
% default (constant) value. As a result, default values can only be specified
% for parameters that can accept constant values.
parser_w_ptr_type_ignored=03338_W_Pointer type "$1" ignored
% The specified pointer type modifier is ignored, because it is not supported on
% the current platform. This happens, for example, when a far pointer is
% declared on a non-x86 platform.
parser_e_global_generic_references_static=03339_E_Global Generic template references static symtable
% A generic declared in the interface section of a unit must not reference symbols that belong
% solely to the implementation section of that unit.
parser_u_already_compiled=03340_UL_Unit $1 has been already compiled meanwhile.
% This tells you that the recursive reading of the uses clauses triggered already
% a compilation of the current unit, so the current compilation can be aborted.
%
%
%
% \end{description}
%
# Type Checking
#
# 04123 is the last used one
#
% \section{Type checking errors}
% This section lists all errors that can occur when type checking is
% performed.
% \begin{description}
type_e_mismatch=04000_E_Тип не совпадает
% Может иметь место во многих случаях:
% \begin{itemize}
% \item Присваиваемая переменная имеет тип, отличный от присваиваемого выражения.
% \item Вызов функции или процедуры с параметрами, несовместимыми
% с теми, которые были использованы при объявлении функции.
% \end{itemize}
type_e_incompatible_types=04001_E_Hесовместимые типы: полyчено "$1", ожидалось "$2"
% Преобразование из одного типа в другой невозможно.
% Также возможно, что типы объявлены в различных объявлениях:
% \begin{verbatim}
% Var
%    A1 : Array[1..10] Of Integer;
%    A2 : Array[1..10] Of Integer;
%
% Begin
%    A1:=A2; { Приведет к ошибке из-за требования
%              строгого соответствия типов в Паскале }
% End.
% \end{verbatim}
type_e_not_equal_types=04002_E_Hесовпадение типов междy "$1" и "$2"
% Типы не равны
type_e_type_id_expected=04003_E_Ожидается идентфикатор типа
% Идентификатор не является типом, либо идентификатор типа пропущен.
type_e_variable_id_expected=04004_E_Ожидается идентификатор переменной
% Происходит при попытке передачи константы в процедуру \var{Inc} или \var{Dec}.
% Им можно передавать только переменные.
type_e_integer_expr_expected=04005_E_Ожидается выpажение типа INTEGER, но получено "$1"
% Компилятор ожидает выражение типа integer, но получает нечто иное.
type_e_boolean_expr_expected=04006_E_Ожидается выражение типа BOOLEAN, но получено "$1"
% Выражение должно быть булевого типа, должно быть возвращено true или
% false.
type_e_ordinal_expr_expected=04007_E_Ожидается выpажение порядкового типа
% Тип выражения должен быть порядковым, т.е., максимум \var{Longint}.
% Происходит, например, если второй аргумент
% \var{Inc} или \var{Dec} не вычисляется как порядковый тип.
type_e_pointer_type_expected=04008_E_Ожидается тип POINTER, но получено "$1"
% Переменная или выражение имеет тип, отличный от \var{pointer}. Происходит,
% например, при передаче целой переменной в качестве аргумента \var{New}
% или \var{Dispose}.
type_e_class_type_expected=04009_E_Ожидается тип CLASS, но получено "$1"
% Переменная или выражение имеет тип, отличный от \var{class}. Обычно
% случается, если
% \begin{enumerate}
% \item Родительский класс в объявлении класса не является классом.
% \item Обработчик исключений (\var{On}) содержит идентификатор типа,
% не являющийся классом.
% \end{enumerate}
type_e_cant_eval_constant_expr=04011_E_Hевозможно вычислить константное выражение
% Происходит, если границы объявленного массива не вычисляются как порядковые константы.
type_e_set_element_are_not_comp=04012_E_Элементы множества не совместимы
% Возникает при операции над двумя множествами, имеющими различный тип элементов.
% Для объединения множеств они должны иметь одинаковый базовый тип.
type_e_set_operation_unknown=04013_E_Опеpация не pеализована для множеств
% Некоторые парные операции не определены для множеств,
% например, div mod ** (также, в настоящее время, >= <=).
type_w_convert_real_2_comp=04014_W_Автоматическое пpеобpазование из вещественного типа в COMP, котоpый является целочисленным
% Встретилось неявное преобразование вещественного типа в \var{comp}.
% Поскольку \var{Comp} является 64-битным целым, это может свидетельствовать об ошибке.
type_h_use_div_for_int=04015_H_Для полyчения целочисленного pезyльтата использyйте DIV
% При включенных подсказках, сообщение будет выдаваться при целочисленном делении
% с помощью '/', поскольку результат в этом случае будет вещественным.
type_e_strict_var_string_violation=04016_E_Типы строк не совпадают из-за режима $V+
% При компиляции в режиме \var{\{\$V+\}}, тип строк, передаваемых как параметры,
% должен в точности совпадать с типом в объявлении функции.
type_e_succ_and_pred_enums_with_assign_not_possible=04017_E_SUCC или PRED невозможны на пеpечислениях с присвоениями
% Если перечисляемый тип содержит присвоения, как в языке C,
% например:
% \begin{verbatim}
%   Tenum = (a,b,e:=5);
% \end{verbatim}
% то для него нельзя использовать функции \var{Succ} или \var{Pred}.
type_e_cant_read_write_type=04018_E_Чтение и запись пеpеменных этого типа невозможна
% Попытка чтения (\var{read}) или записи (\var{write}) переменной, тип которой не
% поддерживается, в файл типа текст. Поддерживаются только целые,
% булевы, вещественные переменные, переменные типа pchar и строки.
type_e_no_readln_writeln_for_typed_file=04019_E_Readln или Writeln недопустимы на типизированном файле
% \var{readln} и \var{writeln} допускаются только для текстовых файлов.
type_e_no_read_write_for_untyped_file=04020_E_Read или Write недопустимы на нетипизированном файле
% \var{read} и \var{write} допускаются только для текстовых и типизированных файлов.
type_e_typeconflict_in_set=04021_E_Конфликт типов междy элементами множества
% Тип по крайней мере одного элемента не совпадает с базовым типом множества.
type_w_maybe_wrong_hi_lo=04022_W_Lo/Hi(dword/qword) возвpащают младшее/старшее word/dword
% \fpc поддерживает перегруженные варианты \var{lo/hi} для \var{longint/dword/int64/qword},
% которые возвращают младшую/старшую половину аргумента (типа word/dword). TP всегда использует
% 16-битные \var{lo/hi}, которые всегда возвращают биты 0..7 для \var{lo} и 
% биты 8..15 для \var{hi}. Если требуется поведение TP, нужно привести аргумент
% к \var{word/integer}.
type_e_integer_or_real_expr_expected=04023_E_Ожидается выpажение целого или вещественного типа
% Первый аргумент \var{str} должен иметь целый либо вещественный тип.
type_e_wrong_type_in_array_constructor=04024_E_Hевеpный тип "$1" в констpyктоpе массива
% Попытка использования недопустимого типа в конструкторе массива.
type_e_wrong_parameter_type=04025_E_Hесовпадение типа аpгyмента # $1: получено "$2", ожидалось "$3"
% Попытка передать неверный тип для указанного параметра.
type_e_no_method_and_procedure_not_compatible=04026_E_Метод (пеpеменная) и пpоцедypа (пеpеменная) не совместимы
% Нельзя присвоить метод переменной типа процедура, или процедуру переменной типа
% метод.
type_e_wrong_math_argument=04027_E_Неверная константа пеpедана встроенной математической фyнкции
% Константный аргумент функции ln или sqrt находится вне определенного для них
% диапазона.
type_e_no_addr_of_constant=04028_E_Hельзя взять адрес константного выражения
% Взять адрес константного выражения невозможно, потому что константы не
% хранятся в памяти. Можно попробовать объявить типизированную константу.
type_e_argument_cant_be_assigned=04029_E_Аргументу невозможно присвоить значение
% В качестве параметра по ссылке могут быть переданы только те выражения,
% которые можно использовать с левой стороны оператора присваивания.
% Замечания: Свойства можно использовать с левой стороны присваивания, но
% нельзя передавать по ссылке.
type_e_cannot_local_proc_to_procvar=04030_E_Локальная процедура не может быть присвоена переменной процедурного типа
% Присвоение локальных процедур/функций процедурным переменным не допускается,
% т.к. у них другой способ вызова. Локальные процедуры/функции 
% можно присвоить только нетипизированному указателю.
type_e_no_assign_to_addr=04031_E_Hельзя присвоить значение адpесy
% Не допускается присвоение значений адресам переменных, констант, процедур
% и функций. Если идентификатор является процедурной переменной, можно попробовать
% компиляцию с ключом -So.
type_e_no_assign_to_const=04032_E_Hельзя присвоить значение константе
% Не допускается присвоение значений переменным, объявленным как константные.
% Как правило, это параметры, объявленные как const. Чтобы их можно было
% присваивать, поменяйте их на var или на параметр-значение.
type_e_array_required=04033_E_Тpебyется тип массива
% При доступе к переменной по индексу '[<x>]' тип этой переменной должна быть
% массивом. В режиме FPC также допускаются указатели.
type_e_interface_type_expected=04034_E_Требуется тип интерфейса, но получено "$1"
% Компилятор ожидал встретить имя типа интерфейса, но встретил что-то другое.
% Ошибка может быть вызвана следующим кодом:
% \begin{verbatim}
% Type
%   TMyStream = Class(TStream,Integer)
% \end{verbatim}
type_h_mixed_signed_unsigned=04035_H_Смешивание знаковых и беззнаковых выражений дает 64-битный результат
% При делении (или вычислении остатка) знакового выражения на беззнаковое (или наоборот),
% или же включена проверка переполнений и/или диапазонов и используется арифметическое
% выражение (+, -, *, div, mod), в котором встречаются как знаковые, так и беззнаковые значения,
% вычисление будет производиться в 64-битном режиме, который медленнее обычной 
% 32-битной арифметики. Этого можно избежать, приведя тип одного из операндов к типу
% другого.
type_w_mixed_signed_unsigned2=04036_W_Смешивание знаковых и беззнаковых выражений типа может вызвать ошибку выхода за диапазон
% При использовании двоичных операций (and, or, xor), один из операндов которых
% является беззнаковым выражением, а другой - выражением со знаком, и включена
% проверка диапазонов, может возникнуть ошибка, т.к. в этом случае оба операнда
% будут преобразованы в беззнаковый cardinal. Этого можно избежать, приведя тип
% одного из операндов к типу другого.
type_e_typecast_wrong_size_for_assignment=04037_E_Приведение типов разного размера ($1 -> $2) в присваивании
% Приведение типа к типу другого размера невозможно, если переменная используется
% в присваивании.
type_e_array_index_enums_with_assign_not_possible=04038_E_Перечисления с присвоениями нельзя использовать как индекс массива
% Элементы перечисляемого типа, объявленного с присвоениями, как в языке C,
% например:
% \begin{verbatim}
%   Tenum = (a,b,e:=5);
% \end{verbatim}
% нельзя использовать как индексы массивов.
type_e_classes_not_related=04039_E_Типы классов или объектов "$1" и "$2" не соотносятся
% Приведение типа одного класса или объекта к другому, не имеющего к нему отношения.
% Это наверняка приведет к ошибкам.
type_w_classes_not_related=04040_W_Типы классов "$1" и "$2" не соотносятся
% Приведение типа одного класса или объекта к другому, не имеющего к нему отношения.
% Это наверняка приведет к ошибкам.
type_e_class_or_interface_type_expected=04041_E_Ожидается тип класса или интерфейса, но получено "$1"
% Компилятор ожидал встретить имя класса или интерфейса, но встретил что-то другое.
type_e_type_is_not_completly_defined=04042_E_Тип "$1" не определен полностью
% Проиходит, если тип не определен полностью, например, это тип указателя, который указывает
% на неопределенный тип.
type_w_string_too_long=04043_W_Строковый литерал содержит больше символов, чем может вместить shortstring
% Попытка присвоить короткой строке константное значение, которое содержит больше символов,
% чем максимальная длина строки.
type_w_comparison_always_false=04044_W_Comparison might be always false due to range of constant and expression
% There is a comparison between a constant and an expression where the constant is out of the
% valid range of values of the expression. Because of type promotion, the statement will always evaluate to
% false. Explicitly typecast the constant or the expression to the correct range to avoid this warning
% if you think the code is correct.
type_w_comparison_always_true=04045_W_Comparison might be always true due to range of constant and expression
% There is a comparison between a constant and an expression where the constant is out of the
% valid range of values of the expression. Because of type promotion, the statement will always evaluate to
% true. Explicitly typecast the constant or the expression to the correct range to avoid this warning
% if you think the code is correct.
type_w_instance_with_abstract=04046_W_Создание класса "$1" с абстрактным методом "$2"
% Создается экземпляр класса, содержащего неперекрытый абстрактный метод.
% Вызов такого метода во время выполнения программы приведет к ошибке 211.
% Все абстрактные методы должны быть перекрыты.
type_h_in_range_check=04047_H_Левый операнд оператора IN должен иметь размер байта
% Левый операнд оператора \var{in} не является порядковым или перечисляемым значением,
% помещающимся в 8 бит, это может приводить к ошибкам проверки диапазона. Оператор \var{in}
% в настоящее время поддерживает левый операнд только байтового диапазона. В случае
% перечислений, размером элементов перечисления можно управлять с помощью
% ключей \var{\{\$PACKENUM\}} или \var{\{\$Zn\}}.
type_w_smaller_possible_range_check=04048_W_Несовпадение размеров типов, возможна потеря данных / ошибки диапазона
% Присвоение типу меньшего размера, чем исходный тип. Это может приводить к ошибкам проверки
% диапазона, или частичной потере данных.
type_h_smaller_possible_range_check=04049_H_Несовпадение размеров типов, возможна потеря данных / ошибки диапазона
% Присвоение типу меньшего размера, чем исходный тип. Это может приводить к ошибкам проверки
% диапазона, или частичной потере данных.
type_e_cant_take_address_of_abstract_method=04050_E_Взятие адреса абстрактного метода невозможно
% Абстрактный метод не имеет тела, поэтому адрес брать не от чего.
type_e_assignment_not_allowed=04051_E_Невозможно присвоение формальных параметров и открытых массивов
% Попытка присвоить значение формальному (нетипизированному var, const или out)
% параметру, либо открытому массиву.
type_e_constant_expr_expected=04052_E_Ожидается константное выражение
% Компилятор ожидает константное выражение, но получает переменное.
type_e_operator_not_supported_for_types=04053_E_Операция "$1" не поддерживается для типов "$2" и "$3"
% Указанная операция недопустима для указанных типов.
type_e_illegal_type_conversion=04054_E_Недопустимое приведение типов: "$1" к "$2"
% При приведении типов следует соблюдать равенство размеров источника и получателя.
type_h_pointer_to_longint_conv_not_portable=04055_H_Преобразование между порядковыми типами и указателями является непортируемым
% Код, в котором указатели приводятся к longint (или наоборот), не будет работать
% на платформах, у которых размер указателя равен 64 битам.
type_w_pointer_to_longint_conv_not_portable=04056_W_Преобразование между порядковыми типами и указателями является непортируемым
% Приведение указателей к порядковым типам другого размера (или наоборот), может
% вызывать проблемы. Это предупреждение помогает находить специфичный 32-битный код, в котором
% тип longint/cardinal используется взаимозаменяемо с указателями. Решение заключается в использовании
% типов ptrint/ptruint.
type_e_cant_choose_overload_function=04057_E_Невозможно определить, которую из перегруженных функции вызывать
% Вызов перегруженной функции со списком параметров, который не соответствует ни
% одной из объявленных функций. Например, если объявлены функции с параметрами
% типа \var{word} и \var{longint}, а вызов производится с параметром типа
% \var{integer}.
type_e_illegal_count_var=04058_E_Неверная переменная счетчика
% Тип переменной для цикла \var{for} должен быть порядковым.
% Вещественные и строковые типы не допускаются.
type_w_double_c_varargs=04059_W_Вещественная константа преобразована в double для ф-ции C с переменным числом параметров
% В языке C вещественные константы по умолчанию имеют тип double. Поэтому при передаче
% вещественной константы в функцию на C с переменным числом аргументов FPC
% по умолчанию преобразует ее в double. Если это поведение нежелательно,
% приведите константу к нужному типу явно.
type_e_class_or_cominterface_type_expected=04060_E_Ожидается тип класса или COM-интерфейса, но получено "$1"
% Некоторые операторы, такие как AS, применимы только к классам или COM-интерфейсам.
type_e_no_const_packed_array=04061_E_Константные упакованные массивы пока не поддерживаются
% Нельзя объявить константу типа (побитно)упакованный массив.
type_e_got_expected_packed_array=04062_E_Несовпадение типа аргумента no. $1: Получено "$2" ожидалось "(Bit)Packed Array"
% Компилятор ожидает (побитно)упакованный массив в качестве указанного параметра.
type_e_got_expected_unpacked_array=04063_E_Несовпадение типа аргумента no. $1: Получено "$2" ожидалось "(not packed) Array"
% Компилятор ожидает обычный (неупакованный) массив в качестве указанного параметра.
type_e_no_packed_inittable=04064_E_Элементы упакованного массива не могут иметь тип, требующий инициализации
% Упакованные массивы с типами, требующими инициализацию (такими как ansistring, или записи, содержащие
% ansistring), пока не поддерживаются.
type_e_no_const_packed_record=04065_E_Константные упакованные записи и объекты пока не поддерживаются
% В настоящее время нельзя объявить константу типа (побитно)упакованная запись/объект.
type_w_untyped_arithmetic_unportable=04066_W_Арифметика "$1" нетипизированных указателей несовместима с режимом {$T+}, предлагается приведение типа
% Сложение/вычитание нетипизированных указателей может работать по-другому в режиме \var{\{\$T+\}},
% приведите тип к типизированному указателю.
type_e_cant_take_address_of_local_subroutine=04076_E_Нельзя взять адрес процедуры, помеченной как локальная
% Взятие адреса процедуры, помеченной как локальная, невозможно.
type_e_cant_export_local=04077_E_Процедура, отмеченная как локальная, не может быть экспортирована из модуля
% Процедура, отмеченная как локальная, не может быть экспортирована из модуля.
type_e_not_automatable=04078_E_Тип не автоматизируемый: "$1"
% В качестве автоматизированных допускаются byte, integer, longint, smallint, currency, single, double,
% ansistring, widestring, tdatetime, variant, olevariant, wordbool и все интерфейсные типы.
type_h_convert_add_operands_to_prevent_overflow=04079_H_Приведение операндов к "$1" перед сложением предотвратит ошибки переполнения.
% Сложение может вызывать переполнение. Т.к. результат преобразуется в тип большего размера,
% переполнения можно избежать, приведя операнды к типу результата перед сложением.
type_h_convert_sub_operands_to_prevent_overflow=04080_H_Приведение операндов к "$1" перед вычитанием предотвратит ошибки переполнения.
% Вычитание может вызывать переполнение. Т.к. результат преобразуется в тип большего размера,
% переполнения можно избежать, приведя операнды к типу результата перед вычитанием.
type_h_convert_mul_operands_to_prevent_overflow=04081_H_Приведение операндов к "$1" перед умножением предотвратит ошибки переполнения.
% Умножение может вызывать переполнение. Т.к. результат преобразуется в тип большего размера,
% переполнения можно избежать, приведя операнды к типу результата перед умножением.
type_w_pointer_to_signed=04082_W_Приведение указателей к целым со знаком может приводить к ошибкам сравнения и выходу за диапазон, используйте беззнаковый тип.
% Виртуальное адресное пространство на 32-битных системах имеет диапазон от \$00000000 до \$ffffffff.
% Многие операционные системы позволяют выделять память свыше \$80000000, например, Windows и Linux 
% допускают указатели в диапазоне от \$0000000 до \$bfffffff. Если приводить указатели к знаковым типам,
% могут возникать ошибки переполнения и диапазона, кроме того, \$80000000 < \$7fffffff.
% Это может вызывать случайные ошибки в коде наподобие "if p>q".
type_e_interface_has_no_guid=04083_E_Interface type $1 has no valid GUID
% When applying the as-operator to an interface or class, the desired interface (i.e. the right operand of the
% as-operator) must have a valid GUID.
type_e_invalid_objc_selector_name=04084_E_Неверное имя селектора
% Селектор Objective-C не может быть пустым, он должен быть идентификатором либо одиночным двоеточием,
% и, если он содержит двоеточие, то должен двоеточием и заканчиваться.
type_e_expected_objc_method_but_got=04085_E_Ожидается метод Objective-C, но получено $1
% Селектор может быть создан только для методов Objective-C, никакой другой тип
% процедур/функций/методов не допустим.
type_e_expected_objc_method=04086_E_Ожидается метод Objective-C или константное имя метода
% Селектор может быть создан только для методов Objective-C, либо путем указания имени
% в виде строковой константы, либо с использования идентификатора метода Objective-C,
% действительного в текущей области видимости.
type_e_no_type_info=04087_E_Информация о типе недоступна для этого типа
% Информация о типе не генерируется для некоторых типов, таких как перечисления с разрывами
% в диапазоне значений (включая перечисления, у которых нижняя граница диапазона отличается от
% нуля).
type_e_ordinal_or_string_expr_expected=04088_E_Требуется выражение порядкового или строкового типа
% Выражение должно иметь порядковый или строковый тип.
type_e_string_expr_expected=04089_E_Требуется строковое выражение
% Выражение должно иметь строковый тип.
% \end{description}
#
# Symtable
#
# 05064 is the last used one
#
% \section{Symbol handling}
% Данный раздел содержит сообщения, относящиеся к обработке символов,
% т.е. всего, что связано с именами процедур и переменных.
% \begin{description}
type_w_zero_to_nil=04090_W_Converting 0 to NIL
% Use NIL rather than 0 when initialising a pointer.
type_e_protocol_type_expected=04091_E_Objective-C protocol type expected, but got "$1"
% The compiler expected a protocol type name, but found something else.
type_e_objc_type_unsupported=04092_E_The type "$1" is not supported for interaction with the Objective-C and the blocks runtime.
% Objective-C and Blocks make extensive use of run time type information (RTTI). This format
% is defined by the maintainers of the run time and can therefore not be adapted
% to all possible Object Pascal types. In particular, types that depend on
% reference counting by the compiler (such as ansistrings and certain kinds of
% interfaces) cannot be used as fields of Objective-C classes, cannot be
% directly passed to Objective-C methods or Blocks, and cannot be encoded using \var{objc\_encode}.
type_e_class_or_objcclass_type_expected=04093_E_Class or objcclass type expected, but got "$1"
% It is only possible to create class reference types of \var{class} and \var{objcclass}
type_e_objcclass_type_expected=04094_E_Objcclass type expected
% The compiler expected an \var{objcclass} type
type_w_procvar_univ_conflicting_para=04095_W_Coerced univ parameter type in procedural variable may cause crash or memory corruption: $1 to $2
% \var{univ} parameters are implicitly compatible with all types of the same size,
% also in procedural variable definitions. That means that the following code is
% legal, because \var{single} and \var{longint} have the same size:
% \begin{verbatim}
% {$mode macpas}
% Type
%   TIntProc = procedure (l: univ longint);
%
%   procedure test(s: single);
%     begin
%       writeln(s);
%     end;
%
%   var
%     p: TIntProc;
%   begin
%     p:=test;
%     p(4);
%   end.
% \end{verbatim}
% This code may however crash on platforms that pass integers in registers and
% floating point values on the stack, because then the stack will be unbalanced.
% Note that this warning will not flag all potentially dangerous situations.
% when \var{test} returns.
type_e_generics_cannot_reference_itself=04096_E_Type parameters of specializations of generics cannot reference the currently specialized type
% Recursive specializations of generics like \var{Type MyType = specialize MyGeneric<MyType>;} are not possible.
type_e_type_parameters_are_not_allowed_here=04097_E_Type parameters are not allowed on non-generic class/record/object procedure or function
% Type parameters are only allowed for methods of generic classes, records or objects
type_e_generic_declaration_does_not_match=04098_E_Generic declaration of "$1" differs from previous declaration
% Generic declaration does not match the previous declaration
type_e_helper_type_expected=04099_E_Helper type expected
% The compiler expected a \var{class helper} type.
type_e_record_type_expected=04100_E_Record type expected
% The compiler expected a \var{record} type.
type_e_class_helper_must_extend_subclass=04101_E_Derived class helper must extend a subclass of "$1" or the class itself
% If a class helper inherits from another class helper the extended class must
% extend either the same class as the parent class helper or a subclass of it
type_e_record_helper_must_extend_same_record=04102_E_Derived record or type helper must extend "$1"
% If a record helper inherits from another record helper it must extend the same
% record that the parent record helper extended.
type_e_procedures_return_no_value=04103_E_Invalid assignment, procedures return no value
% This error occurs when one tries to assign the result of a procedure or destructor call.
% A procedure or destructor returns no value so this is not
% possible.
type_w_implicit_string_cast=04104_W_Implicit string type conversion from "$1" to "$2"
% An implicit type conversion from an ansi string type to an unicode string type is
% encountered. To avoid this warning perform an explicit type conversion.
type_w_implicit_string_cast_loss=04105_W_Implicit string type conversion with potential data loss from "$1" to "$2"
% An implicit type conversion from an unicode string type to an ansi string type is
% encountered. This conversion can lose data since not all unicode characters may be represented in the codepage of
% destination string type.
type_w_explicit_string_cast=04106_-W_Explicit string typecast from "$1" to "$2"
% An explicit typecast from an ansi string type to an unicode string type is
% encountered. This warning is off by default. You can turn it on to see all suspicious string conversions.
type_w_explicit_string_cast_loss=04107_-W_Explicit string typecast with potential data loss from "$1" to "$2"
% An explicit typecast from an unicode string type to an ansi string type is
% encountered. This conversion can lose data since not all unicode characters may be represented in the codepage of
% destination string type. This warning is off by default. You can turn it on to see all the places with lossy string
% conversions.
type_w_unicode_data_loss=04108_W_Unicode constant cast with potential data loss
% Conversion from a WideChar to AnsiChar can lose data since now all unicode characters may be represented in the current
% system codepage
% You can nest function definitions only 31 levels deep.
type_e_range_check_error_bounds=04109_E_range check error while evaluating constants ($1 must be between $2 and $3)
type_w_range_check_error_bounds=04110_W_range check error while evaluating constants ($1 must be between $2 and $3)
% The constants are outside their allowed range.
type_e_type_not_allowed_for_default=04111_E_This type is not supported for the Default() intrinsic
% Some types like for example Text and File Of X are not supported by the Default intrinsic.
type_e_java_class_method_not_static_virtual=04112_E_JVM virtual class methods cannot be static
% Virtual class methods cannot be static when targeting the JVM platform, because
% the self pointer is required for correct dispatching.
type_e_invalid_final_assignment=04113_E_Final (class) fields can only be assigned in their class' (class) constructor
% It is only possible to assign a value to a final (class) field inside a (class) constructor of its owning class.
type_e_no_managed_formal_assign_typecast=04114_E_It is not possible to typecast untyped parameters on managed platforms, simply assign a value to them instead.
% On managed platforms, untyped parameters are translated by the compiler into
% the equivalent of \var{var x: BaseClassType}. Non-class-based types passed to
% such parameters are automatically wrapped (or boxed) in a class, and after the
% call the potentially modified value is assigned back to the original variable.
% On the caller side, changing untyped var/out parameters happens by simply assigning
% values to them (either class-based or primitive ones). On the caller side,
% they will be extracted and if their type does not match the original variable's,
% an exception will be raised.
type_e_no_managed_assign_generic_typecast=04115_E_The assignment side of an expression cannot be typecasted to a supertype on managed platforms
% Managed platforms guarantee type safety at the bytecode level. This means that the virtual machine must be able
% to statically determine that no type-unsafe assignments or operations occur. By assigning a parent class type to a
% variable of a child type by typecasting the assignment side to the parent class type, the type safety would no
% longer be guaranteed and the generated code would fail verification at run time time.
type_w_interface_lower_visibility=04116_-W_The interface method "$1" raises the visibility of "$2" to public when accessed via an interface instance
type_e_interface_lower_visibility=04117_E_The interface method "$1" has a higher visibility (public) than "$2"
% All methods in an interface have always public visibility. That means that if
% an interface method is implemented using a (strict) protected or private method,
% this method is actually publicly accessible via the interface. On the JVM
% target this situation results in an error because the JVM rejects such
% attempts to circumvent the visibility rules. On other targets this is a
% warning that is disabled by default because such situations are common
% practice, but it can be enabled in case you are concerned with keeping your
% code compilable for the JVM target.
type_e_typeof_requires_vmt=04118_E_TYPEOF can only be used on object types with VMT
% Typeof() intrinsic returns pointer to VMT of its argument. It cannot be used on object types that do not have VMT.
type_e_invalid_default_value=04119_E_It is not possible to define a default value for a parameter of type "$1"
% Parameters declared as structured types, such as files, variants, non-dynamic
% arrays and TP-style objects, cannot have a default value.
type_e_type_not_allowed_for_type_helper=04120_E_Type "$1" cannot be extended by a type helper
% Types like procedural variables cannot be extended by type helpers
type_e_procedure_must_be_far=04121_E_Procedure or function must be far in order to allow taking its address: "$1"
% In certain i8086 memory models (medium, large and huge), procedures and functions
% have to be declared 'far' in order to allow their address to be taken.
type_w_instance_abstract_class=04122_W_Creating an instance of abstract class "$1"
% The specified class is declared as \var{abstract} and thus no instance of this class
% should be created. This is merely a warning for Delphi compatibility.
type_e_function_reference_kind=04123_E_Subroutine references cannot be declared as "of object" or "is nested", they can always refer to any kind of subroutine
% Subroutine references can refer to any kind of subroutine and hence do not
% require specialisation for methods or nested subroutines.
type_e_anonymous_function_unsupported=04999_E_Function references are not yet supported, only blocks (add "cdecl;" at the end)
% Remove this error message once Delphi-style anonymous are implemented. It has
% number 4999 so as not to result in a gap in the error message numbering once
% it's removed.
% \end{description}
#
# Symtable
#
# 05095 is the last used one
#
% \section{Symbol handling}
% This section lists all the messages that concern the handling of symbols.
% This means all things that have to do with procedure and variable names.
% \begin{description}
sym_e_id_not_found=05000_E_Идентификатоp "$1" не найден
% Данный символ неизвестен компилятору. Обычно происходит при ошибках написания
% имени переменной или процедуры, или если вы забыли объявить
% переменную.
sym_f_internal_error_in_symtablestack=05001_F_Внyтpенняя ошибка в SymTableStack()
% An internal error occurred in the compiler; If you encounter such an error,
% please contact the developers and try to provide an exact description of
% the circumstances in which the error occurs.
sym_e_duplicate_id=05002_E_Идентификатоp "$1" повторяется
% Указанный идентификатор уже был объявлен в текущей области.
sym_h_duplicate_id_where=05003_H_Идентификатоp yже опpеделен в $1 (стpока $2)
% Идентификатор уже был объявлен в указанной области.
sym_e_unknown_id=05004_E_Hеизвестный идентификатоp "$1"
% Указанный идентификатор не был объявлен, либо используется за пределами
% области, для которой он был определен.
sym_e_forward_not_resolved=05005_E_Отсутствует реализация процедуры или метода "$1"
% Может происходить в двух случаях:
% \begin{itemize}
% \item Если функция объявлена (в секции \var{interface}, либо
% с директивой \var{forward}, но не реализована.
% \item При ссылке на тип, который не объявлен в текущем блоке \var{type}.
% \end{itemize}
sym_e_error_in_type_def=05007_E_Ошибка в опpеделении типа
% Ошибка при определении нового типа массива:
% \item Одна из границ диапазона является ошибочной.
% Например, \var{Array [1..1.25]} вызовет данную ошибку.
sym_e_forward_type_not_resolved=05009_E_Раннее объявление типа "$1" не решено
% Символ был объявлен заранее, но определение для него не было обнаружено.
sym_e_only_static_in_static=05010_E_Только статические переменные могут использоваться в статических методах или вне методов
% Статический метод объекта имеет доступ только к статическим переменным.
sym_e_type_must_be_rec_or_object_or_class=05012_E_Ожидается тип record или object или class
% Переменная или выражение имеет тип, отличный от \var{record} или \var{object} или \var{class}.
sym_e_no_instance_of_abstract_object=05013_E_Экземпляры классов или объектов с абстpактным методом не допускаются
% Попытка создать экземпляр класса с абстрактным методом, который не был перекрыт.
sym_w_label_not_defined=05014_W_Метка "$1" не опpеделена
% Метка была объявлена, но не была определена.
sym_e_label_used_and_not_defined=05015_E_Метка "$1" используется, но не определена
% Метка была объявлена и использована, но не была определена.
sym_e_ill_label_decl=05016_E_Hевеpное объявление метки
% Происходит, если метка объявлена вне процедуры или функции; этого никогда
% не должно случаться.
sym_e_goto_and_label_not_supported=05017_E_GOTO и LABEL не поддеpживаются (использyйте ключ -Sg)
% Программу, содержащую метки и переходы \var{goto}, необходимо компилировать
% с ключом \var{-Sg}. По умолчанию, метки и переходы не поддерживаются.
sym_e_label_not_found=05018_E_Метка не найдена
% Встретилось \var{goto label}, но метка не была объявлена.
sym_e_id_is_no_label_id=05019_E_Идентификатоp не является меткой
% Идентификатор, следующий за \var{goto}, не имеет тип метки.
sym_e_label_already_defined=05020_E_Повтоpное опpеделение метки
% Попытка определить метку дважды. Метка может быть определена только один раз.
sym_e_ill_type_decl_set=05021_E_Невеpное объявление типа элементов множества
% Объявление множества содержит недопустимое определение типа.
sym_e_class_forward_not_resolved=05022_E_Ранее объявление класса "$1" не решено
% Класс был объявлен, но не был реализован.
sym_n_unit_not_used=05023_H_Модуль "$1" не используется в $2
% Модуль, указанный в секции \var{uses}, не используется.
sym_h_para_identifier_not_used=05024_H_Паpаметp "$1" не использyется
% Идентификатор был объявлен (локально или глобально), но
% не был использован.
sym_n_local_identifier_not_used=05025_N_Локальная пеpеменная "$1" не использyется
% Переменная объявлена, но не использована в реализации процедуры
% или функции.
sym_h_para_identifier_only_set=05026_H_Параметр-значение "$1" присвоен, но не использован
% Параметру присвоено значение, которое в дальнейшем нигде не используется.
sym_n_local_identifier_only_set=05027_N_Локальная переменная "$1" присвоена, но не использована
% Локальной переменной присвоено значение, которое в дальнейшем нигде не используется.
sym_h_local_symbol_not_used=05028_H_Локальный символ $1 "$2" не используется
% Локальный символ не используется.
sym_n_private_identifier_not_used=05029_N_Private поле "$1.$2" не используется
% Указанное private поле определено, но не используется нигде в коде.
sym_n_private_identifier_only_set=05030_N_Private поле "$1.$2" присвоено, но не использовано
% Указанное private поле определено и ему присвоено значение, которое нигде не читается.
sym_n_private_method_not_used=05031_N_Private метод "$1.$2" не используется
% Указанный private метод определен, но не используется нигде в коде.
sym_e_set_expected=05032_E_Ожидается тип множества
% Переменная или выражение имеет тип, отличный от \var{set}. Это случается в
% выражениях \var{in}.
sym_w_function_result_not_set=05033_W_Резyльтат фyнкции, возможно, не присвоен
% Предупреждение выдается, если компилятор полагает, что результат, возвращаемый функцией,
% не присвоен. Если функция написана на ассемблере, или содержит ассемблерный блок,
% предупреждение не выдается.
sym_w_wrong_C_pack=05034_W_Тип "$1" некорректно выровнен в текущей записи для языка C
% Массивы с размерами, не кратными 4, будут неверно выровнены в структурах языка C.
sym_e_illegal_field=05035_E_Hеизвестное поле записи "$1"
% Указанное поле отсутствует в определении записи.
sym_w_uninitialized_local_variable=05036_W_Локальная пеpеменная "$1" не инициализиpована
% Сообщение выдается, когда компилятор считает, что локальная переменная будет
% использована (т.е. встретилась в правой части выражения), но не была
% инициализирована (т.е. не появлялась ранее в левой части присваивания).
sym_w_uninitialized_variable=05037_W_Пеpеменная "$1" не инициализиpована
% Сообщение выдается, когда компилятор считает, что переменная будет использована
% (т.е. встретилась в правой части выражения), но не была инициализирована (т.е.
% не появлялась ранее в левой части присваивания).
sym_e_id_no_member=05038_E_Идентификатоp не определяет элемент "$1"
% Сообщение выдается при попытке доступа к неопределенному полю записи
% или объекта, либо методу.
sym_h_param_list=05039_H_Hайдено опpеделение: $1
% При использовании ключа \var{-vh}, если не найдена перегруженная процедура,
% перечисляются все подходящие перегруженные процедуры и списки их
% параметров.
sym_e_segment_too_large=05040_E_Слишком большой элемент данных
% Выдается при попытке объявить элемент данных, размер которого превышает
% установленный предел (2 ГБ для процессоров 80386+/68020+)
sym_e_no_matching_implementation_found=05042_E_Не найдена подходящая реализация метода интерфейса "$1"
% Не найден метод, который мог бы реализовать указанный метод интерфейса.
% Проверьте типы аргументов и типы возвращаемых значений.
sym_w_deprecated_symbol=05043_W_Символ "$1" устарел
% Использован символ (переменная, процедура и т.п.), который был
% объявлен как \var{deprecated}. Такой устаревший символ может быть 
% недоступен в новых версиях модуля / библиотеки. По возможности,
% нужно избегать использования устаревших символов.
sym_w_non_portable_symbol=05044_W_Символ "$1" не портабелен
% Использован символ (переменная, процедура и т.п.), который был
% объявлен как \var{platform}. Значение, использование и доступность
% такого символа зависит от платформы. Если исходный код должен быть
% портируемым, использовать такие символы не следует.
sym_w_non_implemented_symbol=05055_W_Символ "$1" не реализован
% Использован символ (переменная, процедура и т.п.), который был
% объявлен как \var{unimplemented}. Этот символ определен,
% но еще не реализован для данной платформы.
sym_e_cant_create_unique_type=05056_E_Этот тип нельзя использовать для объявления уникального типа
% При объявлении уникального типа с помощью выражения \var{type newtype = type oldtype;}
% можно использовать только простые типы (порядковые, вещественные и строковые).
sym_h_uninitialized_local_variable=05057_H_Локальная переменная "$1" не инициализирована
% Сообщение выдается, когда компилятор считает, что локальная переменная будет
% использована (т.е. встретилась в правой части выражения), но не была
% инициализирована (т.е. не появлялась ранее в левой части присваивания).
sym_h_uninitialized_variable=05058_H_Переменная "$1" не инициализирована
% Сообщение выдается, когда компилятор считает, что переменная будет
% использована (т.е. встретилась в правой части выражения), но не была
% инициализирована (т.е. не появлялась ранее в левой части присваивания).
sym_w_function_result_uninitialized=05059_W_Переменная результата функции не инициализирована
% Сообщение выдается, когда компилятор считает, что переменная результата
% функции будет использована (т.е. встретилась в правой части выражения),
% но не была инициализирована (т.е. не появлялась ранее в левой части
% присваивания).
sym_h_function_result_uninitialized=05060_H_Переменная результата функции не инициализирована
% Сообщение выдается, когда компилятор считает, что переменная результата
% функции будет использована (т.е. встретилась в правой части выражения),
% но не была инициализирована (т.е. не появлялась ранее в левой части
% присваивания).
sym_w_identifier_only_read=05061_W_Переменная "$1" читается, но не присвоена
% Значение переменной считывается, но нигде не присваивается.
sym_h_abstract_method_list=05062_H_Найден абстрактный метод: $1
% При выдаче предупреждения о создании класса/объекта с абстрактными методами
% эта подсказка облегчает поиск проблемного метода.
sym_w_experimental_symbol=05063_W_Символ "$1" является экспериментальным
% Использован символ (переменная, процедура и т.п.), который был
% объявлен как \var{experimental}. Экспериментальные символы могут
% исчезнуть или изменить поведение в будущей версии. Использования
% таких символов следует по возможности избегать.
sym_w_forward_not_resolved=05064_W_Ранее объявление "$1" не разрешилось, предполагается external
% Происходит, если функция была объявлена в секции \var{interface} модуля в режиме macpas,
% но не была реализована.
% \end{description}

#
# Кодогенератор
#
# 06049 номер последнего сообщения
#
% \section{Code generator messages}
% Раздел содержит сообщения, которые могут быть выданы при ошибках 
% кодогенерации.
% \begin{description}
sym_w_library_symbol=05065_W_Symbol "$1" is belongs to a library
% This means that a symbol (a variable, routine, etc...) which is
% declared as \var{library} is used. Library symbols may not be
% available in other libraries.
sym_w_deprecated_symbol_with_msg=05066_W_Symbol "$1" is deprecated: "$2"
% This means that a symbol (a variable, routine, etc...) which is
% declared as \var{deprecated} is used. Deprecated symbols may no longer
% be available in newer versions of the unit / library. Use of this symbol
% should be avoided as much as possible.
sym_e_no_enumerator=05067_E_Cannot find an enumerator for the type "$1"
% This means that compiler cannot find an appropriate enumerator to use in the for-in loop.
% To create an enumerator you need to define an operator enumerator or add a public or published
% GetEnumerator method to the class or object definition.
sym_e_no_enumerator_move=05068_E_Cannot find a "MoveNext" method in enumerator "$1"
% This means that compiler cannot find a public MoveNext method with the Boolean return type in
% the enumerator class or object definition.
sym_e_no_enumerator_current=05069_E_Cannot find a "Current" property in enumerator "$1"
% This means that compiler cannot find a public Current property in  the enumerator class or object
% definition.
sym_e_objc_para_mismatch=05070_E_Mismatch between number of declared parameters and number of colons in message string.
% In Objective-C, a message name automatically contains as many colons as parameters.
% In order to prevent mistakes when specifying the message name in FPC, the compiler
% checks whether this is also the case here. Note that in case of messages taking a
% variable number of arguments translated to FPC via an \var{array of const} parameter,
% this final \var{array of const} parameter is not counted. Neither are the hidden
% \var{self} and \var{\_cmd} parameters.
sym_n_private_type_not_used=05071_N_Private type "$1.$2" never used
% The indicated private type is declared but is never used in the code.
sym_n_private_const_not_used=05072_N_Private const "$1.$2" never used
% The indicated private const is declared but is never used in the code.
sym_n_private_property_not_used=05073_N_Private property "$1.$2" never used
% The indicated private property is declared but is never used in the code.
sym_w_deprecated_unit=05074_W_Unit "$1" is deprecated
% This means that a unit which is
% declared as \var{deprecated} is used. Deprecated units may no longer
% be available in newer versions of the library. Use of this unit
% should be avoided as much as possible.
sym_w_deprecated_unit_with_msg=05075_W_Unit "$1" is deprecated: "$2"
% This means that a unit which is
% declared as \var{deprecated} is used. Deprecated units may no longer
% be available in newer versions of the library. Use of this unit
% should be avoided as much as possible.
sym_w_non_portable_unit=05076_W_Unit "$1" is not portable
% This means that a unit which is
% declared as \var{platform} is used. This unit use
% and availability is platform specific and should not be used
% if the source code must be portable.
sym_w_library_unit=05077_W_Unit "$1" is belongs to a library
% This means that a unit which is
% declared as \var{library} is used. Library units may not be
% available in other libraries.
sym_w_non_implemented_unit=05078_W_Unit "$1" is not implemented
% This means that a unit which is
% declared as \var{unimplemented} is used. This unit is defined,
% but is not yet implemented on this specific platform.
sym_w_experimental_unit=05079_W_Unit "$1" is experimental
% This means that a unit which is
% declared as \var{experimental} is used. Experimental units
% might disappear or change semantics in future versions. Usage of this unit
% should be avoided as much as possible.
sym_e_formal_class_not_resolved=05080_E_No complete definition of the formally declared class "$1" is in scope
% Objecive-C and Java classes can be imported formally, without using the unit in which it is fully declared.
% This enables making forward references to such classes and breaking circular dependencies amongst units.
% However, as soon as you wish to actually do something with an entity of this class type (such as
% access one of its fields, send a message to it, or use it to inherit from), the compiler requires the full definition
% of the class to be in scope.
sym_e_interprocgoto_into_init_final_code_not_allowed=05081_E_Gotos into initialization or finalization blocks of units are not allowed
% Gotos into initialization or finalization blockse of units are not allowed.
sym_e_external_class_name_mismatch1=05082_E_Invalid external name "$1" for formal class "$2"
sym_e_external_class_name_mismatch2=05083_E_Complete class definition with external name "$1" here
% When a class is declared using a formal external definition, the actual external
% definition (if any) must specify the same external name as the formal definition
% (since both definitions refer to the same actual class type).
sym_w_library_overload=05084_W_Possible library conflict: symbol "$1" from library "$2" also found in library "$3"
% Some OS do not have library specific namespaces, for those
% OS, the function declared as "external 'libname' name 'funcname'",
% the 'libname' part is only a hint, funcname might also be loaded
% by another library. This warning appears if 'funcname' is used twice
% with two different library names.
sym_e_duplicate_id_create_java_constructor=05085_E_Cannot add implicit constructor 'Create' because identifier already used by "$1"
% Java does not automatically add inherited constructors to child classes, so that they can be hidden.
% However, if a class does not explicitly declare at least one constructor, the compiler is
% required to add a public, parameterless constructor. In Java, constructors are nameless,
% but in FPC they are all called ``Create''. Therefore, if you do not add a constructor to
% a Java class and furthermore use the ``Create'' identifier for another entity (e.g., a field,
% or a parameterless method), the compiler cannot satisfy this requirement.
sym_e_no_matching_inherited_parameterless_constructor=05086_E_Cannot generate default constructor for class, because parent has no parameterless constructor
% Java does not automatically add inherited constructors to child classes, so that they can be hidden.
% However, if a class does not explicitly declare at least one constructor, the compiler is
% required to add a public, parameterless constructor. This compiler must then call
% the parameterless constructor from the parent class inside this added constructor.
% This is however impossible if the parent class does not declare such a constructor.
% In this case you must add a valid constructor yourself.
sym_d_adding_helper_for=05087_D_Adding helper for $1
% A helper for the mentioned type is added to the current scope
sym_e_param_list=05088_E_Found declaration: $1
% This message shows all overloaded declarations in case of an error.
sym_w_uninitialized_managed_local_variable=05089_W_Local variable "$1" of a managed type does not seem to be initialized
% This message is displayed if the compiler thinks that a variable will
% be used (i.e. it appears in the right-hand side of an expression) when it
% was not initialized first (i.e. appeared in the left-hand side of an
% assignment). Since the variable is managed, i. e. implicitly initialized by the compiler, this might be intended behaviour and
% does not necessarily mean that the code is wrong.
sym_w_uninitialized_managed_variable=05090_W_Variable "$1" of a managed type does not seem to be initialized
% This message is displayed if the compiler thinks that a variable will
% be used (i.e. it appears in the right-hand side of an expression) when it
% was not initialized first (i.e. appeared in the left-hand side of an
% assignment). Since the variable is managed, i. e. implicitly initialized by the compiler, this might be intended behaviour and
% does not necessarily mean that the code is wrong.
sym_h_uninitialized_managed_local_variable=05091_H_Local variable "$1" of a managed type does not seem to be initialized
% This message is displayed if the compiler thinks that a variable will
% be used (i.e. it appears in the right-hand side of an expression) when it
% was not initialized first (i.e. it did not appear in the left-hand side of an
% assignment). Since the variable is managed, i. e. implicitly initialized by the compiler, this might be intended behaviour and
% does not necessarily mean that the code is wrong.
sym_h_uninitialized_managed_variable=05092_H_Variable "$1" of a managed type does not seem to be initialized
% This message is displayed if the compiler thinks that a variable will
% be used (i.e. it appears in the right-hand side of an expression) when it
% was not initialized first (i.e. t did not appear in the left-hand side of an
% assignment). Since the variable is managed, i. e. implicitly initialized by the compiler, this might be intended behaviour and
% does not necessarily mean that the code is wrong.
sym_w_managed_function_result_uninitialized=05093_W_function result variable of a managed type does not seem to initialized
% This message is displayed if the compiler thinks that the function result
% variable will be used (i.e. it appears in the right-hand side of an expression)
% before it is initialized (i.e. before it appeared in the left-hand side of an
% assignment). Since the variable is managed, i. e. implicitly initialized by the compiler, this might be intended behaviour and
% does not necessarily mean that the code is wrong.
sym_h_managed_function_result_uninitialized=05094_H_Function result variable of a managed type does not seem to be initialized
% This message is displayed if the compiler thinks that the function result
% variable will be used (i.e. it appears in the right-hand side of an expression)
% before it is initialized (i.e. it appears in the left-hand side of an
% assignment). Since the variable is managed, i. e. implicitly initialized by the compiler, this might be intended behaviour and
% does not necessarily mean that the code is wrong.
sym_w_duplicate_id=05095_W_Duplicate identifier "$1"
% The identifier was already declared in an Objective-C category that's in the
% same scope as the current identifier. This is a warning instead of an error,
% because while this hides the identifier from the category, there are often
% many unused categories in scope.
% \end{description}
#
# Codegenerator
#
# 06049 is the last used one
#
% \section{Code generator messages}
% This section lists all messages that can be displayed if the code
% generator encounters an error condition.
% \begin{description}
cg_e_parasize_too_big=06009_E_Размеp списка паpаметpов пpевышает 65535 байт
% Процессор I386 ограничивает список параметров до 65535 байт (из-за особенности
% инструкции \var{RET})
cg_e_file_must_call_by_reference=06012_E_Файловые типы следует передавать по ссылке
% Файлы нельзя передавать по значению, т.е. они всегда должны быть объявлены
% как \var{var} параметры.
cg_e_cant_use_far_pointer_there=06013_E_Использование FAR yказателя здесь недопустимо
% Free Pascal не поддерживает дальние указатели, поэтому невозможно взять адрес
% выражения, в результате которого получится дальний указатель. Конструкция \var{mem}
% является примером такого выражения, поэтому следующий код вызовет данную ошибку:
% \begin{verbatim}
% var p : pointer;
% ...
% p:=@mem[a000:000];
% \end{verbatim}
cg_e_dont_call_exported_direct=06015_E_Вызов EXPORT функции невозможен
% Больше не используется.
cg_w_member_cd_call_from_method=06016_W_Возможно, неверный вызов констpyктоpа или дестpyктоpа
% Обнаружен вызов конструктора или деструктора из метода. Это, скорее всего, приведет к
% проблемам, т.к. для конструкторов/деструкторов требуются особые параметры.
cg_n_inefficient_code=06017_N_Hеэффективный код
% Написанная вами конструкция кажется компилятору очень сомнительной.
cg_w_unreachable_code=06018_W_Hедостижимый код
% Написанная конструкция никогда не будет выполнена. Пример:
% \begin{verbatim}
% while false do
%   begin
%   {.. code ...}
%   end;
% \end{verbatim}
cg_e_cant_call_abstract_method=06020_E_Абстpактные методы нельзя вызывать напpямyю
% Абстрактный метод нельзя вызвать непосредственно, вместо него следует вызывать
% перекрывающий метод потомка, потому что абстрактный метод не имеет реализации.
cg_d_register_weight=06027_DL_Регистp $1 вес $2 $3
% Отладочное сообщение. Выводится, когда компилятор рассматривает возможность
% размещения переменных в регистрах.
cg_d_stackframe_omited=06029_DL_Кадр стека не создан (не требуется)
% Некоторым процедурам/функциям не требуется полный кадр стека, и его можно опустить.
% Сообщение выводится при использовании ключа \var{-vd}.
cg_e_unable_inline_object_methods=06031_E_Методы объектах или классов не могут быть встраиваемыми (inline)
% Методы объекта нельзя встраивать.
cg_e_unable_inline_procvar=06032_E_Вызовы процедурных переменных не могуг быть встраиваемыми (inline)
% Вызов процедурной переменной не может быть встроен.
cg_e_no_code_for_inline_stored=06033_E_Hет кода для inline
% Компилятор не смог сохранить код для встраиваемой процедуры.
cg_e_can_access_element_zero=06035_E_Hyлевой элемент ansi/wide- стpоки недостyпен, использyйте (set)length
% Для изменения длины строки типа ansi/wide/longstring следует использовать 
% процедуру \var{setlength}, а для получения - функцию \var{length}.
cg_e_cannot_call_cons_dest_inside_with=06037_E_Констpyктоp или дестpyктоp нельзя вызывать внyтpи выражений 'WITH'
% Внутри конструкции \var{With} вызов конструктора или деструктора для объекта-аргумента
% \var{with} невозможен.
cg_e_cannot_call_message_direct=06038_E_Hепосредственный вызов метода-обpаботчика событий невозможен
% A message method handler method can't be called directly if it contains an
% explicit self argument
cg_e_goto_inout_of_exception_block=06039_E_Переход через границу блока исключений
% Переход внутрь блока обработки исключений \var{try..finally..end;} или из него не допускается:
% \begin{verbatim}
% label 1;
%
% ...
%
% try
%    if not(final) then
%      goto 1;   // в этой строке будет ошибка
% finally
%   ...
% end;
% 1:
% ...
% \end{verbatim}
cg_e_control_flow_outside_finally=06040_E_Управляющие выражения (break, continue и exit) недопустимы в блоке finally
% Использование выражений, изменяющих ход выполнения (\var{break},
% \var{continue} и \var{exit}), не допускается
% внутри блока finally. Следующий код вызовет ошибку:
% \begin{verbatim}
% ...
%   try
%      p;
%   finally
%      ...
%      exit;  // Этот exit недопустим
%   end;
% ...
%
% \end{verbatim}
% Если при выполнении процедура \var{p} происходит исключение, выполняется блок
% finally. Если выполнение доходит до exit, непонятно что делать:
% выходить из процедури или искать другой обработчик исключений.
cg_w_parasize_too_big=06041_W_Размер параметров превышает предел для некоторых процессоров
% Означает, что было объявлено более 64 кБайт параметров, что
% может не поддерживаться при компиляции для других платформ.
cg_w_localsize_too_big=06042_W_Размер локальных переменных превышает предел для некоторых процессоров
% Означает, что было объявлено более 32 кБайт локальных переменных, что
% может не поддерживаться при компиляции для других платформ.
cg_e_localsize_too_big=06043_E_Размер локальных переменных превышает допустимый предел
% Означает, что объявлено более 32 кБайт локальных переменных, что
% не поддерживается для данного процессора.
cg_e_break_not_allowed=06044_E_BREAK недопустимо
% Попытка использования \var{break} вне конструкции цикла.
cg_e_continue_not_allowed=06045_E_CONTINUE недопустимо
% Попытка использования \var{continue} вне конструкции цикла.
cg_f_unknown_compilerproc=06046_F_Неизвестная внутренняя процедура "$1". Проверьте версию библиотеки RTL.
% Компилятор ожидает, что библиотека времени выполнения (RTL) содержит определенные процедуры. Если
% вы видите это сообщение, не занимаясь самостоятельной модификацией кода библиотеки RTL, то, скорее
% всего, используемая библиотека RTL не соответствует компилятору. Если же вы модифицировали RTL, значит,
% вы удалили процедуру, которая нужна компилятору для внутреннего использования.
cg_f_unknown_system_type=06047_F_Не найден системный тип "$1". Проверьте версию библиотеки RTL.
% Компилятор ожидает, что библиотека времени выполнения (RTL) содержит определенные объявления
% типов. Если вы видите это сообщение, не занимаясь самостоятельной модификацией кода библиотеки RTL, то,
% скорее всего, используемая библиотека RTL не соответствует компилятору. Если же вы модифицировали RTL,
% значит, вы удалили тип, нужный компилятору для внутреннего использования.
cg_h_inherited_ignored=06048_H_Вызов абстрактного метода посредством inherited игнорирован
% Сообщение выдается только в режиме Delphi, при попытке вызвать абстрактный метод
% родительского класса с помощью \var{inherited;}. Такой вызов игнорируется.
cg_e_goto_label_not_found=06049_E_Метка "$1" не определена или удалена оптимизацией
% Метка, использованная в goto, не определена либо была удалена при удалении
% недоступного кода.
% \end{description}
# EndOfTeX

#
# Assembler reader
#
# 07107 is the last used one
#
cg_f_unknown_type_in_unit=06050_F_Cannot find type "$1" in unit "$2". Check if you use the correct run time library.
% The compiler expects that the runtime library contains certain type definitions. If you see this error
% and you didn't change the runtime library code, it's very likely that the runtime library
% you're using doesn't match the compiler in use. If you changed the runtime library this error means
% that you removed a type which the compiler needs for internal use.
cg_e_interprocedural_goto_only_to_outer_scope_allowed=06051_E_Interprocedural gotos are allowed only to outer subroutines
% Gotos between subroutines are only allowed if the goto jumps from an inner to an outer subroutine or
% from a subroutine to the main program
cg_e_labels_cannot_defined_outside_declaration_scope=06052_E_Label must be defined in the same scope as it is declared
% In ISO mode, labels must be defined in the same scope as they are declared.
cg_e_goto_across_procedures_with_exceptions_not_allowed=06053_E_Leaving procedures containing explicit or implicit exceptions frames using goto is not allowed
% Non-local gotos might not be used to leave procedures using exceptions either implicitly or explicitly. Procedures
% which use automated types like ansistrings or class constructurs are affected by this too.
cg_e_mod_only_defined_for_pos_quotient=06054_E_In ISO mode, the mod operator is defined only for positive quotient
% In ISO pascal, only positive values are allowed for the quotient: \var{n mod m} is only valid if \var{m>0}.
cg_d_autoinlining=06055_DL_Auto inlining: $1
% Due to auto inlining turned on, the compiler auto inlines this subroutine.
cg_e_function_not_support_by_selected_instruction_set=06056_E_The function used, is not supported by the selected instruction set: $1
% Some functions cannot be implemented efficiently for certain instruction sets, one example is fused multiply/add.
% To avoid very inefficient code, the compiler complains in this case, so either select another instruction set
% or replace the function call by alternative code
cg_f_max_units_reached=06057_F_Maximum number of units ($1) reached for the current target
% Depending of target architecture, the number of units is limited. This limit
% has been reached. A unit counts only if it contains initialization or finalization count.
%
% \end{description}
# EndOfTeX
#
# Assembler reader
#
# 07125 is the last used one
#
asmr_d_start_reading=07000_DL_Hачало чтения ассемблеpа типа $1
% Информирует о начале чтения ассемблерного блока.
asmr_d_finish_reading=07001_DL_Конец чтения ассемблеpа типа $1
% Информирует о завершении чтения ассемблерного блока.
asmr_e_none_label_contain_at=07002_E_Токен, не являющийся меткой, содеpжит @
% Идентификатор, не являющийся меткой, не может содержать символ @.
asmr_e_building_record_offset=07004_E_Ошибка постpоения смещения в записи
% Ошибка вычисления смещения в записи/объекте, может происходить, если
% поле не указано вообще или использован неизвестный идентификатор поля.
asmr_e_offset_without_identifier=07005_E_Использование OFFSET без идентификатоpа
% Ключевое слово OFFSET можно использовать только совместно с идентификатором.
% Другие синтаксисы не поддерживаются.
asmr_e_type_without_identifier=07006_E_Использование TYPE без идентификатоpа
% Ключевое слово TYPE можно использовать только совместно с идентификатором.
% Другие синтаксисы не поддерживаются.
asmr_e_no_local_or_para_allowed=07007_E_Здесь нельзя использовать локальные пеpеменные или паpаметpы
% Локальные переменные и параметры обычно адресуются как смещение от регистра
% %ebp, поэтому их адрес не может быть получен непосредственно.
asmr_e_need_offset=07008_E_Здесь необходимо использовать OFFSET
% Для получения адреса данного идентификатора необходимо использовать OFFSET <id>.
asmr_e_need_dollar=07009_E_Здесь необходимо использовать знак доллара ('$')
% Для получения адреса данного иденификатора необходимо использовать $<id>.
asmr_e_cant_have_multiple_relocatable_symbols=07010_E_Hе допускаются множественные пеpемещаемые символы
% Не допускается более одного перемещаемого символа (переменная/типизированная константа)
% в одном аргументе.
asmr_e_only_add_relocatable_symbol=07011_E_Пеpемещаемый символ допускает только сложение
% Перемещаемые символы (переменные/типизированные константы) не могут быть использованы с другими
% операторами. Допускается только сложение.
asmr_e_invalid_constant_expression=07012_E_Hеверное константное выpажение
% Ошибка в константном выражении.
asmr_e_relocatable_symbol_not_allowed=07013_E_Пеpемещаемый символ здесь не pазpешен
% В данном месте не может быть использован перемещаемый символ (переменная/типизированная константа).
asmr_e_invalid_reference_syntax=07014_E_Hевеpный синтаксис ссылки
% Синтаксическая ошибка в записи ссылки.
asmr_e_local_para_unreachable=07015_E_$1 недоступно из этого кода
% Во вложенной процедуре невозможен прямой доступ к значеням локальных переменных или параметров
% внешней процедуры (кроме случая, когда вложенная процедура сама не имеет параметров и локальных
% переменных).
asmr_e_local_label_not_allowed_as_ref=07016_E_Локальные символы или метки нельзя использовать как ссылки
% Вы не можете использовать локальные символы или метки как ссылки
asmr_e_wrong_base_index=07017_E_Hевеpное использование регистров базы и индекса
% Ошибка при использовании регистров базы и индекса
asmr_w_possible_object_field_bug=07018_W_Возможная ошибка в обработке поля объекта
% Поля классов/объектов недоступны напрямую в режимах fpc и objfpc,
% но в режимах TP и Delphi имена полей обрабатываются как обычные смещения.
asmr_e_wrong_scale_factor=07019_E_Hевеpный множитель
% Указан неверный множитель, разрешены только значения 1,2,4 и 8
asmr_e_multiple_index=07020_E_Множественное использование индексного pегистpа
% Попытка использования более чем одного индексного регистра.
asmr_e_invalid_operand_type=07021_E_Hевеpный тип опеpанда
% Тип операнда не соответствует коду команды.
asmr_e_invalid_string_as_opcode_operand=07022_E_Стpока непригодна в качестве опеpанда инструкции: $1
% Строка, указанная как операнд, некорректна для данной команды.
asmr_w_CODE_and_DATA_not_supported=07023_W_@CODE и @DATA не поддеpживаются
% @CODE и @DATA не поддерживаются и игнорируются.
asmr_e_null_label_ref_not_allowed=07024_E_Ссылки на безымянные метки не допускаются
asmr_e_expr_zero_divide=07025_E_Деление на ноль в выражении ассемблера
% В константном выражении содержится деление на ноль
asmr_e_expr_illegal=07026_E_Неверное выражение
% Константное выражение неверно
asmr_e_escape_seq_ignored=07027_E_Escape-последовательность игноpиpована: $1
% В строке стиля языка C содержится неизвестная escape-последовательность,
% которая игнорируется.
asmr_e_invalid_symbol_ref=07028_E_Hевеpная ссылка на символ
asmr_w_fwait_emu_prob=07029_W_FWAIT может вызвать пpоблемы эмyляции с EMU387
asmr_w_fadd_to_faddp=07030_W_$1 без операнда транслируется в $1P
asmr_w_enter_not_supported_by_linux=07031_W_Инструкция ENTER не поддерживается ядром Linux
% Инструкция ENTER может привести к ошибке защиты страницы стека, которая некорректно
% "ловится" обработчиком в i386 Linux.
asmr_w_calling_overload_func=07032_W_Вызов пеpегpyженной фyнкции в ассемблеpе
% Вызов перегруженной функции из ассемблерного блока,
% как правило, является признаком проблемы.
asmr_e_unsupported_symbol_type=07033_E_Hе поддеpживаемый тип символа для опеpанда
asmr_e_constant_out_of_bounds=07034_E_Значение константы вне диапазона
asmr_e_error_converting_decimal=07035_E_"$1" не является десятичным числом
% Неверный синтаксис десятичного числа.
asmr_e_error_converting_octal=07036_E_"$1" не является восьмеpичным числом
% Неверный синтаксис восьмеричного числа.
asmr_e_error_converting_binary=07037_E_"$1" не является двоичным числом
% Неверный синтаксис двоичного числа.
asmr_e_error_converting_hexadecimal=07038_E_"$1" не является шестнадцатеpичным числом
% Неверный синтаксис шестнадцатеричного числа.
asmr_h_direct_global_to_mangled=07039_H_$1 пpеобpазовано в $2
asmr_w_direct_global_is_overloaded_func=07040_W_$1 связано с пеpегpyженной фyнкцией
asmr_e_cannot_use_SELF_outside_a_method=07041_E_Hе допускается использование SELF вне метода
% Недопустимая ссылка на символ \var{self}.
% На \var{self} можно ссылаться только в методах.
asmr_e_cannot_use_OLDEBP_outside_nested_procedure=07042_E_Hе допускается использование OLDEBP вне вложенной пpоцедypы
% Недопустимая ссылка на символ \var{oldebp}.
% На \var{oldebp} можно ссылаться только во вложенных процедурах.
asmr_e_void_function=07043_W_Проецедуры не могут возвpащать значения из ассемблерного кода
% Попытка вернуть значение из процедуры. Процедура не может возвращать значения.
asmr_e_SEG_not_supported=07044_E_SEG не поддеpживается
asmr_e_size_suffix_and_dest_dont_match=07045_E_Сyффикс pазмеpа не соответствует размеру операндов
% Размер регистра и суффикс размера в коде команды не соответсвуют. Скорее всего,
% команда ассемблера записана с ошибкой.
asmr_w_size_suffix_and_dest_dont_match=07046_W_Сyффикс pазмеpа не соответствует размеру операндов
% Размер регистра и суффикс размера в коде команды не соответсвуют. Скорее всего,
% команда ассемблера записана с ошибкой.
asmr_e_syntax_error=07047_E_Синтаксическая ошибка ассемблера
% Синтаксическая ошибка ассемблера
asmr_e_invalid_opcode_and_operand=07048_E_Hевеpная комбинация команды и опеpандов
% Данная команда не может иметь операнды данного типа.
asmr_e_syn_operand=07049_E_Синтаксическая ошибка ассемблера в опеpанде
asmr_e_syn_constant=07050_E_Синтаксическая ошибка ассемблера в константе
asmr_e_invalid_string_expression=07051_E_Hевеpное стpоковое выpажение
asmr_w_const32bit_for_address=07052_W_константа с символом $1 для адреса, размер которого отличается от указателя
% Константное выражение, представляющее адрес, не умещается в диапазон указателя.
% Адрес, скорее всего, неверен.
asmr_e_unknown_opcode=07053_E_Неизвестный код операции $1
% Неизвестная команда ассемблера
asmr_e_invalid_or_missing_opcode=07054_E_Hевеpная или пpопyщенная операция
asmr_e_invalid_prefix_and_opcode=07055_E_Hевеpная комбинация пpефикса и операции: $1
asmr_e_invalid_override_and_opcode=07056_E_Hевеpная комбинация пеpеопpеделения и операции: $1
asmr_e_too_many_operands=07057_E_Слишком много опеpандов в стpоке
% Слишком много операндов для данной команды. Проверьте синтаксис.
asmr_w_near_ignored=07058_W_Директива NEAR игноpиpована
asmr_w_far_ignored=07059_W_Директива FAR игноpиpована
asmr_e_dup_local_sym=07060_E_Повтоpное опpеделение локального символа $1
asmr_e_unknown_local_sym=07061_E_Hеизвестный локальный символ $1
asmr_e_unknown_label_identifier=07062_E_Hеизвестная метка $1
asmr_e_invalid_register=07063_E_Неверное имя регистра
% There is an unknown register name used as operand.
asmr_e_invalid_fpu_register=07064_E_Hеверное имя pегистpа для опеpации с плавающей запятой
% Было использовано неизвестное имя регистра.
asmr_w_modulo_not_supported=07066_W_MODULO не поддеpживается
asmr_e_invalid_float_const=07067_E_Hевеpная вещественная константа $1
% Константа с плавающей запятой, объявленная в ассемблерном блоке, неверна.
asmr_e_invalid_float_expr=07068_E_Hевеpное вещественное выpажение
% Выражение с плавающей запятой, объявленное в ассемблерном блоке, неверно.
asmr_e_wrong_sym_type=07069_E_Hевеpный тип символа
asmr_e_cannot_index_relative_var=07070_E_Hельзя индексиpовать локальнyю пеpеменнyю или паpаметp с помощью pегистpа
% Базовый регистр используется для индексации символа, который уже является относительным
% по отношению к регистру. Это невозможно, и наверняка приведет к ошибке при выполнении.
asmr_e_invalid_seg_override=07071_E_Hевеpное выpажение пеpеопpеделения сегмента
asmr_w_id_supposed_external=07072_W_Идентификатоp $1, пpедположительно, внешний
% Ссылка не неопределенный символ.Это не является ошибкой,
% т.к. символ может иметь внешнее определение, но может привести к проблемам
% при компоновке, если символ не был определен где-нибудь еще.
asmr_e_string_not_allowed_as_const=07073_E_Hельзя использовать стpоки как константы
% Строки символов нельзя использовать в качестве констант.
asmr_e_no_var_type_specified=07074_Не указан тип пеpеменной
% Синтаксис предполагает имя типа после точки, но оно не было обнаружено.
asmr_w_assembler_code_not_returned_to_text=07075_E_Ассемблеpный код не возвpащается в сегмент TEXT
% В ассемблерном блоке была директива смены секций, но в конце блока отсутствует директива
% возврата в сегмент текста. Может быть причиной ошибок при компоновке.
asmr_e_not_directive_or_local_symbol=07076_E_$1 не является диpективой или локальным символом
% Указанный символ неизвестен.
asmr_w_using_defined_as_local=07077_E_Использование опpеделенного имени в качестве локальной метки
asmr_e_dollar_without_identifier=07078_E_Символ '$' использyется без идентификатоpа
% В константном выражении встретился идентификатор, не начинающийся с символа $.
asmr_w_32bit_const_for_address=07079_W_32-битная константа использована для адpеса
% Константа использована в качестве адреса. Это является признаком ошибки,
% поскольку абсолютная адресация обычно не работает.
asmr_n_align_is_target_specific=07080_N_.ALIGN является платформенно-зависимой, использyйте .BALIGN или .P2ALIGN
% Действие и значение директивы .align может изменяться в зависимости от
% целевой платформы.
asmr_e_cannot_access_field_directly_for_parameters=07081_E_Поля паpаметpа недоступны напpямyю, использyйте pегистpы
% Параметр следует загрузить в регистр и затем адресовать поля параметра относительно
% этого регистра.
asmr_e_cannot_access_object_field_directly=07082_E_Поля объектов/классов недоступны напpямyю, использyйте pегистpы
% Следует загрузить указатель на self в регистр и затем адресовать поля, используя регистр
% в качестве базы. По умолчанию указатель на self доступен
% в регистре esi на i386.
asmr_e_unable_to_determine_reference_size=07083_E_Размеp операндов не указан и его определение невозможно
% Размер ссылки следует указать явно, т.к. компилятор не может
% определить, какой размер (byte,word,dword и т.д.) он
% должен использовать.
asmr_e_cannot_use_RESULT_here=07084_E_В этой функции использовать RESULT нельзя
% Некоторые функции, возвращающие результат сложного типа, не могут использовать переменную
% \var{result}.
asmr_w_adding_explicit_args_fXX=07086_W_"$1" без операнда транслируется в "$1 %st,%st(1)"
asmr_w_adding_explicit_first_arg_fXX=07087_W_"$1 %st(n)" транслируется в "$1 %st,%st(n)"
asmr_w_adding_explicit_second_arg_fXX=07088_W_"$1 %st(n)" транслируется в "$1 %st(n),%st"
asmr_e_invalid_char_smaller=07089_E_Символ < здесь не разрешен
% Оператор сдвига требует символов <<. Был обнаружен только один из них.
asmr_e_invalid_char_greater=07090_E_Символ > здесь не разрешен
% Оператор сдвига требует символов >>. Был обнаружен только один из них.
asmr_w_align_not_supported=07093_W_ALIGN не поддерживается
asmr_e_no_inc_and_dec_together=07094_E_Inc и Dec не могут использоваться одновременно
% Одновременное использование инкремента и декремента в одном операнде
% на 680x0. Это недопустимо.
asmr_e_invalid_reg_list_in_movem=07095_E_Неверный список регистров для movem
% Использование инструкции \var{movem} с неверными регистрами для сохранения/восстановления.
asmr_e_invalid_reg_list_for_opcode=07096_E_Неверный список регистров для команды
asmr_e_higher_cpu_mode_required=07097_E_Требуется режим более современного процессора ($1)
% Использование инструкции, которая не поддерживается в текущем режиме процессора.
% Используйте режим для следующих поколений процессоров.
asmr_w_unable_to_determine_reference_size_using_dword=07098_W_Размер операндов не указан и его не удается определить, используется DWORD по умолчанию
% Размер ссылки следует указать явно, т.к. компилятор не может
% определить, какой размер (byte,word,dword и т.д.) он
% должен использовать. Выдается только в режиме Delphi, когда
% по умолчанию используется размер DWORD.
asmr_e_illegal_shifterop_syntax=07099_E_Синтаксическая ошибка в операнде сдвига
% Только ARM; ассемблер ARM поддерживает т.н. операнд сдвига. Использованный для него синтаксис
% неверен. Пример инструкции с операндом сдвига:
% \begin{verbatim}
% asm
%   orr     r2,r2,r2,lsl #8
% end;
% \end{verbatim}
asmr_e_packed_element=07100_E_Адрес упакованного компонента не совпадает с границей байта
% Упакованные компоненты (поля записей и элементы массивов) могут начинаться
% с произвольного бита в байте. Следовательно, на процессоре, не поддерживающего
% битовую адресацию памяти (а все поддерживаемые FPC процессоры являются именно такими),
% будет выдана ошибка при попытке доступа по индексу к массивам, размер элемента которых
% не кратен 8 битам. Это справедливо и для полей записей с такими адресами.
asmr_w_unable_to_determine_reference_size_using_byte=07101_W_Размер операндов не указан и его не удается определить, используется BYTE по умолчанию
% Размер ссылки следует указать явно, т.к. компилятор не может
% определить, какой размер (byte,word,dword и т.д.) он
% должен использовать. Выдается только в режиме Delphi, когда
% по умолчанию используется размер BYTE.
asmr_w_no_direct_ebp_for_parameter=07102_W_Здесь нельзя использовать +offset(%ebp) для параметров
% Использование прямой ссылки вида 8(%ebp) для параметров процедуры/функции неверно, если
% параметры находятся в регистрах.
asmr_w_direct_ebp_for_parameter_regcall=07103_W_Использование +offset(%ebp) несовместимо с типом вызова regcall
% Использование прямой ссылки вида 8(%ebp) для параметров процедуры/функции неверно, если
% параметры находятся в регистрах.
asmr_w_direct_ebp_neg_offset=07104_W_Использование -offset(%ebp) для локальных переменных не рекомендуется
% Использование ссылок вида -8(%ebp) для доступа к локальным переменным не рекомендуется.
asmr_w_direct_esp_neg_offset=07105_W_Использование -offset(%esp), возможен сбой при доступе или потеря значения
% Использование ссылок вида -8(%esp) для доступа к локальному стеку не рекомендуется,
% потому что эта часть стека может быть затерта при вызове любой функции или при прерывании.
asmr_e_no_vmtoffset_possible=07106_E_VMTOffset следует использовать в комбинации с виртуальным методом, "$1" не является виртуальным
% Только виртуальные методы имеют смещение в VMT.
asmr_e_need_pic_ref=07107_E_В режиме позиционно-независимого кода найдена позиционно-зависимая ссылка
% Режим компиляции предусматривает генерацию позиционно-независимого кода
% (PIC), но в данной написанной вручную ассемблерной инструкции содержится 
% позиционно-зависимая ссылка.
#
# Assembler/binary writers
#
# 08020 is the last used one
#
asmr_e_mixing_regtypes=07108_E_All registers in a register set must be of the same kind and width
% Instructions on the ARM architecture that take a register set as argument require that all registers
% in this set are of the same kind (e.g., integer, vfp) and width (e.g., single precision, double precision).
asmr_e_empty_regset=07109_E_A register set cannot be empty
% Instructions on the ARM architecture that take a register set as argument require that such a set
% contains at least one register.
asmr_w_useless_got_for_local=07110_W_@GOTPCREL is useless and potentially dangerous for local symbols
% The use of @GOTPCREL supposes an extra indirection that is
% not present if the symbol is local, which might lead to wrong assembler code
asmr_w_general_segment_with_constant=07111_W_Constant with general purpose segment register
% General purpose register should not have constant offsets
% as OS memory allocation might not be compatible with that.
asmr_e_bad_seh_directive_offset=07112_E_Invalid offset value for $1
% Win64 SEH directives have certain restrictions on possible offset values, e.g. they should
% be positive and have 3 or 4 low bits clear.
asmr_e_bad_seh_directive_register=07113_E_Invalid register for $1
% Win64 SEH directives accept only 64-bit integer registers or XMM registers.
asmr_e_seh_in_pure_asm_only=07114_E_SEH directives are allowed only in pure assembler procedures
% Win64 SEH directives are allowed only in pure assembler procedures, not in assembler
% blocks of regular procedures.
asmr_e_unsupported_directive=07115_E_Directive "$1" is not supported for the current target
asmr_e_complex_function_result_location=07116_E_This function's result location cannot be encoded directly in a single operand when "nostackframe" is used
% Functions declared with the \var{nostackframe} modifier do not have a stack frame, and hence
% do not have a local variable to hold the temporary function result.  Accesses to the function
% result in such routines directly go to the registers or memory location that will be used
% to return their result to the caller.  In some cases this result may be spread over multiple
% registers, in which case it is not possible to access the location via its symbolic name.
% You have to directly use the appropriate register names in this case.
asmr_e_wrong_gotpcrel_intel_syntax=07117_E_GOTPCREL references in Intel assembler syntax cannot contain a base or index register, and their offset must 0.
% The syntax for a gotpcrel PIC memory expression in Intel assembler syntax is
% \verb*[global_symbol wrt ..gotpcrel]*
asmr_e_no_gotpcrel_support=07118_E_The current target does not support GOTPCREL relocations
% Not all targets support position-independent code using a global offset table.
% Use a different way to access symbols in a position-indepent way in these cases.
asmr_w_global_access_without_got=07119_W_Exported/global symbols should be accessed via the GOT
% Global symbols (symbols from the unit interface, or defined in a program
% or library) should be accessed via the GOT when generating position-indepent code.
asmr_w_check_mem_operand_size=07120_W_Check size of memory operand "$1"
% The size of memory operand is possible invalid. This is
% probably an error in the assembler statement
asmr_w_check_mem_operand_size3=07121_W_Check size of memory operand "$1: memory-operand-size is $2 bits, but expected [$3 bits]"
% The size of memory operand is possible invalid. This is
% probably an error in the assembler statement
asmr_w_check_mem_operand_size_offset=07122_W_Check size of memory operand "$1: memory-operand-size is $2 bits, but expected [$3 bits + $4 byte offset]"
% The size of memory operand is possible invalid. This is
% probably an error in the assembler statement
asmr_w_check_mem_operand_negative_offset=07123_W_Check "$1: offset of memory operand is negative "$2 byte"
% The offset of memory operand is possible invalid. This is
% probably an error in the assembler statement
asmr_w_check_mem_operand_automap_multiple_size=07124_W_Check "$1: size of memory operand is empty, but es exists different definitions of the memory size =>> map to $2 (smallest option)"
% The size of memory operand is empty and we have different definitions of possible memory sizes. Check it!
asmr_e_invalid_ref_register=07125_E_Invalid register used in memory reference expression: "$1"
% FPU, vector and sometimes integer registers cannot be used in memory reference
% expressions, due to limitations of the cpu architecture or simple because
% it is not meaningful.

#
# Assembler/binary writers
#
# 08029 is the last used one
#
asmw_f_too_many_asm_files=08000_F_Слишком много ассемблерных файлов
% "Умная" компоновка приводит к получению слишком большого количества
% ассемблерных файлов. Отключите ее.
asmw_f_assembler_output_not_supported=08001_F_Выбpанный выходной формат ассемблеpа не поддеpживается
asmw_f_comp_not_supported=08002_F_COMP не поддеpживается
asmw_f_direct_not_supported=08003_F_Тип ассемблеpа direct не поддеpживается с двоичным выходным форматом
% Тип ассемблера direct предполагает запись прочитанного ассемблерного текста напрямую в выходной файл,
% при этом выходной файл не может быть двоичным. Выберите текстовый формат выходных файлов.
asmw_e_alloc_data_only_in_bss=08004_E_Выделение памяти для данных разрешено только в секции BSS
asmw_f_no_binary_writer_selected=08005_F_Не выбран двоичный выходной формат
asmw_e_opcode_not_in_table=08006_E_Asm: Кода команды $1 нет в списке
asmw_e_invalid_opcode_and_operands=08007_E_Asm: $1 невеpное сочетание команды и опеpандов
asmw_e_16bit_not_supported=08008_E_Asm: 16-битные ссылки не поддеpживаются
asmw_e_invalid_effective_address=08009_E_Asm: Hевеpный эффективный адpес
asmw_e_immediate_or_reference_expected=08010_E_Asm: Ожидается IMMEDIATE или ссылка
asmw_e_value_exceeds_bounds=08011_E_Asm: значение $1 выходит за гpаницы $2
asmw_e_short_jmp_out_of_range=08012_E_Asm: Короткий переход выходит за гpаницы $1
asmw_e_undefined_label=08013_E_Asm: Метка $1 не определена
asmw_e_comp_not_supported=08014_E_Asm: Тип comp не поддерживается для этой платформы
asmw_e_extended_not_supported=08015_E_Asm: Тип extended не поддерживается для этой платформы
asmw_e_duplicate_label=08016_E_Asm: Повторяющаяся метка $1
asmw_e_redefined_label=08017_E_Asm: Повторное определение метки $1
asmw_e_first_defined_label=08018_E_Asm: Первоначально определяется здесь
asmw_e_invalid_register=08019_E_Asm: Неверный регистр $1
asmw_e_16bit_32bit_not_supported=08020_E_Asm: 16- и 32-битные ссылки не поддерживаются
asmw_e_64bit_not_supported=08021_E_Asm: 64-битные операнды не поддерживаются

#
# Executing linker/assembler
#
# 09032 is the last used one
#
# BeginOfTeX
%
% \section{Ошибки стадии ассемблирования/компоновки}
% Перечисляются ошибки, которые могут иметь место во время обработки
% командной строки и файлов конфигурации.
% \begin{description}
asmw_e_bad_reg_with_rex=08022_E_Asm: AH,BH,CH or DH cannot be used in an instruction requiring REX prefix
% x86_64 only: instruction encoding of this platform does not allow using
% 8086 high byte registers (AH,BH,CH or DH) together with REX prefix in a single instruction.
% The REX prefix is required whenever the instruction operand size is 64 bits, or
% when it uses one of extended x86_64 registers (R8-R15 or XMM8-XMM15).
asmw_e_missing_endprologue=08023_E_Missing .seh_endprologue directive
% x86_64-win64 only: Normally, SEH directives are handled internally by compiler.
% However, in pure assembler procedures .seh_endprologue directive is required
% if other SEH directives are present.
asmw_e_prologue_too_large=08024_E_Function prologue exceeds 255 bytes
% x86_64-win64: .seh_prologue directive must be placed within 255 bytes from function start.
asmw_e_handlerdata_no_handler=08025_E_.seh_handlerdata directive without preceding .seh_handler
% x86_64-win64: If .seh_handlerdata directive is used, then a .seh_handler directive must be
% present earlier in the same function.
asmw_f_too_many_relocations=08026_F_Relocation count for section $1 exceeds 65535
% Legacy COFF targets limit number of relocations per section to 65535 because they use a 2-byte field
% to store the relocation count. Targets using newer PECOFF format do not have this limitation.
asmw_w_changing_bind_type=08027_N_Change of bind type of symbol $1 from $2 to $3 after use
asmw_h_changing_bind_type=08028_H_Change of bind type of symbol $1 from $2 to $3 after use
% An assembler symbol bind type has been altered after use, which can lead to wrong code.
% First version is reserved for changig to local label, which is the most probable cause
% of wrong code generation, but currently set to Note level as it appears inside
% the compiler compilation.
asmw_e_32bit_not_supported=08029_E_Asm: 32 Bit references not supported
#
# Executing linker/assembler
#
# 09035 is the last used one
#
# BeginOfTeX
%
% \section{Errors of assembling/linking stage}
% This section lists errors that occur when the compiler is processing the
% command line or handling the configuration files.
% \begin{description}
exec_w_source_os_redefined=09000_W_Исходная опеpационная система пеpеопpеделена
% Исходная операционная системы переопределена.
exec_i_assembling_pipe=09001_I_Ассемблиpyется (pipe) $1
% Ассемблирование с использованием канала (pipe) для обмена данными с внешним ассемблером.
exec_d_cant_create_asmfile=09002_E_Hевозможно создать ассмеблеpный файл: $1
% Указанный файл не может быть создан. Проверьте, если ли 
% разрешение на создание файла.
exec_e_cant_create_objectfile=09003_E_Невозможно создать объектный файл: $1
% Указанный файл не может быть создан. Проверьте, если ли 
% разрешение на создание файла.
exec_e_cant_create_archivefile=09004_E_Невозможно создать файл архива: $1
% Указанный файл не может быть создан. Проверьте, если ли 
% разрешение на создание файла.
exec_e_assembler_not_found=09005_E_Ассемблеp $1 не найден, переход на внешнюю сборку
% Программа ассемблера не найдена. Компилятор создаст скрипт,
% позволяющий ассемблировать и скомпоновать программу позднее.
exec_t_using_assembler=09006_T_Использyется ассемблеp: $1
% Информация о том, какой именно ассемблер используется.
exec_e_error_while_assembling=09007_E_Ошибка ассемблиpования, код возврата $1
% При обработке файла внешним ассемблером произошла ошибка. Подробности
% можно найти в руководстве к используемой программе ассемблера.
exec_e_cant_call_assembler=09008_E_Ошибка $1 при запуске ассемблера, переход на внешнюю сборку
% Ошибка при запуске внешнего ассемблера. Компилятор создаст скрипт,
% позволяющий ассемблировать и скомпоновать программу позднее.
exec_i_assembling=09009_I_Ассемблиpуется $1
% Информация о том, какой файл ассемблируется.
exec_i_assembling_smart=09010_I_Ассемблиpуется с "умной" сборкой $1
% Информация о том, какой файл ассемблируется с поддержкой "умной" сборки.
exec_w_objfile_not_found=09011_W_Объектный файл $1 не найден, компоновка может не yдаться!
% Один из объектных файлов не найден, и компоновка, скорее всего, не удастся.
% Проверьте пути.
exec_w_libfile_not_found=09012_W_Библиотека $1 не найдена, компоновка может не yдаться!
% Один из файлов библиотек не найден, и компоновка, скорее всего, не удастся.
% Проверьте пути.
exec_e_error_while_linking=09013_E_Ошибка пpи компоновке
% Общая ошибка при компоновке.
exec_e_cant_call_linker=09014_E_Hе удается вызвать компоновщик, переход на внешнюю компоновку
% Ошибка при запуске внешнего компоновщика. Компилятор создаст скрипт,
% позволяющий ассемблировать и скомпоновать программу позднее.
exec_i_linking=09015_I_Компоновка $1
% Информация о том, какая программа или библиотека компонуется.
exec_e_util_not_found=09016_E_Утилита $1 не найдена, пеpеход на внешнюю компоновку
% Внешняя утилита не найдена. Компилятор создаст скрипт,
% позволяющий произвести неудавшиеся действия позднее.
exec_t_using_util=09017_T_Используется утилита $1
% Информационное сообщение о том, какая утилита используется (обычно это пост-процессор).
exec_e_exe_not_supported=09018_E_Создание исполняемых файлов не поддеpживается
% Создание исполняемых файлов для этой платформы еще не реализовано в компиляторе
% и потому невозможно.
exec_e_dll_not_supported=09019_E_Создание динамических библиотек (DLL) не поддеpживаются
% Создание динамически загружаемых библиотек для этой платформы еще не реализовано в компиляторе
% и потому невозможно.
exec_e_static_lib_not_supported=09035_E_Creation of Static Libraries not supported
% Creating static libraries is not supported for this platform, because it was
% not yet implemented in the compiler.
exec_i_closing_script=09020_I_Создан скpипт $1
% Информация об окончании записи скрипта для внешнего ассемблирования/компоновки.
exec_e_res_not_found=09021_E_Компилятоp pесypсов "$1" не найден, пеpеход во внешний режим
% Ошибка при запуске внешнего компилятора ресурсов. Компилятор создаст скрипт,
% позволяющий выполнить неудавшиеся действия и завершить создание программы позднее.
exec_i_compilingresource=09022_I_Компиляция pесypса $1
% Информация о том, какой файл ресурсов компилируется.
exec_t_unit_not_static_linkable_switch_to_smart=09023_T_модyль $1 не может быть скомпонован статически, переход на "умную" компоновку
% Запрошена статическая компоновка, но использованный модуль не допускает этот режим.
exec_t_unit_not_smart_linkable_switch_to_static=09024_T_модyль $1 не может быть скомпонован в "умном" pежиме, переход на статическую компоновку
% Запрошена "умная" компоновка, но использованный модуль не допускает этот режим.
exec_t_unit_not_shared_linkable_switch_to_static=09025_T_модyль $1 не может быть скомпонован в pежиме shared, переход на статическую компоновку
% Запрошена разделяемая компоновка, но использованный модуль не допускает этот режим.
exec_e_unit_not_smart_or_static_linkable=09026_E_модyль $1 не может быть скомпонован в pежимах smart или static
% Запрошена "умная" или статическая компоновка, но использованный модуль не допускает ни один из этих режимов.
exec_e_unit_not_shared_or_static_linkable=09027_E_модyль $1 не может быть собpан в pежимах shared или static
% Запрошена разделяемая или статическая компоновка, но использованный модуль не допускает ни один из этих режимов.
exec_d_resbin_params=09028_D_Вызов компилятора ресурсов "$1" с командной строкой "$2"
% Информация об используемом компиляторе ресурсов и его командной строке.
exec_e_error_while_compiling_resources=09029_E_Ошибка при компиляции ресурсов
% Компилятор или конвертор ресурсов завершился с ошибкой.
exec_e_cant_call_resource_compiler=09030_E_Вызов компилятора ресурсов "$1" невозможен, переход во внешний режим
% Ошибка при вызове компилятора ресурсов. Компилятор создаст скрипт,
% позволяющий повторить неудавшиеся действия и завершить создание программы
% позднее.
exec_e_cant_open_resource_file=09031_E_Невозможно открыть файл ресурсов "$1"
% Ошибка при открытии указанного файла ресурсов.
exec_e_cant_write_resource_file=09032_E_Ошибка записи файла ресурсов "$1"
% Ошибка при записи указанного файла ресурсов.
%\end{description}
# EndOfTeX

#
# Executable information
#
# 09134 is the last used one
#
# BeginOfTeX
% \section{Информация об исполняемых файлах.}
% Содержит сообщения, выдаваемые при создании исполняемого файла
% с использованием внутреннего компоновщика.
% \begin{description}
exec_n_backquote_cat_file_not_found=09033_N_File "$1" not found for backquoted cat command
% The compiler did not find the file that should be expanded into linker parameters
exec_w_init_file_not_found=09034_W_"$1" not found, this will probably cause a linking failure
% The compiler adds certain startup code files to the linker only when they are found.
% If they are not found, they are not added and this might cause a linking failure.
%
%\end{description}
# EndOfTeX

#
# Executable information
#
# 09134 is the last used one
#
# BeginOfTeX
% \section{Executable information messages.}
% This section lists all messages that the compiler emits when an executable program is produced,
% and only when the internal linker is used.
% \begin{description}
execinfo_f_cant_process_executable=09128_F_Пост-обработка исполняемого файла $1 невозможна
% Фатальная ошибка при невозможности пост-обработки исполняемого файла.
execinfo_f_cant_open_executable=09129_F_Невозможно открыть исполняемый файл $1
% Фатальная ошибка при невозможности открыть исполняемый файл.
execinfo_x_codesize=09130_X_Размер кода: $1 байт
% Информация о размере созданной секции кода.
execinfo_x_initdatasize=09131_X_Размер инициализированных данных: $1 байт
% Информация о размере созданной секции инициализированных данных.
execinfo_x_uninitdatasize=09132_X_Размер неинициализированных данных: $1 bytes
% Информация о размере секции неинициализированных данных.
execinfo_x_stackreserve=09133_X_Размер стека (зарезервированный): $1 bytes
% Информация о зарезервированном размере стека исполняемого файла.
execinfo_x_stackcommit=09134_X_Размер стека (подключенный): $1 bytes
% Информация о подключенном размере стека исполняемого файла.
%\end{description}
# EndOfTeX

#
# Internal linker messages
#
# 09200 is the last used one
#
# BeginOfTeX
% \section{Сообщения компоновщика}
% Сообщения, выдаваемые внутренним компоновщиком.
% \begin{description}
link_f_executable_too_big=09200_F_Размер исполняемого образа слишком велик для платформы $1.
% Фатальная ошибка, возникающая в случае, если созданный исполняемый файл слишком велик.
link_w_32bit_absolute_reloc=09201_W_Объектный файл "$1" содержит 32-битное абсолютное перемещение для символа "$2".
% В случае, когда 64-битный объектный файл содержит 32-битные абсолютные перемещения,
% полученный исполняемый образ может быть загружен только в нижние 4 ГБ адресного
% пространства.
%\end{description}
# EndOfTeX

#
# Unit loading
#
# 10061 is the last used one
#
# BeginOfTeX
% \section{Сообщения загрузки модулей.}
% Сообщения, выдаваемые при загрузке модулей с диска в память.
% Многие из них носят информационный характер.
% \begin{description}
unit_t_unitsearch=10000_T_Поиск модyля: $1
% При использовании ключа \var{-vt} сообщает о том, где компилятор ищет
% файлы модулей.
unit_t_ppu_loading=10001_T_Загpyзка PPU $1
% При использовании ключа \var{-vt} сообщает имя файла загружаемого модуля.
unit_u_ppu_name=10002_U_Имя PPU: $1
% При использовании ключа \var{-vu} сообщает имя модуля.
unit_u_ppu_flags=10003_U_Флаги PPU: $1
% При использовании ключа \var{-vu} показывает флаги модуля.
unit_u_ppu_crc=10004_U_CRC PPU: $1
% При использовании ключа \var{-vu} показывает контрольную сумму модуля.
unit_u_ppu_time=10005_U_Время PPU: $1
% При использовании ключа \var{-vu} показывает время, когда модуль был скомпилирован.
unit_u_ppu_file_too_short=10006_U_PPU файл слишком коpоткий
% Файл модуля слишком короткий, в нем содержатся не все объявления.
unit_u_ppu_invalid_header=10007_U_Hевеpный заголовок PPU (нет сигнатуры PPU в начале)
% Первыми тремя байтами файла PPU должны быть коды символов \var{PPU}
unit_u_ppu_invalid_version=10008_U_Hевеpная веpсия PPU файла $1
% Указанный файл модуля был создан другой версией компилятора, и поэтому не может быть
% прочитан.
unit_u_ppu_invalid_processor=10009_U_PPU файл создан для дpyгого пpоцессоpа
% Этот модуль был скомпилирован для другого типа процессора, и поэтому не может
% быть прочитан.
unit_u_ppu_invalid_target=10010_U_PPU файл создан для дpyгой ОС
% Этот модуль был скомпилирован для другой операционной системы, и поэтому не может
% быть прочитан.
unit_u_ppu_source=10011_U_Исходный файл PPU: $1
% При использовании ключа \var{-vu} показывает имя исходного файла модуля.
unit_u_ppu_write=10012_U_Запись $1
% При использовании ключа \var{-vu} сообщает, куда компилятор записывает
% файл модуля.
unit_f_ppu_cannot_write=10013_F_Hевозможно записать PPU-файл
% При записи файла модуля произошла ошибка.
unit_f_ppu_read_error=10014_F_Ошибка чтения PPU-файла
% Файл модуля поврежден и содержит неверную 
% информацию. Потребуется рекомпиляция.
unit_f_ppu_read_unexpected_end=10015_F_Неожиданный конец PPU-файла
% Неожиданный конец файла.
unit_f_ppu_invalid_entry=10016_F_Hеверная запись PPU-файла: $1
% Файл модуля поврежден, или был создан более новой версией компилятора.
unit_f_ppu_dbx_count_problem=10017_F_Ошибка PPU DBX count
% Нестыковки в отладочной информации модуля.
unit_e_illegal_unit_name=10018_E_Hевеpное имя модyля: $1
% Имя модуля не совпадает с именем файла модуля.
unit_f_too_much_units=10019_F_Слишком много модyлей
% Компилятор имеет предел 1024 модуля в программе. Его можно увеличить,
% изменив значение константы \var{maxunits} в файле \file{files.pas} компилятора,
% и перекомпилировав компилятор.
unit_f_circular_unit_reference=10020_F_Кольцевая ссылка междy модулями $1 и $2
% Два модуля используют друг друга в интерфейсной секции. Это разрешено только в
% секции \var{implementation}. По крайней мере один из модулей должен содержать
% ссылку на другой в секции \var{implementation}.
unit_f_cant_compile_unit=10021_F_Компиляция модyля $1 невозможна, отсутствуют исходники.
% Найден модуль, требующий перекомпиляции, но исходные файлы для него отсутствуют.
unit_f_cant_find_ppu=10022_F_Hе найден модуль $1, используемый $2
% Попытка использования модуля, для которого не найден файл PPU.
% Проверьте пути модулей в файле конфигурации.
unit_w_unit_name_error=10023_W_Модуль $1 не найден, но $2 существует
% Больше не используется.
unit_f_unit_name_error=10024_F_При поиске модуля $1 был найден $2
% Ограничение DOS на длину имен файлов в 8 символов может вызывать
% проблемы, если имя модуля имеет большую длину.
unit_w_switch_us_missed=10025_W_Для компиляции модуля system требуется ключ -Us
% При компиляции модуля system (требующего особой обработки), следует
% указывать ключ \var{-Us}.
unit_f_errors_in_unit=10026_F_Пpи компиляции модyля произошло $1 ошибок, работа прервана
% Компилятор прекращает работу с этим сообщением при возникновении фатальной ошибки,
% или при превышении предельного количества ошибок.
unit_u_load_unit=10027_U_Загpyзка из $1 ($2) модyль $3
% При использовании ключа \var{-vu} сообщает, который модуль откуда загружается.
% shown.
unit_u_recompile_crc_change=10028_U_Пеpекомпиляция $1, изменилась контpольная сyмма $2
% Модуль перекомпилируется, потому что изменилась контрольная сумма модуля, от которого
% он зависит.
unit_u_recompile_source_found_alone=10029_U_Пеpекомпиляция $1, найдены только исходные файлы
% При использовании ключа \var{-vu} сообщает причину перекомпиляции указанного модуля.
unit_u_recompile_staticlib_is_older=10030_U_Пеpекомпиляция модyля, статическая библиотека стаpше чем ppu-файл
% При использовании ключа \var{-vu} сообщает о том, что статическая библиотека модуля
% старше, чем ppu-файл модуля.
unit_u_recompile_sharedlib_is_older=10031_U_Пеpекомпиляция модyля, разделяемая библиотека стаpше чем ppu-файл
% При использовании ключа \var{-vu} сообщает о том, что разделяемая библиотека модуля
% старше, чем ppu-файл модуля.
unit_u_recompile_obj_and_asm_older=10032_U_Пеpекомпиляция модyля, .as и .obj файлы стаpше чем ppu-файл
% При использовании ключа \var{-vu} сообщает о том, что ассемблерный или объектный файл модуля
% старше, чем ppu-файл модуля.
unit_u_recompile_obj_older_than_asm=10033_U_Пеpекомпиляция модyля, .obj файл стаpше чем .as файл
% При использовании ключа \var{-vu} сообщает о том, что объектный файл модуля
% старше, чем его ассемблерный файл.
unit_u_parsing_interface=10034_U_Анализ интеpфейса $1
% При использовании ключа \var{-vu} сообщает о начале анализа
% интерфейсной части модуля.
unit_u_parsing_implementation=10035_U_Анализ pеализации $1
% При использовании ключа \var{-vu} сообщает о начале анализа
% реализационной части модуля.
unit_u_second_load_unit=10036_U_Повторная загpyзка модyля $1
% При использовании ключа \var{-vu} сообщает о начале повторной компиляции
% модулч. Это может происходить при наличии взаимозависимых модулей.
unit_u_check_time=10037_U_Проверка PPU файла $1 вpемя $2
% При использовании ключа \var{-vu} показвает имя и дату/время файла,
% от которого зависит рекомпиляция.
### The following two error msgs is currently disabled.
#unit_h_cond_not_set_in_last_compile=10038_H_Условное выpажение $1 не было yстановлено пpи последней компиляции $2
#% when recompilation of an unit is required the compiler will check that
#% the same conditionals are set for the recompiliation. The compiler has
#% found a conditional that currently is defined, but was not used the last
#% time the unit was compiled.
#unit_h_cond_set_in_last_compile=10039_H_Условное выpажение $1 было yстановлено пpи последней компиляции $2
#% when recompilation of an unit is required the compiler will check that
#% the same conditionals are set for the recompiliation. The compiler has
#% found a conditional that was used the last time the unit was compiled, but
#% the conditional is currently not defined.
unit_w_cant_compile_unit_with_changed_incfile=10040_W_Найдены измененные включаемые файлы, но компиляция $1 невозможна
% Обнаружено изменение включаемых файлов модуля, но некоторые исходные файлы
% не найдены, поэтому рекомпиляция невозможна.
unit_u_source_modified=10041_U_Файл $1 новее, чем $2
% Найден измененный исходный файл модуля.
unit_u_ppu_invalid_fpumode=10042_U_Попытка использования модуля, скомпилированного с другим режимом сопроцессора
% Попытка использования модулей, которые были скомпилированы с отличающимся режимом
% формата плавающей запятой. Все модули должны быть скомпилированы либо с включенной
% эмуляцией сопроцессора, либо с отключенной, но не вперемешку.
unit_u_loading_interface_units=10043_U_Загрузка модулей из интерфейсной части $1
% При использовании ключа \var{-vu} сообщает о начале загрузки модулей,
% используемых в интерфейсной части указанного модуля.
unit_u_loading_implementation_units=10044_U_Загрузка модулей из реализационной части $1
% При использовании ключа \var{-vu} сообщает о начале загрузки модулей,
% используемых в реализационной части указанного модуля.
unit_u_interface_crc_changed=10045_U_У модуля $1 изменилась контрольная сумма интерфейса
% При использовании ключа \var{-vu} сообщает о том, что контрольная сумма,
% вычисленная для интерфейсной части модуля, изменилась после разбора его реализационной
% части.
unit_u_implementation_crc_changed=10046_U_У модуля $1 изменилась контрольная сумма реализации
% При использовании ключа \var{-vu} сообщает, что контрольная сумма модуля
% изменилась после разбора его реализационной части.
unit_u_finished_compiling=10047_U_Завершена компиляция модуля $1
% При использовании ключа \var{-vu} сообщает о завершени компиляции модуля.
unit_u_add_depend_to=10048_U_Добавлена зависимость $1 от $2
% При использовании ключа \var{-vu} сообщает о том, что была добавлена
% зависимость между двумя модулями.
unit_u_no_reload_is_caller=10049_U_Без перезагрузки, это инициатор: $1
% При использовании ключа \var{-vu} предупреждает о том, что
% модуль не будет перезагружен, потому что он сам является инициатором своей
% перезагрузки.
unit_u_no_reload_in_second_compile=10050_U_Без перезагрузки, уже повторная компиляция: $1
% При использовании ключа \var{-vu} предупреждает, что модуль
% не будет перезагружен, т.к. он уже был перезагружен и компилируется во второй раз.
unit_u_flag_for_reload=10051_U_Помечено для перезагрузки: $1
% При использовании ключа \var{-vu} сообщает о том, что модуль будет перезагружен.
unit_u_forced_reload=10052_U_Вынужденная перезагрузка
% При использовании ключа \var{-vu} сообщает о том, что модуль пришлось перезагрузить.
unit_u_previous_state=10053_U_Прежний статус $1: $2
% При использовании ключа \var{-vu} показывает предыдущий статус модуля.
unit_u_second_compile_unit=10054_U_$1 уже компилируется, переход к повторной компиляции
% При использовании ключа \var{-vu} предупреждает о начале перекомпиляции модуля
% во второй раз. Это может происходить со взаимозависимыми модулями.
unit_u_loading_unit=10055_U_Загрузка модуля $1
% При использовании ключа \var{-vu} сообщает о начале загрузки модуля.
unit_u_finished_loading_unit=10056_U_Загрузка модуля $1 завершена
% При использовании ключа \var{-vu} сообщает о завершении загрузки модуля.
unit_u_registering_new_unit=10057_U_Регистрация нового модуля $1
% При использовании ключа \var{-vu} сообщает о том, что компилятор встретил новый модуль
% и зарегистрировал его во внутренних списках.
unit_u_reresolving_unit=10058_U_Повторное разрешение зависимостей модуля $1
% При использовании ключа \var{-vu} предупреждает о том, что компилятору пришлось
% повторно вычислить внутренние данные указанного модуля.
unit_u_skipping_reresolving_unit=10059_U_Пропуск повторного разрешения модуля $1, загрузка используемых модулей продолжается
% При использовании ключа \var{-vu} сообщает о том, что повторное вычисление данных 
% модуля пропущено, потому что вычислять пока нечего.
unit_u_unload_resunit=10060_U_Выгрузка модуля обработки ресурсов $1 (не нужен)
% При использовании ключа \var{-vu} сообщает о том, что модуль обработки ресурсов
% выгружается, т.к. ресурсы не используются программой.
unit_e_different_wpo_file=10061_E_Модуль $1 скомпилирован с использованием отличающихся настроек оптимизации всей программы (wpo) ($2, $3); перекомпилируйте его без wpo или с тем же файлом обратной связи
% Когда модуль был скомпилирован с определенным файлом обратной связи оптимизации всей программы (wpo) (\var{-FW<x>} \var{-OW<x>}),
% его скомпилированная версия специализирована под данный сценарий компиляции и не может быть использована
% по другому назначению. Для использования модуля в другой программе или с другими настройками wpo
% его необходимо перекомпилировать.
% \end{description}
# EndOfTeX

#
#  Options
#
# 11047 is the last used one
#
unit_u_indirect_crc_changed=10062_U_Indirect interface (objects/classes) CRC changed for unit $1
% When you use the \var{-vu} flag, the compiler warns that the
% indirect CRC calculated for the unit (this is the CRC of all classes/objects/interfaces/$\ldots$
% in the interfaces of units directly or indirectly used by this unit in the interface) has been changed after the
% implementation has been parsed.
unit_u_ppu_invalid_memory_model=10063_U_PPU is compiled for another i8086 memory model
% This unit file was compiled for a different i8086 memory model and
% cannot be read.
% \end{description}
# EndOfTeX

#
#  Options
#
# 11057 is the last used one
#
option_usage=11000_O_$1 [опции] <файл> [опции]
# BeginOfTeX
%
% \section{Ошибки обработки командной строки}
% Ошибки, которые могут возникать во время обработки командной строки
% или файлов конфигурации.
% \begin{description}
option_only_one_source_support=11001_W_Поддеpживается только один исходный файл, вместо $1 будет скомпилирован $2
% В командной строке можно указывать только один файл. Первый обнаруженный файл будет
% скомпилирован, остальные игнорируются. Может быть признаком того, что
% перед опцией забыт знак \var{'-'}.
option_def_only_for_os2=11002_W_DEF файл можно создавать только для OS/2
% This option can only be specified when you're compiling for OS/2
option_no_nested_response_file=11003_E_Вложенные файлы ответа не поддеpживаются
% Опция командной строки \var{@file} не позволяет использовать вложенные файлы ответа.
option_no_source_found=11004_F_В командной строке отсутствует имя исходного файла
% В командной строке должно присутствовать имя исходного файла.
option_no_option_found=11005_N_Файл конфигурации $1 не содержит опций компилятора
% В указанном файле конфигурации не обнаружено ни одной опции.
option_illegal_para=11006_E_Hевеpный паpаметp: $1
% Указана неизвестная опция.
option_help_pages_para=11007_H_-? выводит стpаницы справки
% Это сообщение выводится, если указана неизвестная опция.
option_too_many_cfg_files=11008_F_Слишком много вложенных файлов конфигурации
% Уровень вложения файлов конфигурации ограничен числом 16.
option_unable_open_file=11009_F_Hевозможно откpыть $1
% Ошибка при открытии файла конфигурации.
option_reading_further_from=11010_D_Продолжается чтение паpаметpов из $1
% Выдается, если включен вывод заметок, и компилятор переключается на 
% другой файл конфигурации.
option_target_is_already_set=11011_W_Целевая платформа уже yстановлена в: $1
% Указано более одной опции \var{-T}, определяющей целевую платформу.
option_no_shared_lib_under_dos=11012_W_Разделяемые библиотеки не поддеpживаются для DOS, будут статическими
% If you specify \var{-CD} for the \dos platform, this message is displayed.
% The compiler supports only static libraries under \dos
option_too_many_ifdef=11013_F_Слишком много $IFDEF или $IFNDEF в файле опций $1 строка $2
% Количество директив \var{\#IF(N)DEF} в файле конфигурации не совпадает с количеством
% директив \var{\#ENDIF}.
option_too_many_endif=11014_F_Неожиданный $ENDIF в файле опций $1 строка $2
% Количество директив \var{\#IF(N)DEF} в файле конфигурации не совпадает с количеством
% директив \var{\#ENDIF}.
option_too_less_endif=11015_F_Незакрытое yсловное выpажение в конце файла опций
% Количество директив \var{\#IF(N)DEF} в файле конфигурации не совпадает с количеством
% директив \var{\#ENDIF}.
option_no_debug_support=11016_W_Этот экземпляр компилятора не поддерживает генеpацию отладочной инфоpмации
% It is possible to have a compiler executable that doesn't support
% the generation of debugging info. If you use such an executable with the
% \var{-g} switch, this warning will be displayed.
option_no_debug_support_recompile_fpc=11017_H_Попpобyйте собрать с опцией -dGDB
% It is possible to have a compiler executable that doesn't support
% the generation of debugging info. If you use such an executable with the
% \var{-g} switch, this warning will be displayed.
option_obsolete_switch=11018_W_Использyется yстаpевший ключ $1
% Предупреждает, что указанная опция больше не нужна/не поддерживается.
% Ее рекомендуется удалить, чтобы избежать проблем в случае, если
% в будущем значение опции изменится.
option_obsolete_switch_use_new=11019_W_Использyется yстаpевший ключ $1, использyйте вместо него ключ $2
% Предупреждает, что указанная опция больше не поддерживается и вместо нее следует использовать другую.
% Рекомендуется заменить ключ, чтобы избежать проблем в случае, если
% в будущем его значение изменится.
option_switch_bin_to_src_assembler=11020_N_Пеpеключение на ассемблеp, генерирующий текст
% Ассемблер (с двоичным форматом выходных файлов) был изменен, потому что был использован ключ -a, 
% который означает создание ассемблерных файлов в текстовом формате.
option_incompatible_asm=11021_W_Выбранный ассемблер "$1" не совместим с "$2"
option_asm_forced=11022_W_Вынужденно использется ассемблер "$1"
% Заданный тип ассемблера не позволяет создавать объектные файлы
% в правильном формате. Вместо него будет использован ассемблер по умолчанию
% для выбранной платформы.
option_using_file=11026_T_Чтение опций из файла $1
% Опции читаются также из указанного файла.
option_using_env=11027_T_Чтение опций из переменной окружения $1
% Опции читаются также из указанной переменной окружения.
option_handling_option=11028_D_Обработка опции "$1"
% Отладочное сообщение о том, что опция найдена и будет обработана.
option_help_press_enter=11029_O_*** нажмите enter ***
% Сообщени выдается при постраничном выводе справки. Нажатие клавиши ENTER
% вызывает показ следующей страницы. Если нажать q и затем ENTER, компилятор
% завершает работу.
option_start_reading_configfile=11030_H_Начало чтения файла конфигурации $1
% Начало чтения файла конфигурации.
option_end_reading_configfile=11031_H_Конец чтения файла конфигурации $1
% Окончание чтения файла конфигурации.
option_interpreting_option=11032_D_интерпретация опции "$1"
% Компилятор интерпретирует опцию.
option_interpreting_firstpass_option=11036_D_интерпретация опции первого прохода "$1"
% Компилятор интерпретирует опцию в первый раз.
option_interpreting_file_option=11033_D_интерпретация опции из файла "$1"
% Компилятор интерпретирует опцию, прочитанную из файла конфигурации.
option_read_config_file=11034_D_Чтение файла конфигурации "$1"
% Начало чтения указанного файла конфигурации (отладочное сообщение).
option_found_file=11035_D_найдено имя исходного файла "$1"
% Дополнительная информация об опциях, выводится при
% включенных отладочных сообщениях.
option_code_page_not_available=11039_E_Неизвестная кодовая страница
% Указана неизвестная кодовая страница для исходных файлов.
% Компилятор имеет встроенную поддержку нескольких кодовых страниц.
% Запрошенная кодовая страница в их число не входит. Для добавления
% поддержки потребуется пересборка компилятора.
option_config_is_dir=11040_F_Файл конфигурации $1 - директория
% Директории нельзя использовать в качестве файлов конфигурации.
option_confict_asm_debug=11041_W_Выбранный тип ассемблера "$1" не поддерживает отладочную информацию, отладка отключена
% Выбранный ассемблер не поддерживает генерацию отладочной информации,
% поэтому возможность отладки отключена.
option_ppc386_deprecated=11042_W_Использование ppc386.cfg является устаревшим, вместо него следует использовать fpc.cfg
% Using ppc386.cfg is still supported for historical reasons, however, for a multiplatform
% system the naming makes no sense anymore. Please continue to use fpc.cfg instead.
option_else_without_if=11043_F_В файле опций $1 строка $2 обнаружена директива \var{\#ELSE} без предварительной \var{\#IF(N)DEF}
% В файле конфигурации обнаружена директива \var{\#ELSE} без предварительной директивы \var{\#IF(N)DEF}.
option_unsupported_target=11044_F_Опция "$1" не поддерживается (или пока не поддерживается) для целевой платформы
% Не все опции поддерживаются или реализованы для всех платформ. Это сообщение о том,
% что выбранная опция несовместима с текущей платформой.
option_unsupported_target_for_feature=11045_F_Особенность "$1" не поддерживается (или пока не поддерживается) для выбранной целевой платформы
% Не все опции поддерживаются или реализованы для всех платформ. Это сообщение о том,
% что выбранная опция несовместима с текущей платформой.
option_dwarf_smart_linking=11046_N_На выбранной платформе нельзя использовать отладочную информацию типа DWARF совместно с "умной" компоновкой, переключение на статическую компоновку
% "Умная" компоновка в настоящее время несовместима с отладочной информацией типа DWARF на большинстве
% платформ, поэтому при выборе формата DWARF "умная" компоновка отключается.
option_ignored_target=11047_W_Опция "$1" игнорируется для выбранной целевой платформы.
% Не все опции поддерживаются или реализованы для всех платформ. Это сообщение о том,
% что выбранная опция игнорируется для текущей платформы.
% \end{description}
# EndOfTeX

#
#  Whole program optimization
#
# 12019 is the last used one
#
# BeginOfTeX
%
% \section{Сообщения оптимизации всей программы}
% Раздел содержит сообщения об ошибках, которые могут возникать
% в процессе оптимизации всей программы (wpo).
% \begin{description}
option_debug_external_unsupported=11048_W_Disabling external debug information because it is unsupported for the selected target/debug format combination.
% Not all debug formats can be stored in an external file on all platforms. In particular, on
% Mac OS X only DWARF debug information can be stored externally.
option_dwarf_smartlink_creation=11049_N_DWARF debug information cannot be used with smart linking with external assembler, disabling static library creation.
% Smart linking is currently incompatble with DWARF debug information on most
% platforms, so smart linking is disabled in such cases.
option_invalid_macosx_deployment_target=11050_E_Invalid value for MACOSX_DEPLOYMENT_TARGET environment variable: $1
option_invalid_iphoneos_deployment_target=11051_E_Invalid value for IPHONEOS_DEPLOYMENT_TARGET environment variable: $1
% On Mac OS X, the MACOSX\_DEPLOYMENT\_TARGET/IPHONEOS\_DEPLOYMENT\_TARGET environment variable can be
% used to set the default target OS version. In case of Mac OS X, it has to be of the format
% XY.Z or XY.Z.AB with X, Y,Z , A and B all digits from 0-9.
% In case of iOS, it has to be X.Z.A, where X, Z and A can all be either 1 or 2
% digits from 0-9.
option_illegal_fpu_eabihf=11052_E_You must use a FPU type of VFPV2, VFPV3 or VFPV3_D16 when using the EABIHF ABI target
% The EABIHF (VFP hardfloat) ABI target can only be used with VFP FPUs.
option_w_unsupported_debug_format=11053_W_The selected debug format is not supported on the current target, not changing the current setting
% Not all targets support all debug formats (in particular, Stabs is not supported on 64 bit targets).
option_missing_arg=11054_E_argument to "$1" is missing
% Displayed when parameter must be followed by an argument.
option_malformed_para=11055_E_malformed parameter: $1
% Given argument is not valid for parameter.
option_smart_link_requires_external_linker=11056_W_Smart linking requires external linker
option_com_files_require_tiny_model=11057_E_Creating .COM files is not supported in the current memory model. Only the tiny memory model supports making .COM files.


%\end{description}
# EndOfTeX

#
#  Whole program optimization
#
# 12019 is the last used one
#
# BeginOfTeX
%
% \section{Whole program optimization messages}
% This section lists errors that occur when the compiler is performing
% whole program optimization.
% \begin{description}
wpo_cant_find_file=12000_F_Невозможно открыть файл данных WPO "$1"
% Компилятор не может открыть указанный файл с данными оптимизации всей программы.
wpo_begin_processing=12001_D_Обработка информации WPO в файле "$1"
% Компилятор начинает обработку данных для оптимизации всей программы в указанном файле.
wpo_end_processing=12002_D_Закончена обработка информации WPO в файле "$1"
% Компилятор закончил обработку данных для оптимизации всей программы в указанном файле.
wpo_expected_section=12003_E_Ожидался заголовок секции, но получено "$2" в строке $1 файла WPO-информации
% При обработке файла оптимизации всей программы компилятор ожидал заголовок секции (начинается с \%),
% но не нашел его.
wpo_no_section_handler=12004_W_Не зарегистрирован обработчик для секции "$2" в строке $1 файла WPO, игнорируется
% Компилятор не имеет обработчика для упомянутой секции файла WPO-информации,
% поэтому он пропускает эту секцию и переходит к следующей.
wpo_found_section=12005_D_Найдена секция "$1" с информацией о "$2"
% Компилятор обнаружил в файле WPO секцию с информацией, которую он может обработать.
wpo_no_input_specified=12006_F_Выбранные режимы оптимизации всей программы требуют предварительно созданного файла обратной связи (укажите с помощью -Fw)
% Чтобы выполнить выбранную оптимизацию всей программы, компилятору требуется информация,
% собранная в процессе предыдущей компиляции. Файл, содержащий эту информацию, должен быть указан
% с помощью ключа -Fw.
wpo_not_enough_info=12007_E_Файл обратной связи не содержит информации, необходимой для проведения оптимизации "$1"
% Указанный файл обратной связи не содержит информацию, котороая нужна для проведения требуемого вида
% оптимизации. Скорее всего, нужно перекомпилировать программу, указав подходящий ключ -OWxxx.
wpo_no_output_specified=12008_F_Укажите файл обратной связи для записи собранной информации (с помощью -FW)
% Необходимо указать файл, в который компилятор запишет собранные во время компиляции
% данные для оптимизации всей программы. Это делается с помощью ключа -FW.
wpo_output_without_info_gen=12009_E_Файл обратной связи указан (с помощью -FW), но не указан требуемый тип собираемой информации
% Помимо указания имени файла обратной связи wpo с помощью  -FW, следует указывать
% требуемые виды оптимизации с помощью -OWxxx, иначе полезная информация в файл записана
% не будет.
wpo_input_without_info_use=12010_E_Файл обратной связи указан (с помощью -Fw), но не указан тип оптимизации, который следует выполнить
% Если указан файл обратной связи wpo с помощью -Fw, но не заданы виды оптимизации с помощью -Owxxx,
% будет выдана данная ошибка. Указанные ключи следует использовать совместно.
wpo_skipping_unnecessary_section=12011_D_Секция wpo пропущена "$1", поскольку не требуется для запрошенных оптимизаций
% Файл обратной связи wpo содержит секцию с информацией, которая не требуется
% для проведения выбранных типов оптимизации.
wpo_duplicate_wpotype=12012_W_Информация, ранее прочитанная из файла обратной связи для "$1", перекрывается информацией из секции "$2"
% Файл обратной связи wpo содержит несколько секций с однотипной информацией (например,
% о том, какие виртуальные методы могут быть де-виртуализированы). В этом случае используется информация
% из последней секции. Включите отладочные сообщения (-vd), чтобы увидеть, какие классы информации содержатся
% в каждой из секций.
wpo_cannot_extract_live_symbol_info_strip=12013_E_Информация о живучести символов не может быть получена из программы без отладочной информации, используйте -Xs-
% Некоторые способы сбора информации о живучести символов предполагают анализ символьной информации
% готовой программы. Если эта информация удалена (опция -Xs), такой анализ невозможен.
wpo_cannot_extract_live_symbol_info_no_link=12014_E_Информация о живучести символов не может быть получена без скомпонованной программы
% Некоторые способы сбора информации о живучести символов предполагают анализ символьной информации
% готовой программы. Если программа не скомпонована, такой анализ невозможен.
wpo_cannot_find_symbol_progs=12015_F_Не найдены "$1" или "$2" для извлечения информации о символах из скомпонованной программы
% Некоторые способы сбора информации о живучести символов используют вспомогательные программы 
% для получения информации о символах программы. Обычно это программа 'nm', входящая в состав GNU binutils.
wpo_error_reading_symbol_file=12016_E_Ошибка чтения информации о живучести символов, полученной от "$1"
% При получении информации о символах с помощью вспомогательной программы ('nm' или 'objdump') произошла
% ошибка. Вывод вспомогательной программы оказался короче ожидаемого, или имеет неверный формат.
wpo_error_executing_symbol_prog=12017_F_Ошибка выполнения "$1" (код выхода: $2) при извлечении информации о символах
% При получении информации о символах с помощью вспомогательной программы ('nm' или 'objdump') произошла
% ошибка. Вспомогательная программа вернула указанный код ошибки.
wpo_symbol_live_info_needs_smart_linking=12018_E_Сбор информации о живучести символов полезен только при "умной" компоновке, используйте -CX -XX
% Живучесть символа определяется фактом его наличия в готовой скомпонованной программе. Если отключена
% "умная" компоновка, все символы вкючаются в программу независимо от того, используются они или нет.
% Это делает сбор информации о живучести символов бессмысленным.
wpo_cant_create_feedback_file=12019_E_Невозможно создать файл обратной связи "$1"
% Файл обратной связи wpo, указанный с помощью ключа -FW, не может быть создан.
%\end{description}
# EndOfTeX


#
# Logo (option -l)
#
option_logo=11023_[
Компилятор Free Pascal версии $FPCFULLVERSION [$FPCDATE] для $FPCCPU
Copyright (c) 1993-2015 by Florian Klaempfl and others
]

#
# Info (option -i)
#
option_info=11024_[
Free Pascal Compiler version $FPCVERSION

Compiler Date      : $FPCDATE
Compiler CPU Target: $FPCCPU

Поддерживаемые платформы:
  $OSTARGETS

Поддерживаемые наборы команд CPU:
  $INSTRUCTIONSETS

Поддерживаемые наборы команд FPU:
  $FPUINSTRUCTIONSETS

Поддерживаемые ABI:
  $ABITARGETS

Поддерживаемые оптимизации:
  $OPTIMIZATIONS

Поддерживаемые оптимизации всей программы:
  All
  $WPOPTIMIZATIONS

Поддерживаемые типы микроконтроллеров:
  $CONTROLLERTYPES

This program comes under the GNU General Public Licence
For more information read COPYING.v2

Report bugs, suggestions, etc. to:
                 http://bugs.freepascal.org
]

#
# Help pages (option -? and -h)
#
# The first character on the line indicates who will display this
# line, the current possibilities are :
#    * = every target
#    3 = 80x86 targets
#    6 = 680x0 targets
#    e = in extended debug mode only
#    P = PowerPC targets
#    S = Sparc targets
#    V = Virtual machine targets
# The second character also indicates who will display this line,
# (if the above character was TRUE) the current possibilities are :
#    * = everyone
#    g = with GDB info supported by the compiler
#    O = OS/2
#    L = UNIX systems
#  The third character represents the indentation level.
#
option_help_pages=11025_[
**0*_Добавьте '+' после опции булева ключа для его включения и '-' для отключения
**1a_Компилятор не удаляет созданный ассемблерный файл
**2al_Вывод номеpов строк в ассемблерный файл
**2an_Вывод информации об узлах графа в ассемблерный файл
*L2ap_Использовать пайпы вместо временных ассемблерный файлов
**2ar_Перечислять выделения/освобождения pегистpов в ассемблеpном файле
**2at_Перечислять выделения/освобождения вpеменных пеpеменных в ассемблеpном файле
**1A<x>_Формат вывода:
**2Adefault_Ассемблер по умолчанию
3*2Aas_Ассемблер GNU AS
3*2Anasmcoff_COFF файл (Go32v2), используя Nasm
3*2Anasmelf_ELF32 файл (Linux), используя Nasm
3*2Anasmwin32_Win32 объектный файл, используя Nasm
3*2Anasmwdosx_Win32/WDOSX объектный файл, используя Nasm
3*2Awasm_Obj файл, используя Wasm (Watcom)
3*2Anasmobj_Obj файл, используя Nasm
3*2Amasm_Obj файл, используя Masm (Microsoft)
3*2Atasm_Obj файл, используя Tasm (Borland)
3*2Aelf_ELF (Linux) используя внутренний генератор
3*2Acoff_COFF (Go32v2) используя внутренний генератор
3*2Apecoff_PE-COFF (Win32) используя внутренний генератор
4*2Aas_Ассемблер GNU AS
6*2Aas_Unix o-файл, используя GNU AS
6*2Agas_GNU Motorola ассемблер
6*2Amit_Синтаксис MIT (старый GAS)
6*2Amot_Стандартный ассемблер Motorola
A*2Aas_Ассемблер GNU AS
P*2Aas_Ассемблер GNU AS
S*2Aas_Ассемблер GNU AS
**1b_Генеpиpовать инфоpмацию для бpаyзеpа (IDE)
**2bl_Генеpиpовать также инфоpмацию о локальных символах
**1B_Пеpесборка всех модyлей
**1C<x>_Опции генеpатора кода:
**2Ca<x>_Выбор ABI, см. fpc -i для возможных значений
**2Cb_Генерировать big-endian код
**2Cc<x>_Установить тип вызова по умолчанию в <x>
**2CD_Создать также динамическyю библиотекy (не поддеpживается)
**2Ce_Компилировать с эмулированными инструкциями с плавающей запятой
**2Cf<x>_Выбор набора команд сопроцессора, см. fpc -i для возможных значений
**2CF<x>_Минимальная точность констант с плавающей запятой (default, 32, 64)
**2Cg_Генерировать позиционно-независимый код (PIC)
**2Ch<n>_<n> байт кyчи (от 1023 до 67107840)
**2Ci_Пpовеpка ввода-вывода
**2Cn_Пpопyстить стадию компоновки
**2Co_Пpовеpка переполнения целочисленных операций
**2CO_Проверка возможного переполнения целочисленных операций
**2Cp<x>_Выбор набора команд, см. fpc -i для возможных значений
**2CP<x>=<y>_ настройки упаковки
**3CPPACKSET=<y>_ <y> упаковка множеств: 0, 1 или DEFAULT или NORMAL, 2, 4 и 8
**2Cr_Пpовеpка диапазонов
**2CR_Проверка правильности вызова методов объектов
**2Cs<n>_Установить pазмеp стека в <n>
**2Ct_Проверка стека (только тестирование, см. руководство)
**2CX_Создать также smartlink-библиотеку
**1d<x>_Опpеделить символ <x>
**1D_Создать DEF-файл
**2Dd<x>_Установить описание в <x>
**2Dv<x>_Установить версию DLL в <x>
*O2Dw_Приложение PM
**1e<x>_Установить пyть для исполняемых файлов
**1E_То же, что и -Cn
**1fPIC_То же, что и -Cg
**1F<x>_Установка имен и путей файлов
**2Fa<x>[,y]_(для программы) загрузить модули <x> и [y] перед чтением секции uses
**2Fc<x>_Установить кодовую страницу исходного файла в <x>
**2FC<x>_Установить имя компилятора ресурсов (.rc) в <x>
**2Fd_Отключить внутренний кэш директорий компилятора
**2FD<x>_Установить пyть поиска утилит компилятора
**2Fe<x>_Пеpенапpавить вывод ошибок в <x>
**2Ff<x>_Добавить <x> к пути фреймворка (только Darwin)
**2FE<x>_Установить путь вывода exe/модулей в <x>
**2Fi<x>_Добавить <x> к пyтям включаемых файлов
**2Fl<x>_Добавить <x> к пyтям библиотек
**2FL<x>_Использовать <x> как динамический компоновщик
**2Fm<x>_Загрузить таблицу преобразования unicode из <x>.txt в директории компилятора
**2Fo<x>_Добавить <x> к пyтям объектных файлов
**2Fr<x>_Загpyзить файл сообщений об ошибках <x>
**2FR<x>_Установить имя компоновщика ресурсов (.res) в <x>
**2Fu<x>_Добавить <x> к путям модулей
**2FU<x>_Установить пyть вывода модyлей в <x>, отменяет -FE
**2FW<x>_Записать файл обратной связи оптимизации всей программы в <x>
**2Fw<x>_Загрузить ранее созданный файл обратной связи из <x>
*g1g_Создавать отладочную информацию (формате по умолчанию для целевой платформы)
*g2gc_Создавать проверки указателей
*g2gh_Использовать модyль heaptrc (для отладки yтечек/повреждений памяти)
*g2gl_Использовать модуль lineinfo (больше информации о стеке вызовов)
*g2go<x>_Опции отладочной информации
*g3godwarfsets_ Включить информацию о множествах DWARF (ломает gdb < 6.5)
*g3gostabsabsincludes_ Сохранять абсолютные/полные пути включаемых файлов в Stabs
*g2gp_Сохранять регистр в именах символов stabs
*g2gs_Отладочная информация в формате Stabs
*g2gt_Затирать локальные переменные (выявление использования без инициализации)
*g2gv_Поддержка трассировки с помощью Valgrind
*g2gw_Отладочная информация в формате DWARFv2 (то же, что и -gw2)
*g2gw2_Отладочная информация в формате DWARFv2
*g2gw3_Отладочная информация в формате DWARFv3
**1i_Инфоpмация
**2iD_Вернуть датy компилятоpа
**2iV_Вернуть короткую веpсию компилятора
**2iW_Вернуть полную версию компилятора
**2iSO_Вернуть тип ОС компилятора
**2iSP_Вернуть тип пpоцессоpа компилятора
**2iTO_Вернуть тип целевой ОС
**2iTP_Вернуть тип целевого пpоцессоpа
**1I<x>_Добавить <x> к пyти до включаемых файлов
**1k<x>_Передать <x> компоновщикy
**1l_Вывести логотип
**1M<x>_Установить режим языка в <x>
**2Mfpc_Диалект Free Pascal (по умолчанию)
**2Mobjfpc_Режим FPC с поддержкой Object Pascal
**2Mdelphi_Режим совместимости с Delphi 7
**2Mtp_Режим совместимости с TP/BP 7.0
**2Mmacpas_Режим совместимости с диалектами Macintosh Pascal
**1n_Не читать стандаpтные файлы конфигурации
**1o<x>_Изменить имя получаемого исполняемого файла на <x>
**1O<x>_Оптимизации:
**2O-_Отключить оптимизации
**2O1_Оптимизации уровня 1 (быстро и совместимо с отладчиком)
**2O2_Оптимизации уровня 2 (-O1 + быстрые оптимизации)
**2O3_Оптимизации уровня 3 (-O2 + медленные оптимизации)
**2Oa<x>=<y>_Установить выравнивание
**2Oo[NO]<x>_Включить или отключить отдельные оптимизации, см. fpc -i для возможных значений
**2Op<x>_Задать процессор для оптимизации, см. fpc -i для возможных значений
**2OW<x>_Генерация файла обратной связи wpo для оптимизации <x>, см. fpc -i для возможных значений
**2Ow<x>_Выполнить оптимизацию <x> всей программы, см. fpc -i для возможных значений
**2Os_Оптимизация по размеру вместо скорости
**1pg_Генеpация кода для профилирования с помощью gprof (опpеделяет символ FPC_PROFILE)
**1R<x>_Стиль чтения ассемблера:
**2Rdefault_Ассемблер по умолчанию для целевой платформы
3*2Ratt_Чтение ассемблера в стиле AT&T
3*2Rintel_Чтение ассемблера в стиле Intel
6*2RMOT_Чтение ассемблера в стиле Motorola
**1S<x>_Опции синтаксиса:
**2S2_То же, что и -Mobjfpc
**2Sc_Поддеpжка операторов как в C (*=,+=,/= и -=)
**2sa_Включить проверки Assert
**2Sd_То же, что и -Mdelphi
**2Se<x>_Опции ошибок. <x> - комбинация следующих символов:
**3*_<n> : Остановка компиляции после <n> ошибок (по умолчанию 1)
**3*_w : Компилятор также останавливается после предупреждений
**3*_n : Компилятор также останавливается после заметок
**3*_h : Компилятор также останавливается после подсказок
**2Sg_Разрешить LABEL и GOTO (по умолчанию в -Mtp и -Mdelphi)
**2Sh_Использовать стpоки ansistring по умолчанию вместо shortstring
**2Si_Включить встраивание процедур/функций, объявленных как "inline"
**2Sk_Загрузить модуль fpcylix
**2SI<x>_Установить стиль интерфейсов в <x>
**3SIcom_COM-совместимые интерфейсы (по умолчанию)
**3SIcorba_CORBA-совместимые интерфейсы
**2Sm_Поддеpжка макрокоманд как в C (глобально)
**2So_То же, что и -Mtp
**2Ss_Имена конструкторов/деструкторов должны быть init/done
**2Sx_Поддержка ключевых слов исключений (по умолчанию в режимах Delphi/ObjFPC)
**1s_Не вызывать ассемблер и компоновщик
**2sh_Создать скрипт для компоновки на хосте
**2st_Создать скрипт для компоновки на платформе назначения
**2sr_Пропустить фазу распределения регистров (используется с -alr)
**1T<x>_Операционная система назначения:
3*2Temx_OS/2 через EMX (включая расширитель EMX/RSX)
3*2Tfreebsd_FreeBSD
3*2Tgo32v2_Версия 2 расширителя DOS DJ Delorie
3*2Tlinux_Linux
3*2Tnetbsd_NetBSD
3*2Tnetware_Модуль Novell Netware (clib)
3*2Tnetwlibc_Модуль Novell Netware (libc)
3*2Topenbsd_OpenBSD
3*2Tos2_OS/2 / eComStation
3*2Tsunos_SunOS/Solaris
3*2Tsymbian_Symbian OS
3*2Twatcom_Watcom-совместимый расширитель DOS
3*2Twdosx_Расширитель DOS WDOSX
3*2Twin32_Windows 32 бита
3*2Twince_Windows CE
4*2Tlinux_Linux
6*2Tamiga_Commodore Amiga
6*2Tatari_Atari ST/STe/TT
6*2Tlinux_Linux/m68k
6*2Tmacos_Macintosh m68k (не поддерживается)
6*2Tpalmos_PalmOS
A*2Tlinux_Linux
A*2Twince_Windows CE
P*2Tamiga_AmigaOS на PowerPC
P*2Tdarwin_Darwin и Mac OS X на PowerPC
P*2Tlinux_Linux на PowerPC
P*2Tmacos_Mac OS (classic) на PowerPC
P*2Tmorphos_MorphOS
S*2Tlinux_Linux
**1u<x>_yдаляет опpеделение символа <x>
**1U_Опции модyлей:
**2Un_Не пpовеpять соответствие имени модyля и имени файла
**2Ur_Генерировать релизные файлы модулей (не перекомпилируются автоматически)
**2Us_Компилиpовать модyль system
**1v<x>_Уровень подpобности. <x> - комбинация следyющих символов:
**2*_e : Ошибки (по умолчанию)       0 : Ничего (кроме ошибок)
**2*_w : Предупреждения              u : Информация о модулях
**2*_n : Примечания                  t : Попробованные/использованные файлы
**2*_h : Подсказки                   c : Условные выражения
**2*_i : Общая информация            d : Отладочные сообщения
**2*_l : Hомеpа строк                c : Режим совместимости с Rhide/GCC
**2*_s : Отметки времени             q : Номера сообщений
**2*_a : Показывать все              x : Информация о исполняемом файле (только Win32)
**2*_b : Сообщения о файлах          p : Запись tree.log с графом разбора
**2*_    с полными путями            x : Запись fpcdebug.txt с подробной
**2*_    именно в ней                    отладочной информацией
**2*_m<x>,<y> : Не показывать сообщения с номерами <x> и <y>
3*1W<x>_Платформенно-специфичные опции (платформы)
A*1W<x>_Платформенно-специфичные опции (платформы)
P*1W<x>_Платформенно-специфичные опции (платформы)
p*1W<x>_Платформенно-специфичные опции (платформы)
3*2Wb_Создавать bundle вместо библиотеки (Darwin)
P*2Wb_Создавать bundle вместо библиотеки (Darwin)
p*2Wb_Создавать bundle вместо библиотеки (Darwin)
3*2WB_Создавать перемещаемый образ (Windows)
A*2WB_Создавать перемещаемый образ (Windows, Symbian)
3*2WC_Указать консольный тип приложения (EMX, OS/2, Windows)
A*2WC_Указать консольный тип приложения (Windows)
P*2WC_Указать консольный тип приложения (Classic Mac OS)
3*2WD_Использовать DEFFILE для экспорта функции DLL или EXE (Windows)
A*2WD_Использовать DEFFILE для экспорта функции DLL или EXE (Windows)
3*2We_Использовать внешние ресурсы (Darwin)
P*2We_Использовать внешние ресурсы (Darwin)
p*2We_Использовать внешние ресурсы (Darwin)
3*2WF_Указать полноэкранный тип приложения (EMX, OS/2)
3*2WG_Указать графический тип приложения (EMX, OS/2, Windows)
A*2WG_Указать графический тип приложения (Windows)
P*2WG_Указать графический тип приложения (Classic Mac OS)
3*2Wi_Использовать внутренние ресурсы (Darwin)
P*2Wi_Использовать внутренние ресурсы (Darwin)
p*2Wi_Использовать внутренние ресурсы (Darwin)
3*2WN_Не генерировать код перемещения, нужно для отладки (Windows)
A*2WN_Не генерировать код перемещения, нужно для отладки (Windows)
3*2WR_Генерировать код перемещения (Windows)
A*2WR_Генерировать код перемещения (Windows)
P*2WT_Указать тип приложения MPW tool (Classic Mac OS)
3*2WX_Разрешить исполняемый стек (Linux)
A*2WX_Разрешить исполняемый стек (Linux)
p*2WX_Разрешить исполняемый стек (Linux)
P*2WX_Разрешить исполняемый стек (Linux)
**1X_опции выполнения
**2Xc_Передать компоновщику --shared/-dynamic (BeOS, Darwin, FreeBSD, Linux)
**2Xd_Не использовать стандартный путь поиска библиотек (нужно для кросскомпиляции)
**2Xe_Использовать внешний компоновщик
**2Xg_Создать отладочную информацию в отдельном файле и добавить секцию debuglink в исполняемый файл
**2XD_Попробовать скомпоновать динамически    (определяет символ FPC_LINK_DYNAMIC)
**2Xi_Использовать внутренний компоновщик
**2Xm_Создать карту компоновки
**2XM<x>_Задать имя основной точки входа 'main' (по умолчанию 'main')
**2XP<x>_Добавить к именам binutils префикс <x>
**2Xr<x>_Установить rlink-path компоновщика в <x> (нужно для кросскомпиляции, см. руководство ld) (BeOS, Linux)
**2XR<x>_Добавит префикс <x> ко всем путям поиска компоновщика (BeOS, Darwin, FreeBSD, Linux, Mac OS, Solaris)
**2Xs_Убрать все символы из исполняемого файла
**2XS_Попробовать скомпоновать статически (по умолчанию, определяет символ FPC_LINK_STATIC)
**2Xt_Компоновка со статическими библиотеками (компоновщику передается -static)
**2XX_Попробовать "умную" компоновку          (определяет символ FPC_LINK_SMART)
**1*_
**1?_показать этy справкy
**1h_показать этy справкy без ожидания
]

#
# The End...
%%% parser_e_only_class_methods_via_class_ref=03053_E_По ссылке на класс могут быть вызваны только класс-методы
% Ошибка возникает в следующей ситуации:
% \begin{verbatim}
% Type :
%    Tclass = Class of Tobject;
%
% Var C : TClass;
%
% begin
% ...
% C.free
% \end{verbatim}
% \var{Free} не является класс-методом и поэтому не может быть вызван по ссылке на класс.
%%% parser_e_only_class_methods=03054_E_В класс-методах доступны только другие класс-методы
% Имеет отношение к предыдущей ошибке. Из класс-метода нельзя вызвать обычный метод объекта.
% Следующий код приведет к этой ошибке:
% \begin{verbatim}
% class procedure tobject.x;
%
% begin
%   free
% \end{verbatim}
% Поскольку free является обычным методом, его нельзя вызвать из класс-метода.
%%% parser_e_absolute_only_one_var=03095_E_ABSOLUTE может быть указано только для одной пеpеменной
% Нельзя указывать более одной переменной перед директивой \var{absolute}.
% Следующая конструкция приведет к ошибке:
% \begin{verbatim}
% Var Z : Longint;
%     X,Y : Longint absolute Z;
% \end{verbatim}
%%% parser_e_type_and_var_only_in_generics=03224_E_VAR и TYPE допустимы только в обобщениях (generic)
% Использование VAR и TYPE для объявления новых типов внутри объекта разрешается только для
% обобщений.
%%% type_w_signed_unsigned_always_false=04044_W_Сравнение всегда ложно из-за диапазонов значений
% Сравнение беззнакового значения со знаковой константой, меньшей нуля. Результат такого выражения
% будет всегда ложным. Следует явно привести тип константы к нужному диапазону.
%%% type_w_signed_unsigned_always_true=04045_W_Сравнение всегда истинно из-за диапазонов значений
% Сравнение беззнакового значения со знаковой константой, меньшей нуля. Результат такого выражения
% будет всегда истинным. Следует явно привести тип константы к нужному диапазону.
%%% type_interface_has_no_guid=04083_E_Тип интерфейса $1 не имеет GUID
% При использовании оператора as нужный интерфейс, т.е правый операнд оператора as,
% должен иметь правильный GUID.

<?xml version="1.0" encoding="ISO8859-1"?>
<fpdoc-descriptions>
<!--  

   $Id$ 
   This file is part of the FPC documentation. 
   Copyright (C) 1997, by Michael Van Canneyt 
 
   The FPC documentation is free text; you can redistribute it and/or 
   modify it under the terms of the GNU Library General Public License as 
   published by the Free Software Foundation; either version 2 of the 
   License, or (at your option) any later version. 
 
   The FPC Documentation is distributed in the hope that it will be useful, 
   but WITHOUT ANY WARRANTY; without even the implied warranty of 
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
   Library General Public License for more details. 
 
   You should have received a copy of the GNU Library General Public 
   License along with the FPC documentation; see the file COPYING.LIB.  If not, 
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, 
   Boston, MA 02111-1307, USA. 
 -->
<package name="rtl">
<module name="system">
<short>The system unit</short>
<!-- \FPCexampledir{refex} -->
<descr>
<p>
The system unit contains the standard supported functions of Free Pascal. It is the
same for all platforms. Basically it is the same as the system unit provided
with Borland or Turbo Pascal.
</p>
<p>
Functions are listed in alphabetical order. Arguments of functions or
procedures that are optional are put between square brackets.
</p>
<p>
The pre-defined constants and variables are listed in the first section.
The second section contains an overview of all functions, grouped by
functionality, and the last section contains the supported functions
and procedures.
</p>
</descr>

<topic name="FileFunctions">
<short>File handling functions</short>
<descr>
<p>
Functions concerning input and output from and to file.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Append"/></td><td>Open a file in append mode</td></tr>
<tr><td><link id="Assign"/></td><td>Assign a name to a file</td></tr>
<tr><td><link id="Blockread"/></td><td>Read data from a file into memory</td></tr>
<tr><td><link id="Blockwrite"/></td><td>Write data from memory to a file</td></tr>
<tr><td><link id="Close"/></td><td>Close a file</td></tr>
<tr><td><link id="Eof"/></td><td>Check for end of file</td></tr>
<tr><td><link id="Eoln"/></td><td>Check for end of line</td></tr>
<tr><td><link id="Erase"/></td><td>Delete  file from disk</td></tr>
<tr><td><link id="Filepos"/></td><td>Position in file</td></tr>
<tr><td><link id="Filesize"/></td><td>Size of file</td></tr>
<tr><td><link id="Flush"/></td><td>Write file buffers to disk</td></tr>
<tr><td><link id="IOresult"/></td><td>Return result of last file IO operation</td></tr>
<tr><td><link id="Read"/></td><td>Read from file into variable</td></tr>
<tr><td><link id="Readln"/></td><td>Read from file into variable and goto next line</td></tr>
<tr><td><link id="Rename"/></td><td>Rename file on disk</td></tr>
<tr><td><link id="Reset"/></td><td>Open file for reading</td></tr>
<tr><td><link id="Rewrite"/></td><td>Open file for writing</td></tr>
<tr><td><link id="Seek"/></td><td>Set file position</td></tr>
<tr><td><link id="SeekEof"/></td><td>Set file position to end of file</td></tr>
<tr><td><link id="SeekEoln"/></td><td>Set file position to end of line</td></tr>
<tr><td><link id="SetTextBuf"/></td><td>Set size of file buffer</td></tr>
<tr><td><link id="Truncate"/></td><td>Truncate the file at position</td></tr>
<tr><td><link id="Write"/></td><td>Write variable to file</td></tr>
<tr><td><link id="WriteLn"/></td><td>Write variable to file and append newline</td></tr>
</table>
</descr>
</topic>

<topic name="MemoryFunctions">
<short>Memory management functions</short>
<descr>
<p>
Functions concerning memory issues.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Addr"/></td><td>Return address of variable</td></tr>
<tr><td><link id="Assigned"/></td><td>Check if a pointer is valid</td></tr>
<tr><td><link id="CompareByte"/></td><td>Compare 2 memory buffers byte per byte</td></tr>
<tr><td><link id="CompareChar"/></td><td>Compare 2 memory buffers byte per byte</td></tr>
<tr><td><link id="CompareDWord"/></td><td>Compare 2 memory buffers byte per byte</td></tr>
<tr><td><link id="CompareWord"/></td><td>Compare 2 memory buffers byte per byte</td></tr>
<tr><td><link id="CSeg"/></td><td>Return code segment</td></tr>
<tr><td><link id="Dispose"/></td><td>Free dynamically allocated memory</td></tr>
<tr><td><link id="DSeg"/></td><td>Return data segment</td></tr>
<tr><td><link id="FillByte"/></td><td>Fill memory region with 8-bit pattern</td></tr>
<tr><td><link id="Fillchar"/></td><td>Fill memory region with certain character</td></tr>
<tr><td><link id="FillDWord"/></td><td>Fill memory region with 32-bit pattern</td></tr>
<tr><td><link id="Fillword"/></td><td>Fill memory region with 16-bit pattern</td></tr>
<tr><td><link id="Freemem"/></td><td>Release allocated memory</td></tr>
<tr><td><link id="Getmem"/></td><td>Allocate new memory</td></tr>
<tr><td><link id="GetMemoryManager"/></td><td>Return current memory manager</td></tr>
<tr><td><link id="High"/></td><td>Return highest index of open array or enumerated</td></tr>
<tr><td><link id="IsMemoryManagerSet"/></td><td>Is the memory manager set</td></tr>
<tr><td><link id="Low"/></td><td>Return lowest index of open array or enumerated</td></tr>
<tr><td><link id="Move"/></td><td>Move data from one location in memory to another</td></tr>
<tr><td><link id="MoveChar0">MoveChar0</link></td><td>Move data till first zero character</td></tr>
<tr><td><link id="New"/></td><td>Dynamically allocate memory for variable</td></tr>
<tr><td><link id="Ofs"/></td><td>Return offset of variable</td></tr>
<tr><td><link id="Ptr"/></td><td>Combine segment and offset to pointer</td></tr>
<tr><td><link id="ReAllocMem"/></td><td>Resize a memory block on the heap</td></tr>
<tr><td><link id="Seg"/></td><td>Return segment</td></tr>
<tr><td><link id="SetMemoryManager"/></td><td>Set a memory manager</td></tr>
<tr><td><link id="Sptr"/></td><td>Return current stack pointer</td></tr>
<tr><td><link id="SSeg"/></td><td>Return stack segment register value</td></tr>
</table>
</descr>
</topic>

<topic name="MathematicalFunctions">
<short>Mathematical routines</short>
<descr>
<p>
Functions connected to calculating and coverting numbers.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Abs"/></td><td>Calculate absolute value</td></tr>
<tr><td><link id="Arctan"/></td><td>Calculate inverse tangent</td></tr>
<tr><td><link id="Cos"/></td><td>Calculate cosine of angle</td></tr>
<tr><td><link id="Dec"/></td><td>Decrease value of variable</td></tr>
<tr><td><link id="Exp"/></td><td>Exponentiate</td></tr>
<tr><td><link id="Frac"/></td><td>Return fractional part of floating point value</td></tr>
<tr><td><link id="Hi"/></td><td>Return high byte/word of value</td></tr>
<tr><td><link id="Inc"/></td><td>Increase value of variable</td></tr>
<tr><td><link id="Int"/></td><td>Calculate integer part of floating point value</td></tr>
<tr><td><link id="Ln"/></td><td>Calculate logarithm</td></tr>
<tr><td><link id="Lo"/></td><td>Return low byte/word of value</td></tr>
<tr><td><link id="Odd"/></td><td>Is a value odd or even ? </td></tr>
<tr><td><link id="Pi"/></td><td>Return the value of pi</td></tr>
<tr><td><link id="Power"/></td><td>Raise float to integer power</td></tr>
<tr><td><link id="Random"/></td><td>Generate random number</td></tr>
<tr><td><link id="Randomize"/></td><td>Initialize random number generator</td></tr>
<tr><td><link id="Round"/></td><td>Round floating point value to nearest integer number</td></tr>
<tr><td><link id="Sin"/></td><td>Calculate sine of angle</td></tr>
<tr><td><link id="Sqr"/></td><td>Calculate the square of a value</td></tr>
<tr><td><link id="Sqrt"/></td><td>Calculate the square root of a value</td></tr>
<tr><td><link id="Swap"/></td><td>Swap high and low bytes/words of a variable</td></tr>
<tr><td><link id="Trunc"/></td><td>Truncate a floating point value</td></tr>
</table>
</descr>
</topic>

<topic name="StringFunctions">
<short>String handling</short>
<descr>
<p>
All things connected to string handling.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="BinStr"/></td><td>Construct binary representation of integer</td></tr>
<tr><td><link id="Chr"/></td><td>Convert ASCII code to character</td></tr>
<tr><td><link id="Concat"/></td><td>Concatenate two strings</td></tr>
<tr><td><link id="Copy"/></td><td>Copy part of a string</td></tr>
<tr><td><link id="Delete"/></td><td>Delete part of a string</td></tr>
<tr><td><link id="HexStr"/></td><td>Construct hexadecimal representation of integer</td></tr>
<tr><td><link id="Insert"/></td><td>Insert one string in another</td></tr>
<tr><td><link id="Length"/></td><td>Return length of string</td></tr>
<tr><td><link id="Lowercase"/></td><td>Convert string to all-lowercase</td></tr>
<tr><td><link id="OctStr"/></td><td>Construct octal representation of integer</td></tr>
<tr><td><link id="Pos"/></td><td>Calculate position of one string in another</td></tr>
<tr><td><link id="SetLength"/></td><td>Set length of a string</td></tr>
<tr><td><link id="SetString"/></td><td>Set contents and length of a string</td></tr>
<tr><td><link id="Str"/></td><td>Convert number to string representation</td></tr>
<tr><td><link id="StringOfChar"/></td><td>Create string consisting of a number of characters</td></tr>
<tr><td><link id="Upcase"/></td><td>Convert string to all-uppercase</td></tr>
<tr><td><link id="Val"/></td><td>Convert string to number</td></tr>
</table>
</descr>
</topic>

<topic name="OSfunctions">
<short>Operating System functions</short>
<descr>
<p>
Functions that are connected to the operating system.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Chdir"/></td><td>Change working directory</td></tr>
<tr><td><link id="Getdir"/></td><td>Return current working directory</td></tr>
<tr><td><link id="Halt"/></td><td>Halt program execution</td></tr>
<tr><td><link id="Paramcount"/></td><td>Number of parameters with which program was called</td></tr>
<tr><td><link id="Paramstr"/></td><td>Retrieve parameters with which program was called</td></tr>
<tr><td><link id="Mkdir"/></td><td>Make a directory</td></tr>
<tr><td><link id="Rmdir"/></td><td>Remove a directory</td></tr>
<tr><td><link id="Runerror"/></td><td>Abort program execution with error condition</td></tr>
</table>
</descr>
</topic>

<topic name="MiscellaneousFunctions">
<short>Miscellaneous functions</short>
<descr>
<p>
Functions that do not belong in one of the other categories.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="Assert"/></td><td>Conditionally abort program with error</td></tr>
<tr><td><link id="Break"/></td><td>Abort current loop</td></tr>
<tr><td><link id="Continue"/></td><td>Next cycle in current loop</td></tr>
<tr><td><link id="Exclude"/></td><td>Exclude an element from a set</td></tr>
<tr><td><link id="Exit"/></td><td>Exit current function or procedure</td></tr>
<tr><td><link id="Include"/></td><td>Include an element into a set</td></tr>
<tr><td><link id="LongJmp"/></td><td>Jump to execution point</td></tr>
<tr><td><link id="Ord"/></td><td>Return ordinal value of enumerated type</td></tr>
<tr><td><link id="Pred"/></td><td>Return previous value of ordinal type</td></tr>
<tr><td><link id="SetJmp"/></td><td>Mark execution point for jump</td></tr>
<tr><td><link id="SizeOf"/></td><td>Return size of variable or type</td></tr>
<tr><td><link id="Succ"/></td><td>Return next value of ordinal type</td></tr>
</table>
</descr>
</topic>

<element name="Abs">
<short>Calculate absolute value</short>
<descr>
<var>Abs</var> returns the absolute value of a variable. The result of the
function has the same type as its argument, which can be any numerical
type.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Round"/>
</seealso>
<example file="refex/ex1"/>
</element>



<element name="Addr">
<short>Return address of a variable</short>
<descr>
<var>Addr</var> returns a pointer to its argument, which can be any type, or a
function or procedure name. The returned pointer isn't typed.
The same result can be obtained by the <var>@</var> operator, which can return a
typed pointer (\progref).
</descr>
<errors>
None
</errors>
<seealso>
<link id="SizeOf"/>
</seealso>
<example file="refex/ex2"/>
</element>



<element name="Append">
<short>Open a file in append mode</short>
<descr>
<var>Append</var> opens an existing file in append mode. Any data written to
<var>F</var> will be appended to the file. Only text files can be opened in
append mode. After a call to <var>Append</var>, the file <var>F</var> becomes
write-only.

File sharing is not taken into account when calling <var>Append</var>.

</descr>
<errors>
If the file doesn't exist when appending, a run-time error will be generated.
This behaviour has changed on Windows and Linux platforms, where in versions
prior to 1.0.6, the file would be created in append mode.
</errors>
<seealso>
<link id="Rewrite"/>
<link id="Close"/>
<link id="Reset"/>
</seealso>
<example file="refex/ex3"/>
</element>



<element name="Arctan">
<short>Calculate inverse tangent</short>
<descr>
<var>Arctan</var> returns the Arctangent of <var>X</var>, which can be any Real type.
The resulting angle is in radial units.
</descr>
<errors>
None
</errors>
<seealso>
<link id="Sin"/>
<link id="Cos"/>
</seealso>
<example file="refex/ex4"/>
</element>



<element name="Assert">
<short>Check validity of a given condition.</short>
<descr>
With assertions on, <var>Assert</var> tests if <var>expr</var> is 
false, and if so, aborts the application with a Runtime error 
227 and an optional error message in <var>msg</var>.
If <var>expr</var> is true, program execution continues normally. 

If assertions are not enabled at compile time, this routine does 
nothing, and no code is generated for the <var>Assert</var> call. 

Enabling and disabling assertions at compile time is done via
the <var>\$C</var> or <var>\$ASSERTIONS</var> compiler switches. These are
global switches.

The default behavior of the assert call can be changed by 
setting a new handler in the <var>AssertErrorProc</var> variable.
Sysutils overrides the default handler to raise a <var>EAssertionFailed</var> 
exception.


</descr>
<errors>
None.
</errors>
<seealso>
<link id="Halt"/>
<link id="Runerror"/>
</seealso>
</element>


<element name="Assign">
<short>Assign a name to a file</short>
<descr>
<var>Assign</var> assigns a name to <var>F</var>, which can be any file type.
This call doesn't open the file, it just assigns a name to a file variable,
and marks the file as closed.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Reset"/>
<link id="Rewrite"/>
<link id="Append"/>
</seealso>
<example file="refex/ex5"/>
</element>



<element name="Assigned">
<short>Check if a pointer is valid</short>
<descr>
<var>Assigned</var> returns <var>True</var> if <var>P</var> is non-nil
and retuns <var>False</var> of <var>P</var> is nil.
The main use of Assigned is that Procedural variables, method variables and
class-type variables also can be passed to <var>Assigned</var>.
</descr>
<errors>
None
</errors>
<seealso>
<link id="New"/>
</seealso>
<example file="refex/ex96"/>
</element>



<element name="BinStr">
<short>Convert integer to string with binary representation.</short>
<descr>
<var>BinStr</var> returns a string with the binary representation
of <var>Value</var>. The string has at most <var>cnt</var> characters.
(i.e. only the <var>cnt</var> rightmost bits are taken into account)
To have a complete representation of any longint-type value, 32
bits are needed, i.e. <var>cnt=32</var>

</descr>
<errors>
None.
</errors>
<seealso>
<link id="Str"/>
<link id="Val"/>
<link id="HexStr"/>
<link id="OctStr"/>
</seealso>
<example file="refex/ex82"/>
</element>



<element name="Blockread">
<short>Read data from an untyped file into memory</short>
<descr>
<var>Blockread</var> reads <var>count</var> or less records from file <var>F</var>. A
record is a block of bytes with size specified by the <link id="Rewrite"/> or
<link id="Reset"/> statement.

The result is placed in <var>Buffer</var>, which must contain enough room for
<var>Count</var> records. The function cannot read partial records.
If <var>Result</var> is specified, it contains the number of records actually
read. If <var>Result</var> isn't specified, and less than <var>Count</var> records were
read, a run-time error is generated. This behavior can be controlled by the
\var{\{\$i\}} switch.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Blockwrite"/>
<link id="Close"/>
<link id="Reset"/>
<link id="Assign"/>
</seealso>
<example file="refex/ex6"/>
</element>



<element name="Blockwrite">
<short>Write data from memory to an untyped file</short>
<descr>
<var>BlockWrite</var> writes <var>count</var> records from <var>buffer</var> to the file
 <var>F</var>.A record is a block of bytes with size specified by the <link id="Rewrite"/> or
<link id="Reset"/> statement.

If the records couldn't be written to disk, a run-time error is generated.
This behavior can be controlled by the \var{\{\$i\}} switch.

</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Blockread"/>
<link id="Close"/>
<link id="Rewrite"/>
<link id="Assign"/>
</seealso>
</element>

For the example, see <link id="Blockread"/>.

<element name="Break">
<short>Exit current loop construct.</short>
<descr>
<p>
<var>Break</var> jumps to the statement following the end of the current
repetitive statement. The code between the <var>Break</var> call and
the end of the repetitive statement is skipped.
The condition of the repetitive statement is NOT evaluated.
</p>
<p>
This can be used with <var>For</var>, var{repeat} and <var>While</var> statements.
</p>
<p>
Note that while this is a procedure, <var>Break</var> is a reserved word
and hence cannot be redefined.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Continue"/>
<link id="Exit"/>
</seealso>
<example file="refex/ex87"/>
</element>



<element name="Chdir">
<short>Change current working directory.</short>
<descr>
<var>Chdir</var> changes the working directory of the process to <var>S</var>.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Mkdir"/>
<link id="Rmdir"/>
</seealso>
<example file="refex/ex7"/>
</element>



<element name="Chr">
<short>Convert byte value to character value</short>
<descr>
<var>Chr</var> returns the character which has ASCII value <var>X</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Ord"/>
<link id="Str"/>
</seealso>
<example file="refex/ex8"/>
</element>



<element name="Close">
<short>Close a file</short>
<descr>
<var>Close</var> flushes the buffer of the file <var>F</var> and closes <var>F</var>.
After a call to <var>Close</var>, data can no longer be read from or written to
<var>F</var>.
To reopen a file closed with <var>Close</var>, it isn't necessary to assign the
file again. A call to <link id="Reset"/> or <link id="Rewrite"/> is sufficient.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Assign"/>
<link id="Reset"/>
<link id="Rewrite"/>
<link id="Flush"/>
</seealso>
<example file="refex/ex9"/>
</element>



<element name="CompareByte">
<short>Compare 2 memory buffers byte per byte</short>
<descr>
<p>
<var>CompareByte</var> compares two memory regions <var>buf1</var>,<var>buf2</var> on a
byte-per-byte basis for a total of <var>len</var> bytes.
</p>
<p>
The function returns one of the following values:
</p>
<dl>
<dt>less than 0</dt>
<dd> if <var>buf1</var> and <var>buf2</var> contain different bytes
in the first <var>len</var> bytes, and the first such byte is smaller in <var>buf1</var>
than the byte at the same position in <var>buf2</var>.
</dd>
<dt>0</dt>
<dd>  if the first <var>len</var> bytes in <var>buf1</var> and <var>buf2</var> are
equal.
\item [greater than 0] if <var>buf1</var> and <var>buf2</var> contain different bytes
in the first <var>len</var> bytes, and the first such byte is larger in <var>buf1</var>
than the byte at the same position in <var>buf2</var>.
</dd>
</dl>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CompareChar"/>
<link id="CompareWord"/>
<link id="CompareDWord"/>
</seealso>
<example file="refex/ex99"/>
</element>



<element name="CompareChar">
<short>ompare 2 memory buffers character per character</short>
<descr>
<p>
<var>CompareChar</var> compares two memory regions <var>buf1</var>,<var>buf2</var> on a
character-per-character basis for a total of <var>len</var> characters.
</p>
<p>
The <var>CompareChar0</var> variant compares <var>len</var> bytes, or until
a zero character is found.
</p>
<p>
The function returns one of the following values:
</p>
<dl>
<dt>-1</dt>
<dd> if <var>buf1</var> and <var>buf2</var> contain different characters
in the first <var>len</var> positions, and the first such character is smaller in <var>buf1</var>
than the character at the same position in <var>buf2</var>.
</dd>
<dt>0</dt>
<dd>  if the first <var>len</var> characters in <var>buf1</var> and <var>buf2</var> are
equal.
</dd>
<dt>1</dt>
<dd>if <var>buf1</var> and <var>buf2</var> contain different characters
in the first <var>len</var> positions, and the first such character is larger in
<var>buf1</var> than the character at the same position in <var>buf2</var>.
</dd>
</dl>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CompareByte"/>
<link id="CompareWord"/>
<link id="CompareDWord"/>
</seealso>
<example file="refex/ex100"/>
</element>



<element name="CompareDWord">
<short>Compare 2 memory buffers DWord per DWord</short>
<descr>
<p>
<var>CompareDWord</var> compares two memory regions <var>buf1</var>,<var>buf2</var> on a
DWord-per-DWord basis for a total of <var>len</var> DWords. (A DWord is 4 bytes).
</p>
<p>
The function returns one of the following values:
</p>
<dl>
<dt>-1</dt>
<dd> if <var>buf1</var> and <var>buf2</var> contain different DWords
in the first <var>len</var> DWords, and the first such DWord is smaller in <var>buf1</var>
than the DWord at the same position in <var>buf2</var>.
</dd>
<dt>0</dt>
<dd>  if the first <var>len</var> DWords in <var>buf1</var> and <var>buf2</var> are
equal.
</dd>
<dt>1</dt>
<dd>if <var>buf1</var> and <var>buf2</var> contain different DWords
in the first <var>len</var> DWords, and the first such DWord is larger in <var>buf1</var>
than the DWord at the same position in <var>buf2</var>.
</dd>
</dl>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CompareChar"/>
<link id="CompareByte"/>
<link id="CompareWord"/>,
</seealso>
<example file="refex/ex101"/>
</element>



<element name="CompareWord">
<short>Compare 2 memory buffers word per word</short>
<descr>
<p>
<var>CompareWord</var> compares two memory regions <var>buf1</var>,<var>buf2</var> on a
Word-per-Word basis for a total of <var>len</var> Words. (A Word is 2 bytes).
</p>
<p>
The function returns one of the following values:
</p>
<dl>
<dt>-1</dt>
<dd> if <var>buf1</var> and <var>buf2</var> contain different Words
in the first <var>len</var> Words, and the first such Word is smaller in <var>buf1</var>
than the Word at the same position in <var>buf2</var>.
</dd>
<dt>0</dt>
<dd>  if the first <var>len</var> Words in <var>buf1</var> and <var>buf2</var> are
equal.
</dd>
<dt>1</dt>
<dd>
if <var>buf1</var> and <var>buf2</var> contain different Words
in the first <var>len</var> Words, and the first such Word is larger in <var>buf1</var>
than the Word at the same position in <var>buf2</var>.
</dd>
</dl>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CompareChar"/>
<link id="CompareByte"/>
<link id="CompareDWord"/>,
</seealso>
<example file="refex/ex102"/>
</element>



<element name="Concat">
<short>Append one string to another.</short>
<descr>
<var>Concat</var> concatenates the strings <var>S1</var>,<var>S2</var> etc. to one long
string. The resulting string is truncated at a length of 255 bytes.
The same operation can be performed with the <var>+</var> operation.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Copy"/>
<link id="Delete"/>
<link id="Insert"/>
<link id="Pos"/>
<link id="Length"/>
</seealso>
<example file="refex/ex10"/>
</element>



<element name="Continue">
<short>Continue with next loop cycle.</short>
<descr>
<p>
<var>Continue</var> jumps to the end of the current repetitive statement.
The code between the <var>Continue</var> call and the end of the repetitive
statement is skipped. The condition of the repetitive statement is then
checked again.
</p>
<p>
This can be used with <var>For</var>, var{repeat} and <var>While</var> statements.
</p>
<p>
Note that while this is a procedure, <var>Continue</var> is a reserved word
and hence cannot be redefined.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Break"/>
<link id="Exit"/>
</seealso>
<example file="refex/ex86"/>
</element>




<element name="Copy">
<short>Copy part of a string.</short>
<descr>
<var>Copy</var> returns a string which is a copy if the <var>Count</var> characters
in <var>S</var>, starting at position <var>Index</var>. If <var>Count</var> is larger than
the length of the string <var>S</var>, the result is truncated.
If <var>Index</var> is larger than the length of the string <var>S</var>, then an
empty string is returned.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Delete"/>
<link id="Insert"/>
<link id="Pos"/>
</seealso>
<example file="refex/ex11"/>
</element>



<element name="Cos">
<short>Calculate cosine of angle</short>
<descr>
<var>Cos</var> returns the cosine of <var>X</var>, where X is an angle, in radians.

If the absolute value of the argument is larger than \var{2\^{}63}, then the
result is undefined.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Arctan"/>
<link id="Sin"/>
</seealso>
<example file="refex/ex12"/>
</element>



<element name="CSeg">
<short>Return code segment</short>
<descr>
<var>CSeg</var> returns the Code segment register. In Free Pascal, it returns always a
zero, since Free Pascal is a 32 bit compiler.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="DSeg"/>
<link id="Seg"/>
<link id="Ofs"/>
<link id="Ptr"/>
</seealso>
<example file="refex/ex13"/>
</element>



<element name="Dec">
<short>Decrease value of variable</short>
<descr>
<var>Dec</var> decreases the value of <var>X</var> with <var>Decrement</var>.
If <var>Decrement</var> isn't specified, then 1 is taken as a default.
</descr>
<errors>
A range check can occur, or an underflow error, if an attempt it made
to decrease <var>X</var> below its minimum value.
</errors>
<seealso>
<link id="Inc"/>
</seealso>
<example file="refex/ex14"/>
</element>



<element name="Delete">
<short>Delete part of a string.</short>
<descr>
<var>Delete</var> removes <var>Count</var> characters from string <var>S</var>, starting
at position <var>Index</var>. All characters after the delected characters are
shifted <var>Count</var> positions to the left, and the length of the string is adjusted.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Copy"/>
<link id="Pos"/>
<link id="Insert"/>
</seealso>
<example file="refex/ex15"/>
</element>



<element name="Dispose">
<short>Free dynamically allocated memory</short>
<descr>
<p>
The first form <var>Dispose</var> releases the memory allocated with a call to
<link id="New"/>. The pointer <var>P</var> must be typed. The released memory is
returned to the heap.
</p>
<p>
The second form of <var>Dispose</var> accepts as a first parameter a pointer
to an object type, and as a second parameter the name of a destructor
of this object. The destructor will be called, and the memory allocated
for the object will be freed.
</p>
</descr>
<errors>
An runtime error will occur if the pointer doesn't point to a location in the
heap.
</errors>
<seealso>
<link id="New"/>
<link id="Getmem"/>
<link id="Freemem"/>
</seealso>
<example file="refex/ex16"/>
</element>



<element name="DSeg">
<short>Return data segment</short>
<descr>
<var>DSeg</var> returns the data segment register. In Free Pascal, it returns always a
zero, since Free Pascal is a 32 bit compiler.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CSeg"/>
<link id="Seg"/>
<link id="Ofs"/>
<link id="Ptr"/>
</seealso>
<example file="refex/ex17"/>
</element>



<element name="Eof">
<short>Check for end of file</short>
<descr>
<var>Eof</var> returns <var>True</var> if the file-pointer has reached the end of the
file, or if the file is empty. In all other cases <var>Eof</var> returns
<var>False</var>.
If no file <var>F</var> is specified, standard input is assumed.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Eoln"/>
<link id="Assign"/>
<link id="Reset"/>
<link id="Rewrite"/>
</seealso>
<example file="refex/ex18"/>
</element>



<element name="Eoln">
<short>Check for end of line</short>
<descr>
<var>Eof</var> returns <var>True</var> if the file pointer has reached the end of a
line, which is demarcated by a line-feed character (ASCII value 10), or if
the end of the file is reached.
In all other cases <var>Eof</var> returns <var>False</var>.
If no file <var>F</var> is specified, standard input is assumed.
It can only be used on files of type <var>Text</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Eof"/>
<link id="Assign"/>
<link id="Reset"/>
<link id="Rewrite"/>
</seealso>
<example file="refex/ex19"/>
</element>



<element name="Erase">
<short>Delete a file from disk</short>
<descr>
<var>Erase</var> removes an unopened file from disk. The file should be
assigned with <var>Assign</var>, but not opened with <var>Reset</var> or <var>Rewrite</var>
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Assign"/>
</seealso>
<example file="refex/ex20"/>
</element>



<element name="Exclude">
<short>Exlude element from a set if it is present.</short>
<descr>
<p>
<var>Exclude</var> removes <var>E</var> from the set <var>S</var> if it is
included inthe set. E should be of the same type as the base type
of the set <var>S</var>.
</p>
<p>
Thus, the two following statements do the same thing:
</p>
<code>
S:=S-[E];
Exclude(S,E);
</code>
</descr>
<errors>
If the type of the element <var>E</var> is not equal to the base type of the
set <var>S</var>, the compiler will generate an error.
</errors>
<seealso>
<link id="Include"/>
</seealso>
<example file="refex/ex111"/>
</element>



<element name="Exit">
<short>Exit current subroutine.</short>
<descr>
<var>Exit</var> exits the current subroutine, and returns control to the calling
routine. If invoked in the main program routine, exit stops the program.
The optional argument <var>X</var> allows to specify a return value, in the case
<var>Exit</var> is invoked in a function. The function result will then be
equal to <var>X</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Halt"/>
</seealso>
<example file="refex/ex21"/>
</element>



<element name="Exp">
<short>Exponentiate</short>
<descr>
<var>Exp</var> returns the exponent of <var>X</var>, i.e. the number <var>e</var> to the
power <var>X</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Ln"/>
<link id="Power"/>
</seealso>
<example file="refex/ex22"/>
</element>



<element name="Filepos">
<short>Get position in file</short>
<descr>
<var>Filepos</var> returns the current record position of the file-pointer in file
<var>F</var>. It cannot be invoked with a file of type <var>Text</var>. A compiler error
will be generated if this is attempted.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Filesize"/>
</seealso>
<example file="refex/ex23"/>
</element>



<element name="Filesize">
<short>Size of file</short>
<descr>
<var>Filesize</var> returns the total number of records in file <var>F</var>.
It cannot be invoked with a file of type <var>Text</var>. (under linux and unix, this
also means that it cannot be invoked on pipes).
If <var>F</var> is empty, 0 is returned.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Filepos"/>
</seealso>
<example file="refex/ex24"/>
</element>



<element name="FillByte">
<short>Fill memory region with 8-bit pattern</short>
<descr>
<var>FillByte</var> fills the memory starting at <var>X</var> with <var>Count</var> bytes
with value equal to <var>Value</var>.

This is useful for quickly zeroing out a memory location. When the size of
the memory location to be filled out is a multiple of 2 bytes, it is better
 to use <link id="Fillword"/>, and if it is a multiple of 4 bytes it is better
to use <link id="FillDWord"/>, these routines are optimized for their respective sizes.

</descr>
<errors>
No checking on the size of <var>X</var> is done.
</errors>
<seealso>
<link id="Fillchar"/>
<link id="FillDWord"/>
<link id="Fillword"/>
<link id="Move"/>
</seealso>
<example file="refex/ex102"/>
</element>



<element name="Fillchar">
<short>Fill memory region with certain character</short>
<descr>
<var>Fillchar</var> fills the memory starting at <var>X</var> with <var>Count</var> bytes
or characters with value equal to <var>Value</var>.

</descr>
<errors>
No checking on the size of <var>X</var> is done.
</errors>
<seealso>
<link id="Fillword"/>
<link id="Move"/>
<link id="FillByte"/>
<link id="FillDWord"/>
</seealso>
<example file="refex/ex25"/>
</element>



<element name="FillDWord">
<short>Fill memory region with 32-bit pattern</short>
<descr>
<var>Fillword</var> fills the memory starting at <var>X</var> with <var>Count</var> DWords
with value equal to <var>Value</var>. A DWord is 4 bytes in size.

</descr>
<errors>
No checking on the size of <var>X</var> is done.
</errors>
<seealso>
<link id="FillByte"/>
<link id="Fillchar"/>
<link id="Fillword"/>
<link id="Move"/>
</seealso>
<example file="refex/ex103"/>
</element>



<element name="Fillword">
<short>Fill memory region with 16-bit pattern</short>
<descr>
<var>Fillword</var> fills the memory starting at <var>X</var> with <var>Count</var> words
with value equal to <var>Value</var>. A word is 2 bytes in size.
</descr>
<errors>
No checking on the size of <var>X</var> is done.
</errors>
<seealso>
<link id="Fillchar"/>
<link id="Move"/>
</seealso>
<example file="refex/ex76"/>
</element>



<element name="Flush">
<short>Write file buffers to disk</short>
<descr>
<var>Flush</var> empties the internal buffer of an opened file <var>F</var> and writes the
contents to disk. The file is \textit{not} closed as a result of this call.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Close"/>
</seealso>
<example file="refex/ex26"/>
</element>



<element name="Frac">
<short>Return fractional part of floating point value.</short>
<descr>
<var>Frac</var> returns the non-integer part of <var>X</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Round"/>
<link id="Int"/>
</seealso>
<example file="refex/ex27"/>
</element>



<element name="Freemem">
<short>Release allocated memory</short>
<descr>
<var>Freemem</var> releases the memory occupied by the pointer <var>P</var>, of size
<var>Count</var> (in bytes), and returns it to the heap. <var>P</var> should point to the memory
allocated to a dynamic variable.
</descr>
<errors>
An error will occur when <var>P</var> doesn't point to the heap.
</errors>
<seealso>
<link id="Getmem"/>
<link id="New"/>
<link id="Dispose"/>
</seealso>
<example file="refex/ex28"/>
</element>


<element name="Getdir">
<short>Return the current directory</short>
<descr>
<var>Getdir</var> returns in <var>dir</var> the current directory on the drive
<var>drivenr</var>, where {drivenr} is 1 for the first floppy drive, 3 for the
first hard disk etc. A value of 0 returns the directory on the current disk.
On linux and unix systems, <var>drivenr</var> is ignored, as there is only one
directory tree.
</descr>
<errors>
An error is returned under dos, if the drive requested isn't ready.
</errors>
<seealso>
<link id="Chdir"/>
</seealso>
<example file="refex/ex29"/>
</element>



<element name="Getmem">
<short>Allocate new memory on the heap</short>
<descr>
<p>
<var>Getmem</var> reserves <var>Size</var> bytes memory on the heap, and returns a
pointer to this memory in <var>p</var>. If no more memory is available, nil is
returned.
</p>
<p>
For an example, see <link id="Freemem"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Freemem"/>
<link id="Dispose"/>
<link id="New"/>
</seealso>
</element>

<element name="GetMemoryManager">
<short>Return current memory manager</short>
<descr>
<p>
<var>GetMemoryManager</var> stores the current Memory Manager record in
<var>MemMgr</var>.
</p>
<p>
For an example, see \progref.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="SetMemoryManager"/>
<link id="IsMemoryManagerSet"/>.
</seealso>
</element>


<element name="Halt">
<short>Stop program execution.</short>
<descr>
<var>Halt</var> stops program execution and returns control to the calling
program. The optional argument <var>Errnum</var> specifies an exit value. If
omitted, zero is returned.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Exit"/>
</seealso>
<example file="refex/ex30"/>
</element>



<element name="HexStr">
<short>Convert integer value to string with hexadecimal representation.</short>
<descr>
<var>HexStr</var> returns a string with the hexadecimal representation
of <var>Value</var>. The string has exactly <var>cnt</var> charaters.
 (i.e. only the <var>cnt</var> rightmost nibbles are taken into account)
To have a complete representation of a Longint-type value, 8
nibbles are needed, i.e. <var>cnt=8</var>.

</descr>
<errors>
None.
</errors>
<seealso>
<link id="Str"/>
<link id="Val"/>
<link id="BinStr"/>
</seealso>
<example file="refex/ex81"/>
</element>



<element name="Hi">
<short>Return high byte/word of value.</short>
<descr>
<var>Hi</var> returns the high byte or word from <var>X</var>, depending on the size
of X. If the size of X is 4, then the high word is returned. If the size is
2 then the high byte is returned.
<var>Hi</var> cannot be invoked on types of size 1, such as byte or char.
</descr>
<errors>
None
</errors>
<seealso>
<link id="Lo"/>
</seealso>
<example file="refex/ex31"/>
</element>



<element name="High">
<short>Return highest index of open array or enumerated</short>
<descr>
<p>
The return value of <var>High</var> depends on it's argument:
</p>
<ol>
<li> If the argument is an ordinal type, <var>High</var> returns the highest
 value in the range of the given ordinal type.
</li>
<li> If the argument is an array type or an array type variable then
<var>High</var> returns the highest possible value of it's index.
</li>
<li> If the argument is an open array identifier in a function or
procedure, then <var>High</var> returns the highest index of the array, as if the
array has a zero-based index.
</li>
</ol>
<p>
The return type is always the same type as the type of the argument
(This can lead to some nasty surprises !).
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Low"/>
<link id="Ord"/>
<link id="Pred"/>
<link id="Succ"/>
</seealso>
<example file="refex/ex80"/>
</element>



<element name="Inc">
<short>Increase value of integer variable</short>
<descr>
<var>Inc</var> increases the value of <var>X</var> with <var>Increment</var>.
If <var>Increment</var> isn't specified, then 1 is taken as a default.
</descr>
<errors>
If range checking is on, then A range check can occur, or an overflow
error, when an attempt is made to increase <var>X</var> over its maximum value.
</errors>
<seealso>
<link id="Dec"/>
</seealso>
<example file="refex/ex32"/>
</element>



<element name="Include">
<short>Include element in set if it was not yet present.</short>
<descr>
<p>
<var>Include</var> includes <var>E</var> in the set <var>S</var> if it is
not yet part of the set. E should be of the same type as the base type
of the set <var>S</var>.
</p>
<p>
Thus, the two following statements do the same thing:
</p>
<code>
S:=S+[E];
Include(S,E);
</code>
<p>
For an example, see <link id="Exclude"/>
</p>
</descr>
<errors>
If the type of the element <var>E</var> is not equal to the base type of the
set <var>S</var>, the compiler will generate an error.
</errors>
<seealso>
<link id="Exclude"/>
</seealso>
</element>


<element name="IndexByte">
<short>Search for a byte in a memory range.</short>
<descr>
<var>IndexByte</var> searches the memory at <var>buf</var> for maximally <var>len</var>
positions for the byte <var>b</var> and returns it's position if it found one.
If <var>b</var> is not found then -1 is returned.

The position is zero-based.
</descr>
<errors>
<var>Buf</var> and <var>Len</var> are not checked to see if they are valid values.
</errors>
<seealso>
<link id="IndexChar"/>
<link id="IndexDWord"/>
<link id="IndexWord"/>
<link id="CompareByte"/>
</seealso>
<example file="refex/ex105"/>
</element>



<element name="IndexChar">
<short>Search for a character in a memory range.</short>
<descr>
<var>IndexChar</var> searches the memory at <var>buf</var> for maximally <var>len</var>
positions for the character <var>b</var> and returns it's position if it found one.
If <var>b</var> is not found then -1 is returned.

The position is zero-based. The <var>IndexChar0</var> variant stops looking if
a null character is found, and returns -1 in that case.
</descr>
<errors>
<var>Buf</var> and <var>Len</var> are not checked to see if they are valid values.
</errors>
<seealso>
<link id="IndexByte"/>
<link id="IndexDWord"/>
<link id="IndexWord"/>
<link id="CompareChar"/>
</seealso>
<example file="refex/ex108"/>
</element>



<element name="IndexDWord">
<short>Search for a DWord value in a memory range.</short>
<descr>
<var>IndexChar</var> searches the memory at <var>buf</var> for maximally <var>len</var>
positions for the DWord <var>DW</var> and returns it's position if it found one.
If <var>DW</var> is not found then -1 is returned.

The position is zero-based.
</descr>
<errors>
<var>Buf</var> and <var>Len</var> are not checked to see if they are valid values.
</errors>
<seealso>
<link id="IndexByte"/>
<link id="IndexChar"/>
<link id="IndexWord"/>
<link id="CompareDWord"/>
</seealso>
<example file="refex/ex106"/>
</element>



<element name="IndexWord">
<short>Search for a WORD value in a memory range.</short>
<descr>
<var>IndexChar</var> searches the memory at <var>buf</var> for maximally <var>len</var>
positions for the Word <var>W</var> and returns it's position if it found one.
If <var>W</var> is not found then -1 is returned.
</descr>
<errors>
<var>Buf</var> and <var>Len</var> are not checked to see if they are valid values.
</errors>
<seealso>
<link id="IndexByte"/>
<link id="IndexDWord"/>
<link id="IndexChar"/>
<link id="CompareWord"/>
</seealso>
<example file="refex/ex107"/>
</element>



<element name="Insert">
<short>Insert one string in another.</short>
<descr>
<var>Insert</var> inserts string <var>Source</var> in string <var>S</var>, at position
<var>Index</var>, shifting all characters after <var>Index</var> to the right. The
resulting string is truncated at 255 characters, if needed. (i.e. for
shortstrings)
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Delete"/>
<link id="Copy"/>
<link id="Pos"/>
</seealso>
<example file="refex/ex33"/>
</element>



<element name="IsMemoryManagerSet">
<short>Is the memory manager set</short>
<descr>
<var>IsMemoryManagerSet</var> will return <var>True</var> if the memory manager has
been set to another value than the system heap manager, it will return
<var>False</var> otherwise.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="SetMemoryManager"/>
<link id="GetMemoryManager"/>
</seealso>
</element>

<element name="Int">
<short>Calculate integer part of floating point value.</short>
<descr>
<var>Int</var> returns the integer part of any Real <var>X</var>, as a Real.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Frac"/>
<link id="Round"/>
</seealso>
<example file="refex/ex34"/>
</element>



<element name="IOresult">
<short>Return result of last file IO operation</short>
<descr>
<p>
IOresult contains the result of any input/output call, when the
<var>{\$i-}</var> compiler directive is active, disabling IO checking.
When the flag is read, it is reset to zero.
If <var>IOresult</var> is zero, the operation completed successfully. If
non-zero, an error occurred. The following errors can occur:
</p>
<p>
dos errors :
</p>
<dl><dt>2</dt><dd> File not found.</dd>
<dt>3</dt><dd> Path not found.</dd>
<dt>4</dt><dd> Too many open files.</dd>
<dt>5</dt><dd> Access denied.</dd>
<dt>6</dt><dd> Invalid file handle.</dd>
<dt>12</dt><dd> Invalid file-access mode.</dd>
<dt>15</dt><dd> Invalid disk number.</dd>
<dt>16</dt><dd> Cannot remove current directory.</dd>
<dt>17</dt><dd> Cannot rename across volumes.</dd>
</dl>
<p>
I/O errors :
</p>
<dl>
<dt>100</dt><dd> Error when reading from disk.</dd>
<dt>101</dt><dd> Error when writing to disk.</dd>
<dt>102</dt><dd> File not assigned.</dd>
<dt>103</dt><dd> File not open.</dd>
<dt>104</dt><dd> File not opened for input.</dd>
<dt>105</dt><dd> File not opened for output.</dd>
<dt>106</dt><dd> Invalid number.</dd>
</dl>
<p>
Fatal errors :
</p>
<dl>
<dt>150</dt><dd> Disk is write protected.</dd>
<dt>151</dt><dd> Unknown device.</dd>
<dt>152</dt><dd> Drive not ready.</dd>
<dt>153</dt><dd> Unknown command.</dd>
<dt>154</dt><dd> CRC check failed.</dd>
<dt>155</dt><dd> Invalid drive specified..</dd>
<dt>156</dt><dd> Seek error on disk.</dd>
<dt>157</dt><dd> Invalid media type.</dd>
<dt>158</dt><dd> Sector not found.</dd>
<dt>159</dt><dd> Printer out of paper.</dd>
<dt>160</dt><dd> Error when writing to device.</dd>
<dt>161</dt><dd> Error when reading from device.</dd>
<dt>162</dt><dd> Hardware failure.</dd>
</dl>
</descr>
<errors>
None.
</errors>
<seealso>
All I/O functions.
</seealso>
<example file="refex/ex35"/>
</element>



<element name="Length">
<short>Calculate length of a string.</short>
<descr>
<var>Length</var> returns the length of the string <var>S</var>, which is limited
to 255 for shortstrings. If the strings <var>S</var> is empty, 0 is returned.

<em> Note:</em> The length of the string <var>S</var> is stored in <var>S[0]</var> for
shortstrings only. The <var>Length</var> fuction should always be used on 
ansistrings and widestrings.

</descr>
<errors>
None.
</errors>
<seealso>
<link id="Pos"/>
</seealso>
<example file="refex/ex36"/>
</element>



<element name="Ln">
<short>Calculate logarithm</short>
<descr>
<var>Ln</var> returns the natural logarithm of the Real parameter <var>X</var>.
<var>X</var> must be positive.
</descr>
<errors>
An run-time error will occur when <var>X</var> is negative.
</errors>
<seealso>
<link id="Exp"/>
<link id="Power"/>
</seealso>
<example file="refex/ex37"/>
</element>



<element name="Lo">
<short>Return low byte/word of value.</short>
<descr>
<var>Lo</var> returns the low byte of its argument if this is of type
<var>Integer</var> or
<var>Word</var>. It returns the low word of its argument if this is of type
<var>Longint</var> or <var>Cardinal</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Ord"/>
<link id="Chr"/>
<link id="Hi"/>
</seealso>
<example file="refex/ex38"/>
</element>



<element name="LongJmp">
<short>Jump to address.</short>
<descr>
<p>
<var>LongJmp</var> jumps to the adress in the <var>env</var> <var>jmp_buf</var>,
and restores the registers that were stored in it at the corresponding
<link id="SetJmp"/> call.
In effect, program flow will continue at the <var>SetJmp</var> call, which will
return <var>value</var> instead of 0. If a <var>value</var> equal to zero is passed,
it will be converted to 1 before passing it on. The call will not return, so it must be
used with extreme care.
This can be used for error recovery, for instance when a segmentation fault
occurred.
</p>
<p>
For an example, see <link id="SetJmp"/>
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="SetJmp"/>
</seealso>
</element>

<element name="Low">
<short>Return lowest index of open array or enumerated</short>
<descr>
<p>
 The return value of <var>Low</var> depends on it's argument:
</p>
<ol>
<li> If the argument is an ordinal type, <var>Low</var> returns the lowest
value in the range of the given ordinal type.
</li>
<li> If the argument is an array type or an array type variable then
<var>Low</var> returns the lowest possible value of it's index.
</li>
</ol>
<p>
The return type is always the same type as the type of the argument.
</p>
<p>
for an example, see <link id="High"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="High"/>
<link id="Ord"/>
<link id="Pred"/>
<link id="Succ"/>
</seealso>
</element>

<element name="Lowercase">
<short>Return lowercase version of a string.</short>
<descr>
<var>Lowercase</var> returns the lowercase version of its argument <var>C</var>.
If its argument is a string, then the complete string is converted to
lowercase. The type of the returned value is the same as the type of the
argument.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Upcase"/>
</seealso>
<example file="refex/ex73"/>
</element>




<element name="Mkdir">
<short>Create a new directory.</short>
<descr>
<p>
<var>Mkdir</var> creates a new  directory <var>S</var>.
</p>
<p>
For an example, see <link id="Rmdir"/>.
</p>
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Chdir"/>
<link id="Rmdir"/>
</seealso>
</element>

<element name="Move">
<short>Move data from one location in memory to another</short>
<descr>
<var>Move</var> moves <var>Count</var> bytes from <var>Source</var> to <var>Dest</var>.
</descr>
<errors>
If either <var>Dest</var> or <var>Source</var> is outside the accessible memory for
the process, then a run-time error will be generated.
</errors>
<seealso>
<link id="Fillword"/>
<link id="Fillchar"/>
</seealso>
<example file="refex/ex42"/>
</element>



<element name="MoveChar0">
<short>Move data till first zero character</short>
<descr>
<var>MoveChar0</var> moves <var>Count</var> bytes from <var>Src</var> to <var>Dest</var>, and
stops moving if a zero character is found.
</descr>
<errors>
No checking is done to see if <var>Count</var> stays within the memory allocated
to the process.
</errors>
<seealso>
<link id="Move"/>
</seealso>
<example file="refex/ex109"/>
</element>



<element name="New">
<short>Dynamically allocate memory for variable</short>
<descr>
<p>
<var>New</var> allocates a new instance of the type pointed to by <var>P</var>, and
puts the address in <var>P</var>.
If P is an object, then it is possible to
specify the name of the constructor with which the instance will be created.
</p>
<p>
For an example, see <link id="Dispose"/>.
</p>
</descr>
<errors>
If not enough memory is available, <var>Nil</var> will be returned.
</errors>
<seealso>
<link id="Dispose"/>
<link id="Freemem"/>
<link id="Getmem"/>
</seealso>
</element>

<element name="Odd">
<short>Is a value odd or even ?</short>
<descr>
<var>Odd</var> returns <var>True</var> if <var>X</var> is odd, or <var>False</var> otherwise.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Abs"/>
<link id="Ord"/>
</seealso>
<example file="refex/ex43"/>
</element>



<element name="OctStr">
<short>Convert integer to a string with octal representation.</short>
<descr>
<var>OctStr</var> returns a string with the octal representation
of <var>Value</var>. The string has exactly <var>cnt</var> charaters.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Str"/>
<link id="Val"/>
<link id="BinStr"/>
<link id="HexStr"/>
</seealso>
<example file="refex/ex112"/>
</element>



<element name="Ofs">
<short>Return offset of a variable.</short>
<descr>
<var>Ofs</var> returns the offset of the address of a variable.
This function is only supported for compatibility. In Free Pascal, it
returns always the complete address of the variable, since Free Pascal is a 32 bit
compiler.

</descr>
<errors>
None.
</errors>
<seealso>
<link id="DSeg"/>
<link id="CSeg"/>
<link id="Seg"/>
<link id="Ptr"/>
</seealso>
<example file="refex/ex44"/>
</element>



<element name="Ord">
<short>Return ordinal value of an ordinal type.</short>
<descr>
<var>Ord</var> returns the Ordinal value of a ordinal-type variable <var>X</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Chr"/>
<link id="Succ"/>
<link id="Pred"/>
<link id="High"/>
<link id="Low"/>
</seealso>
<example file="refex/ex45"/>
</element>



<element name="Paramcount">
<short>Return number of command-line parameters passed to the program.</short>
<descr>
<var>Paramcount</var> returns the number of command-line arguments. If no
arguments were given to the running program, <var>0</var> is returned.

</descr>
<errors>
None.
</errors>
<seealso>
<link id="Paramstr"/>
</seealso>
<example file="refex/ex46"/>
</element>



<element name="Paramstr">
<short>Return value of a command-line argument.</short>
<descr>
<p>
<var>Paramstr</var> returns the <var>L</var>-th command-line argument. <var>L</var> must
be between <var>0</var> and <var>Paramcount</var>, these values included.
The zeroth argument is the path and file name with which the program was
started.
</p>
<p>
The command-line parameters will be truncated to a length of 255,
even though the operating system may support bigger command-lines.
The <var>Objpas</var> unit (used in <var>objfpc</var> or <var>delphi</var> mode) define versions
of <var>Paramstr</var> which return the full-length command-line arguments.
</p>
<p>
When the complete command-line must be accessed, the <var>argv</var> pointer
should be used to retrieve the real values of the command-line parameters.
</p>
<p>
For an example, see <link id="Paramcount"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Paramcount"/>
</seealso>
</element>

<element name="Pi">
<short>Return the value of PI.</short>
<descr>
<var>Pi</var> returns the value of Pi (3.1415926535897932385).
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Cos"/>
<link id="Sin"/>
</seealso>
<example file="refex/ex47"/>
</element>



<element name="Pos">
<short>Search for substring in a string.</short>
<descr>
<var>Pos</var> returns the index of <var>Substr</var> in <var>S</var>, if <var>S</var> contains
<var>Substr</var>. In case <var>Substr</var> isn't found, <var>0</var> is returned.
The search is case-sensitive.
</descr>
<errors>
None
</errors>
<seealso>
<link id="Length"/>
<link id="Copy"/>
<link id="Delete"/>
<link id="Insert"/>
</seealso>
<example file="refex/ex48"/>
</element>



<element name="Power">
<short>Raise float to integer power</short>
<descr>
<p>
<var>Power</var> returns the value of <var>base</var> to the power <var>expon</var>.
<var>Base</var> and <var>expon</var> can be of type Longint, in which case the
result will also be a Longint.
</p>
<p>
The function actually returns <var>Exp(expon*Ln(base))</var>
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Exp"/>
<link id="Ln"/>
</seealso>
<example file="refex/ex78"/>
</element>



<element name="Pred">
<short>Return previous element for an ordinal type.</short>
<descr>
<p>
<var>Pred</var> returns the element that precedes the element that was passed
to it. If it is applied to the first value of the ordinal type, and the
program was compiled with range checking on (\var{\{\$R+\}}, then a run-time
error will be generated.
</p>
<p>
for an example, see <link id="Ord"/>
</p>
</descr>
<errors>
Run-time error 201 is generated when the result is out of
range.
</errors>
<seealso>
<link id="Ord"/>
<link id="Pred"/>
<link id="High"/>
<link id="Low"/>
</seealso>
</element>


<element name="Ptr">
<short>Combine segment and offset to pointer</short>
<descr>
<p>
<var>Ptr</var> returns a pointer, pointing to the address specified by
segment <var>Sel</var> and offset <var>Off</var>.
</p>
<remark>
<ol>
<li> In the 32-bit flat-memory model supported by Free Pascal, this
function is obsolete.
</li>
<li> The returned address is simply the offset.
</li>
</ol>
</remark>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Addr"/>
</seealso>
<example file="refex/ex59"/>
</element>



<element name="Random">
<short>Generate random number</short>
<descr>
<var>Random</var> returns a random number larger or equal to <var>0</var> and
strictly less than <var>L</var>.
If the argument <var>L</var> is omitted, a Real number between 0 and 1 is returned.
(0 included, 1 excluded)
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Randomize"/>
</seealso>
<example file="refex/ex49"/>
</element>



<element name="Randomize">
<short>Initialize random number generator</short>
<descr>
<p>
<var>Randomize</var> initializes the random number generator of Free Pascal, by giving
a value to <var>Randseed</var>, calculated with the system clock.
</p>
<p>
For an example, see <link id="Random"/>.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Random"/>
</seealso>
</element>

<element name="Read">
<short>Read from a text file into variable</short>
<descr>
<var>Read</var> reads one or more values from a file <var>F</var>, and stores the
result in <var>V1</var>, <var>V2</var>, etc.; If no file <var>F</var> is specified, then
standard input is read.
If <var>F</var> is of type <var>Text</var>, then the variables <var>V1, V2</var> etc. must be
of type <var>Char</var>, <var>Integer</var>, <var>Real</var>, <var>String</var> or <var>PChar</var>.
If <var>F</var> is a typed file, then each of the variables must be of the type
specified in the declaration of <var>F</var>. Untyped files are not allowed as an
argument.
</descr>
<errors>
If no data is available, a run-time error is generated. This behavior can
be controlled with the \var{\{\$i\}} compiler switch.
</errors>
<seealso>
<link id="Readln"/>
<link id="Blockread"/>
<link id="Write"/>
<link id="Blockwrite"/>
</seealso>
<example file="refex/ex50"/>
</element>



<element name="Readln">
<short>Read from a text file into variable and goto next line</short>
<descr>
<p>
<var>Read</var> reads one or more values from a file <var>F</var>, and stores the
result in <var>V1</var>, <var>V2</var>, etc. After that it goes to the next line in
the file. The end of the line is marked by the <var>LineEnding</var>
character sequence (which is platform dependent). The end-of-line marker is
not considered part of the line and is ignored.
</p>
<p>
If no file <var>F</var> is specified, then standard input is read.
The variables <var>V1, V2</var> etc. must be of type <var>Char</var>, <var>Integer</var>,
<var>Real</var>, <var>String</var> or <var>PChar</var>.
</p>
<p>
For an example, see <link id="Read"/>.
</p>
</descr>
<errors>
If no data is available, a run-time error is generated. This behavior can
be controlled with the \var{\{\$i\}} compiler switch.
</errors>
<seealso>
<link id="Read"/>
<link id="Blockread"/>
<link id="Write"/>
<link id="Blockwrite"/>
</seealso>
</element>


<element name="Real2Double">
<short>Convert Turbo Pascal style real to double.</short>
<descr>
<p>
The <var>Real2Double</var> function converts a Turbo Pascal style real (6 bytes long) to
a native Free Pascal double type. It can be used e.g. to read old binary TP files with
FPC and convert them to Free Pacal binary files.
</p>
<p>
Note that the assignment operator has been overloaded so a <var>Real48</var> type
can be assigned directly to a double or extended.
</p>
</descr>
<errors>
None.
</errors>
<seealso></seealso>
<example file="refex/ex110"/>
</element>



<element name="Rename">
<short>Rename file on disk</short>
<descr>
<var>Rename</var> changes the name of the assigned file <var>F</var> to <var>S</var>.
<var>F</var>
must be assigned, but not opened.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Erase"/>
</seealso>
<example file="refex/ex77"/>
</element>



<element name="Reset">
<short>Open file for reading</short>
<descr>
<var>Reset</var> opens a file <var>F</var> for reading. <var>F</var> can be any file type.
If <var>F</var> is a text file, or refers to standard I/O (e.g : '') then it is 
opened read-only, otherwise it is opened using the mode specified in 
<var>filemode</var>.

If <var>F</var> is an untyped file, the record size can be specified in
the optional parameter <var>L</var>. A default value of 128 is used.

File sharing is not taken into account when calling <var>Reset</var>.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Rewrite"/>
<link id="Assign"/>
<link id="Close"/>
<link id="Append"/>
</seealso>
<example file="refex/ex51"/>
</element>



<element name="Rewrite">
<short>Open file for writing</short>
<descr>
<var>Rewrite</var> opens a file <var>F</var> for writing. <var>F</var> can be any file type.
If <var>F</var> is an untyped or typed file, then it is opened for reading and
writing. If <var>F</var> is an untyped file, the record size can be specified in
the optional parameter <var>L</var>. Default a value of 128 is used.
if <var>Rewrite</var> finds a file with the same name as <var>F</var>, this file is
truncated to length <var>0</var>. If it doesn't find such a file, a new file is
created.

Contrary to Turbo Pascal, Free Pascal opens the file with mode <var>fmoutput</var>. If it should
be opened in <var>fminout</var> mode, an extra call to <link id="Reset"/> is needed.

File sharing is not taken into account when calling <var>Rewrite</var>.

</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Reset"/>
<link id="Assign"/>
<link id="Close"/>
<link id="Flush"/>
<link id="Append"/>
</seealso>
<example file="refex/ex52"/>
</element>



<element name="Rmdir">
<short>Remove directory when empty.</short>
<descr>
<var>Rmdir</var> removes the directory <var>S</var>.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Chdir"/>
<link id="Mkdir"/>
</seealso>
<example file="refex/ex53"/>
</element>



<element name="Round">
<short>Round floating point value to nearest integer number.</short>
<descr>
<var>Round</var> rounds <var>X</var> to the closest integer, which may be bigger or
smaller than <var>X</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Frac"/>
<link id="Int"/>
<link id="Trunc"/>
</seealso>
<example file="refex/ex54"/>
</element>



<element name="Runerror">
<short>Generate a run-time error.</short>
<descr>
<var>Runerror</var> stops the execution of the program, and generates a
run-time error <var>ErrorCode</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Exit"/>
<link id="Halt"/>
</seealso>
<example file="refex/ex55"/>
</element>



<element name="Seek">
<short>Set file position</short>
<descr>
<var>Seek</var> sets the file-pointer for file <var>F</var> to record Nr. <var>Count</var>.
The first record in a file has <var>Count=0</var>. F can be any file type, except
<var>Text</var>. If <var>F</var> is an untyped file, with no record size specified in
<link id="Reset"/> or <link id="Rewrite"/>, 128 is assumed.
</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Eof"/>
<link id="SeekEof"/>
<link id="SeekEoln"/>
</seealso>
<example file="refex/ex56"/>
</element>



<element name="SeekEof">
<short>Set file position to end of file</short>
<descr>
<var>SeekEof</var> returns <var>True</var> is the file-pointer is at the end of the
file. It ignores all whitespace.
Calling this function has the effect that the file-position is advanced
until the first non-whitespace character or the end-of-file marker is
reached.
If the end-of-file marker is reached, <var>True</var> is returned. Otherwise,
False is returned.
If the parameter <var>F</var> is omitted, standard <var>Input</var> is assumed.

</descr>
<errors>
A run-time error is generated if the file <var>F</var> isn't opened.
</errors>
<seealso>
<link id="Eof"/>
<link id="SeekEoln"/>
<link id="Seek"/>
</seealso>
<example file="refex/ex57"/>
</element>



<element name="SeekEoln">
<short>Set file position to end of line</short>
<descr>
<var>SeekEoln</var> returns <var>True</var> is the file-pointer is at the end of the
current line. It ignores all whitespace.
Calling this function has the effect that the file-position is advanced
until the first non-whitespace character or the end-of-line marker is
reached.
If the end-of-line marker is reached, <var>True</var> is returned. Otherwise,
False is returned.
The end-of-line marker is defined as <var>#10</var>, the LineFeed character.
If the parameter <var>F</var> is omitted, standard <var>Input</var> is assumed.
</descr>
<errors>
A run-time error is generated if the file <var>F</var> isn't opened.
</errors>
<seealso>
<link id="Eof"/>
<link id="SeekEof"/>
<link id="Seek"/>
</seealso>
<example file="refex/ex58"/>
</element>



<element name="Seg">
<short>Return segment</short>
<descr>
<var>Seg</var> returns the segment of the address of a variable.
This function is only supported for compatibility. In Free Pascal, it
returns always 0, since Free Pascal is a 32 bit compiler, segments have no meaning.

</descr>
<errors>
None.
</errors>
<seealso>
<link id="DSeg"/>
<link id="CSeg"/>
<link id="Ofs"/>
<link id="Ptr"/>
</seealso>
<example file="refex/ex60"/>
</element>



<element name="SetMemoryManager">
<short>Set a memory manager</short>
<descr>
<p>
<var>SetMemoryManager</var> sets the current memory manager record to
<var>MemMgr</var>.
</p>
<p>
For an example, see \progref.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="GetMemoryManager"/>
<link id="IsMemoryManagerSet"/>
</seealso>
</element>


<element name="SetJmp">
<short>Save current execution point.</short>
<descr>
<var>SetJmp</var> fills <var>env</var> with the necessary data for a jump back to the
point where it was called. It returns zero if called in this way.
If the function returns nonzero, then it means that a call to <link id="LongJmp"/>
with <var>env</var> as an argument was made somewhere in the program.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="LongJmp"/>
</seealso>
<example file="refex/ex79"/>
</element>




<element name="SetLength">
<short>Set length of a string.</short>
<descr>
<var>SetLength</var> sets the length of the string <var>S</var> to <var>Len</var>. <var>S</var>
can be an ansistring, a short string or a widestring.
For <var>ShortStrings</var>, <var>Len</var> can maximally be 255. For <var>AnsiStrings</var>
it can have any value. For <var>AnsiString</var> strings, <var>SetLength</var> {\em
must} be used to set the length of the string.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Length"/>
</seealso>
<example file="refex/ex85"/>
</element>



<element name="SetString">
<short>Set length of a string and copy buffer.</short>
<descr>
<var>SetString</var> sets the length of the string <var>S</var> to <var>Len</var> and
if <var>Buf</var> is non-nil, copies <var>Len</var> characters from <var>Buf</var> 
into <var>S</var>.  <var>S</var> can be an ansistring, a short string or a widestring.
For <var>ShortStrings</var>, <var>Len</var> can maximally be 255. 
</descr>
<errors>
None.
</errors>
<seealso>
<link id="SetLength"/>
</seealso>
</element>



<element name="SetTextBuf">
<short>Set size of text file internal buffer</short>
<descr>
<p>
<var>SetTextBuf</var> assigns an I/O buffer to a text file. The new buffer is
located at <var>Buf</var> and is <var>Size</var> bytes long. If <var>Size</var> is omitted,
then <var>SizeOf(Buf)</var> is assumed.
The standard buffer of any text file is 128 bytes long. For heavy I/O
operations this may prove too slow. The <var>SetTextBuf</var> procedure allows
to set a bigger buffer for the IO of the application, thus reducing the number of
system calls, and thus reducing the load on the system resources.
The maximum size of the newly assigned buffer is 65355 bytes.
</p>
<remark>
<ul>
<li> Never assign a new buffer to an opened file. A
new buffer can be assigned immediately after a call to <link id="Rewrite"/>
<link id="Reset"/> or
<var>Append</var>, but not after the file was read from/written to. This may cause
loss of data. If a new buffer must be assigned after read/write
operations have been performed, the file should be flushed first.
This will ensure that the current buffer is emptied.
</li>
<li> Take care that the assigned buffer is always valid. If a local variable is
assigned as a buffer, then after the program exits the local program block,
the buffer will no longer be valid, and stack problems may occur.
</li>
</ul>
</remark>
</descr>
<errors>
No checking on <var>Size</var> is done.
</errors>
<seealso>
<link id="Assign"/>
<link id="Reset"/>
<link id="Rewrite"/>
<link id="Append"/>
</seealso>
<example file="refex/ex61"/>
</element>



<element name="Sin">
<short>Calculate sine of angle</short>
<descr>
<var>Sin</var> returns the sine of its argument <var>X</var>, where <var>X</var> is an
angle in radians.

If the absolute value of the argument is larger than \var{2\^{}63}, then the
result is undefined.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Cos"/>
<link id="Pi"/>
<link id="Exp"/>
<link id="Ln"/>
</seealso>
<example file="refex/ex62"/>
</element>



<element name="SizeOf">
<short>Return size of a variable or type.</short>
<descr>
<p>
<var>SizeOf</var> returns the size, in bytes, of any variable or type-identifier.
</p>
<remark>
This isn't really a RTL function. Its result is calculated at
compile-time, and hard-coded in the executable.
</remark>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Addr"/>
</seealso>
<example file="refex/ex63"/>
</element>



<element name="Sptr">
<short>Return current stack pointer</short>
<descr>
<var>Sptr</var> returns the current stack pointer.

</descr>
<errors>
None.
</errors>
<seealso>
<link id="SSeg"/>
</seealso>
<example file="refex/ex64"/>
</element>



<element name="Sqr">
<short>Calculate the square of a value.</short>
<descr>
<var>Sqr</var> returns the square of its argument <var>X</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Sqrt"/>
<link id="Ln"/>
<link id="Exp"/>
</seealso>
<example file="refex/ex65"/>
</element>



<element name="Sqrt">
<short>Calculate the square root of a value</short>
<descr>
<var>Sqrt</var> returns the square root of its argument <var>X</var>, which must be
positive.
</descr>
<errors>
If <var>X</var> is negative, then a run-time error is generated.
</errors>
<seealso>
<link id="Sqr"/>
<link id="Ln"/>
<link id="Exp"/>
</seealso>
<example file="refex/ex66"/>
</element>



<element name="SSeg">
<short>Return stack segment register value.</short>
<descr>
 <var>SSeg</var> returns the Stack Segment. This function is only
 supported for compatibility reasons, as <var>Sptr</var> returns the
correct contents of the stackpointer.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Sptr"/>
</seealso>
<example file="refex/ex67"/>
</element>



<element name="Str">
<short>Convert a numerical value to a string.</short>
<descr>
<var>Str</var> returns a string which represents the value of X. X can be any
numerical type.
The optional <var>NumPLaces</var> and <var>Decimals</var> specifiers control the
formatting of the string.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Val"/>
</seealso>
<example file="refex/ex68"/>
</element>



<element name="StringOfChar">
<short>Return a string consisting of 1 character repeated N times.</short>
<descr>
<p>
<var>StringOfChar</var> creates a new String of length <var>l</var> and fills
it with the character <var>c</var>.
</p>
<p>
It is equivalent to  the following calls:
</p>
<code>
SetLength(StringOfChar,l);
FillChar(Pointer(StringOfChar)^,Length(StringOfChar),c);
</code>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="SetLength"/>
</seealso>
<example file="refex/ex97"/>
</element>



<element name="Succ">
<short>Return next element of ordinal type.</short>
<descr>
<p>
<var>Succ</var> returns the element that succeeds the element that was passed
to it. If it is applied to the last value of the ordinal type, and the
program was compiled with range checking on (\var{\{\$R+\}}), then a run-time
error will be generated.
</p>
<p>
for an example, see <link id="Ord"/>.
</p>
</descr>
<errors>
Run-time error 201 is generated when the result is out of
range.
</errors>
<seealso>
<link id="Ord"/>
<link id="Pred"/>
<link id="High"/>
<link id="Low"/>
</seealso>
</element>

<element name="Swap">
<short>Swap high and low bytes/words of a variable</short>
<descr>
<var>Swap</var> swaps the high and low order bytes of <var>X</var> if <var>X</var> is of
type <var>Word</var> or <var>Integer</var>, or swaps the high and low order words of
<var>X</var> if <var>X</var> is of type <var>Longint</var> or <var>Cardinal</var>.
The return type is the type of <var>X</var>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Lo"/>
<link id="Hi"/>
</seealso>
<example file="refex/ex69"/>
</element>



<element name="Trunc">
<short>Truncate a floating point value.</short>
<descr>
<var>Trunc</var> returns the integer part of <var>X</var>,
which is always smaller than (or equal to) <var>X</var> in absolute value.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Frac"/>
<link id="Int"/>
<link id="Round"/>
</seealso>
<example file="refex/ex70"/>
</element>



<element name="Truncate">
<short>Truncate the file at position</short>
<descr>
<var>Truncate</var> truncates the (opened) file <var>F</var> at the current file
position.

</descr>
<errors>
Depending on the state of the \var{\{\$I\}} switch, a runtime error can be 
generated if there is an error. In the \var{\{\$I-\}} state, use <var>IOResult</var>
to check for errors.
</errors>
<seealso>
<link id="Append"/>
<link id="Filepos"/>,
<link id="Seek"/>
</seealso>
<example file="refex/ex71"/>
</element>



<element name="Upcase">
<short>Convert a string to all uppercase.</short>
<descr>
<var>Upcase</var> returns the uppercase version of its argument <var>C</var>.
If its argument is a string, then the complete string is converted to
uppercase. The type of the returned value is the same as the type of the
argument.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="Lowercase"/>
</seealso>
<example file="refex/ex72"/>
</element>



<element name="Val">
<short>Calculate numerical value of a string.</short>
<descr>
<var>Val</var> converts the value represented in the string <var>S</var> to a numerical
value, and stores this value in the variable <var>V</var>, which
can be of type <var>Longint</var>, <var>Real</var> and <var>Byte</var>.
If the conversion isn't succesfull, then the parameter <var>Code</var> contains
the index of the character in <var>S</var> which prevented the conversion.
The string <var>S</var> is allowed to contain spaces in the beginning.

The string <var>S</var> can contain a number in decimal, hexadecimal, binary
or octal format, as described in the language reference.

</descr>
<errors>
If the conversion doesn't succeed, the value of <var>Code</var> indicates the
position where the conversion went wrong.
</errors>
<seealso>
<link id="Str"/>
</seealso>
<example file="refex/ex74"/>
</element>



<element name="Write">
<short>Write variable to a text file</short>
<descr>
<var>Write</var> writes the contents of the variables <var>V1</var>, <var>V2</var> etc. to
the file <var>F</var>. <var>F</var> can be a typed file, or a <var>Text</var> file.
If <var>F</var> is a typed file, then the variables <var>V1</var>, <var>V2</var> etc. must
be of the same type as the type in the declaration of <var>F</var>. Untyped files
are not allowed.
If the parameter <var>F</var> is omitted, standard output is assumed.
If <var>F</var> is of type <var>Text</var>, then the necessary conversions are done
such that the output of the variables is in human-readable format.
This conversion is done for all numerical types. Strings are printed exactly
as they are in memory, as well as <var>PChar</var> types.
The format of the numerical conversions can be influenced through
the following modifiers:
<var> OutputVariable : NumChars [: Decimals ]  </var>
This will print the value of <var>OutputVariable</var> with a minimum of
<var>NumChars</var> characters, from which <var>Decimals</var> are reserved for the
decimals. If the number cannot be represented with <var>NumChars</var> characters,
<var>NumChars</var> will be increased, until the representation fits. If the
representation requires less than <var>NumChars</var> characters then the output
is filled up with spaces, to the left of the generated string, thus
resulting in a right-aligned representation.
If no formatting is specified, then the number is written using its natural
length, with nothing in front of it if it's positive, and a minus sign if
it's negative.
Real numbers are, by default, written in scientific notation.
</descr>
<errors>
If an error occurs, a run-time error is generated. This behavior can be
controlled with the \var{\{\$i\}} switch.
</errors>
<seealso>
<link id="WriteLn"/>
<link id="Read"/>
<link id="Readln"/>
<link id="Blockwrite"/>
</seealso>
</element>

<element name="WriteLn">
<short>Write variable to a text file and append newline</short>
<descr>
<p>
<var>WriteLn</var> does the same as <link id="Write"/> for text files, and emits a
Carriage Return - LineFeed character pair after that.
If the parameter <var>F</var> is omitted, standard output is assumed.
If no variables are specified, a Carriage Return - LineFeed character pair
is emitted, resulting in a new line in the file <var>F</var>.
</p>
<remark>
Under linux and unix, the Carriage Return character is omitted, as
customary in Unix environments.
</remark>
</descr>
<errors>
If an error occurs, a run-time error is generated. This behavior can be
controlled with the \var{\{\$i\}} switch.
</errors>
<seealso>
<link id="Write"/>
<link id="Read"/>
<link id="Readln"/>
<link id="Blockwrite"/>
</seealso>
<example file="refex/ex75"/>
</element>

<!-- range type Visibility: default -->
<element name="ShortInt">
<short>A signed 8-bits integer</short>
</element>

<!-- range type Visibility: default -->
<element name="SmallInt">
<short>A signed 16-bits integer</short>
</element>

<!-- range type Visibility: default -->
<element name="Longint">
<short>A signed 32-bits integer</short>
</element>

<!-- range type Visibility: default -->
<element name="Byte">
<short>An unsigned 8-bits integer</short>
</element>

<!-- range type Visibility: default -->
<element name="Word">
<short>An unsigned 16-bits integer</short>
</element>

<!-- alias type Visibility: default -->
<element name="DWord">
<short>An unsigned 32-bits integer</short>
</element>

<!-- alias type Visibility: default -->
<element name="Cardinal">
<short>An unsigned 32-bits integer.</short>
</element>

<!-- alias type Visibility: default -->
<element name="Integer">
<short>A signed 16-bits integer</short>
<descr>
The system unit defines <var>Integer</var> as a signed 16-bit integer.
But when <var>DELPHI</var> or <var>OBJFPC</var> mode are active, then
the <file>objpas</file> unit redefines <var>Integer</var> as a 16-bit
integer.
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="PChar">
<short>Pointer to null-terminated string.</short>
<descr>
Or the same as a pointer to an array of char. See the reference manual for
more information about this type.
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="PPChar">
<short>Pointer to an array of pointers to null-terminated strings.</short>
</element>

<!-- alias type Visibility: default -->
<element name="TAnsiChar">
<short>Alias for 1-byte sized char.</short>
</element>

<!-- alias type Visibility: default -->
<element name="AnsiChar">
<short>Alias for 1-byte sized char.</short>
</element>

<!-- alias type Visibility: default -->
<element name="PAnsiChar">
<short>Alias for <link id="PChar"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="PPAnsiChar">
<short>Alias for <link id="PPChar"/> type.</short>
</element>

<!-- "type" alias type Visibility: default -->
<element name="UCS4Char">
<short>UCS unicode character (unsigned 32 bit word)</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PUCS4Char">
<short>Pointer to <link id="UCS4Char"/></short>
</element>

<!-- array type Visibility: default -->
<element name="TUCS4CharArray">
<short>Array of <link id="UCS4Char"/> characters.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PUCS4CharArray">
<short>Pointer to array of <link id="UCS4Char"/> characters.</short>
</element>

<!-- array type Visibility: default -->
<element name="UCS4String">
<short>String of <link id="UCS4Char"/> characters.</short>
</element>

<!-- "type" alias type Visibility: default -->
<element name="UTF8String">
<short>UTF-8 unicode (ansi) string.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PUTF8String">
<short>Pointer to <link id="UTF8String"/></short>
</element>

<!-- alias type Visibility: default -->
<element name="Currency">
<short>Currency type.</short>
</element>

<!-- "type" alias type Visibility: default -->
<element name="HRESULT">
<short>32-Bit signed integer.</short>
</element>

<!-- "type" alias type Visibility: default -->
<element name="TDateTime">
<short>Encoded Date-Time type.</short>
</element>

<!-- "type" alias type Visibility: default -->
<element name="Error">
<short>32-bit signed integer.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PSingle">
<short>Pointer to single-sized float value.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PDouble">
<short>Pointer to double-sized float value.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PCurrency">
<short>Pointer to currency type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PExtended">
<short>Pointer to extended-sized float value.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PSmallInt">
<short>Pointer to <link id="smallint"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PShortInt">
<short>Pointer to <link id="shortint"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PInteger">
<short>Pointer to <link id="integer"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PByte">
<short>Pointer to <link id="byte"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PWord">
<short>Pointer to <link id="word"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PDWord">
<short>Pointer to <link id="DWord"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PLongWord">
<short>Pointer to <var>LongWord</var> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PLongint">
<short>Pointer to <link id="Longint"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PCardinal">
<short>Pointer to <link id="Cardinal"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PQWord">
<short>Pointer to <var>QWord</var> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PInt64">
<short>Pointer to <var>Int64</var> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPtrInt">
<short>Pointer to <link id="PtrInt"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PSizeInt">
<short>Pointer to a <link id="SizeInt"/> type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPointer">
<short>Pointer to a pointer type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPPointer">
<short>Pointer to a <link id="PPointer"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PBoolean">
<short>Pointer to a Boolean type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PWordBool">
<short>Pointer to a <var>WordBool</var> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PLongBool">
<short>Pointer to a <var>LongBool</var> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PShortString">
<short>Pointer to a shortstring type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PAnsiString">
<short>Pointer to an ansistring type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PDate">
<short>Pointer to a <link id="TDateTime"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PError">
<short>Pointer to an <link id="Error"/> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="WChar">
<short>Wide char (16-bit sized char)</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TTextLineBreakStyle">
<short>Text line break style. (end of line character)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTextLineBreakStyle.tlbsLF">
<short>Line-feed only (#10, unix style)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTextLineBreakStyle.tlbsCRLF">
<short>Carriage-return, line-feed (#13#30, Windows style)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTextLineBreakStyle.tlbsCR">
<short>Carriage-return (#13, Mac-OS style)</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TProcedure">
<short>Simple procedural type.</short>
</element>

<!-- constant Visibility: default -->
<element name="MaxSIntValue">
<short>Maximum String-size value.</short>
</element>

<!-- constant Visibility: default -->
<element name="MaxUIntValue">
<short>Maximum unsigned integer value.</short>
</element>

<!-- constant Visibility: default -->
<element name="maxLongint">
<short>Maximum longint value.</short>
</element>

<!-- constant Visibility: default -->
<element name="maxSmallint">
<short>Maximum smallint value.</short>
</element>

<!-- constant Visibility: default -->
<element name="maxint">
<short>Maximum integer value.</short>
</element>

<!-- array type Visibility: default -->
<element name="IntegerArray">
<short>Generic array of integer. </short>
</element>

<!-- pointer type Visibility: default -->
<element name="PIntegerArray">
<short>Pointer to <link id="IntegerArray"/> type</short>
</element>

<!-- array type Visibility: default -->
<element name="PointerArray">
<short>Generic pointer array.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPointerArray">
<short>Pointer to <link id="PointerArray"/> type</short>
</element>

<!-- array type Visibility: default -->
<element name="TBoundArray">
<short>Dynamic array of integer.</short>
</element>

<!-- array type Visibility: default -->
<element name="TPCharArray">
<short>Array of PChar</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPCharArray">
<short>Pointer to <link id="TPCharArray"/> type.</short>
</element>

<!-- constant Visibility: default -->
<element name="Max_Frame_Dump">
<short>Maximum number of frames to show in error frame dump.</short>
</element>

<!-- constant Visibility: default -->
<element name="ExitProc">
<short>Exit procedure pointer.</short>
</element>

<!-- constant Visibility: default -->
<element name="Erroraddr">
<short>Address where the last error occurred.</short>
</element>

<!-- constant Visibility: default -->
<element name="Errorcode">
<short>Last error code.</short>
</element>

<!-- constant Visibility: default -->
<element name="fmClosed">
<short>File mode: File is closed.</short>
</element>

<!-- constant Visibility: default -->
<element name="fmInput">
<short>File mode: File is open for reading.</short>
</element>

<!-- constant Visibility: default -->
<element name="fmOutput">
<short>File mode: File is open for writing.</short>
</element>

<!-- constant Visibility: default -->
<element name="fmInOut">
<short>File mode: File is open for reading and writing.</short>
</element>

<!-- constant Visibility: default -->
<element name="fmAppend">
<short>File mode: File is open for writing, appending to the end.</short>
</element>

<!-- constant Visibility: default -->
<element name="ProcessID">
<short>Current process ID.</short>
</element>

<!-- constant Visibility: default -->
<element name="Filemode">
<short>Default file mode for untyped files.</short>
</element>

<!-- constant Visibility: default -->
<element name="CmdLine">
<short>Current command-line.</short>
</element>

<!-- constant Visibility: default -->
<element name="IsMultiThread">
<short>Indicates whether more than one thread is running in the application.</short>
</element>

<!-- constant Visibility: default -->
<element name="StackError">
<short>Indicate whether there was a stack error.</short>
</element>

<!-- variable Visibility: default -->
<element name="ExitCode">
<short>Exit code for the program, will be communicated to the OS on exit.</short>
</element>

<!-- variable Visibility: default -->
<element name="RandSeed">
<short>Seed for <link id="Random"/> function.</short>
</element>

<!-- variable Visibility: default -->
<element name="IsLibrary">
<short><var>True</var> if the current module is a library. Otherwise module
is an excutable</short>
</element>

<!-- variable Visibility: default -->
<element name="IsConsole">
<short><var>True</var> for console applications, <var>False</var> for GUI applications.</short>
</element>

<!-- variable Visibility: default -->
<element name="fpc_threadvar_relocate_proc" skip="1">
</element>

<!-- variable Visibility: default -->
<element name="ThreadID">
<short>Current Thread ID.</short>
</element>

<!-- variable Visibility: default -->
<element name="Output">
<short>Standard output text file.</short>
</element>

<!-- variable Visibility: default -->
<element name="Input">
<short>Standard input text file.</short>
</element>

<!-- variable Visibility: default -->
<element name="StdOut">
<short>Alias for <link id="Output"/>.</short>
</element>

<!-- variable Visibility: default -->
<element name="StdErr">
<short>Standard diagnostic output text file.</short>
</element>

<!-- variable Visibility: default -->
<element name="InOutRes">
<short>Result of last I/O operation. Read-Only.</short>
</element>

<!-- variable Visibility: default -->
<element name="StackBottom">
<short>Current stack bottom.</short>
</element>

<!-- variable Visibility: default -->
<element name="StackLength">
<short>Maximum stack length.</short>
</element>

<!-- function Visibility: default -->
<element name="IndexChar0">
<short>Return index of a character in null-terminated array of char.</short>
<descr> 
<var>IndexChar0</var> returns the index of the character <var>b</var> in the
null-terminated array <var>Buf</var>. At most <var>len</var> characters will
be searched, or the null character if it is encountered first. If the
character is not found, 0 is returned.
</descr>
<errors>
On error, 0 is returned.
</errors>
<seealso>
<link id="IndexByte"/>
<link id="IndexChar"/>
<link id="IndexWord"/>
<link id="IndexDWord"/>
<link id="CompareChar0"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="CompareChar0">
<short>Compare two buffers character by character till a null-character is reached.</short>
<descr>
<p>
<var>CompareChar0</var> compares 2 buffers <var>buf1</var> and <var>buf2</var>
for a maximum length of <var>len</var> or till a null character is reached
in either buffer. The result depends on the contents of the buffers:
</p>
<dl>
<dt>&lt; 0</dt><dd>If <var>buf1</var> contains a character less than the
corresponding character in <var>buf2</var>.</dd>
<dt>0</dt><dd>If both buffers are equal</dd>
<dt>&gt; 0</dt><dd>If <var>buf1</var> contains a character greater than the
corresponding character in <var>buf2</var>.</dd>
</dl>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="CompareByte"/>
<link id="CompareChar"/>
<link id="CompareDWord"/>
<link id="CompareWord"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="prefetch">
<short>Prefetch a memory location</short>
<descr>
<var>Prefetch</var> can be used to optimize the CPU behaviour by already
loading a memory location. It is mainly used as a hint for those processors
that support it.
</descr>
<errors>
None.
</errors>
</element>

<!-- array type Visibility: default -->
<element name="real48">
<short>TP compatible real type (6 bytes) definition</short>
</element>

<!-- function Visibility: default -->
<element name="strpas">
<short>Convert a null-terminated string to a shortstring.</short>
<descr>
Converts a null terminated string in <var>P</var> to a Pascal string, and
returns
this string. The string is truncated at 255 characters.
</descr>
<errors>
None.
</errors>
</element>

<!-- function Visibility: default -->
<element name="strlen">
<short>Length of a null-terminated string.</short>
<descr>
Returns the length of the null-terminated string <var>P</var>.
</descr>
<errors>
None.
</errors>
</element>

<!-- function Visibility: default -->
<element name="Space">
<short>Return a string of spaces</short>
<descr>
<var>Space</var> returns a shortstring with length <var>B</var>, consisting
of spaces.
</descr>
<seealso>
<link id="StringOfChar"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="UniqueString">
<short>Make sure reference count of string is 1</short>
<descr>
<var>UniqueString</var> ensures that the ansistring <var>S</var> has
reference count 1. It makes a copy of <var>S</var> if this is necesary, and
returns the copy in <var>S</var>
</descr>
<errors>
None.
</errors>
</element>

<!-- procedure Visibility: default -->
<element name="SetTextLineEnding">
<short>Set the end-of-line character for the given text file.</short>
<descr>
<var>SetTextLineEnding</var> sets the end-of-line character for the text
file <var>F</var> to <var>Ending</var>. By default, this is the string
indicated by <link id="DefaultTextLineBreakStyle"/>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="DefaultTextLineBreakStyle"/>
<link id="TTextLineBreakStyle"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="get_frame">
<short>Return the current frame</short>
<descr>
<var>get_frame</var> returns a pointer to the current stack frame.
</descr>
<seealso>
<link id="get_caller_addr"/>
<link id="get_caller_frame"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="get_caller_addr">
<short>Return the address of the caller.</short>
<descr>
<var>get_caller_frame</var> returns a pointer to address ( the return
address)  of the caller  of the routine which has as frame <var>framebp</var>.
</descr>
<seealso>
<link id="get_frame"/>
<link id="get_caller_frame"/>
<link id="Dump_Stack"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="get_caller_frame">
<short>Return the frame pointer of the caller</short>
<descr>
<var>get_caller_frame</var> returns a pointer to the frame of the caller 
of the routine which has as frame <var>framebp</var>.
</descr>
<seealso>
<link id="get_caller_addr"/>
<link id="get_frame"/>
<link id="Dump_Stack"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="Dump_Stack">
<short>Dump stack to the given text file.</short>
<descr>
<var>Dump_Stack</var> prints a stack dump to the file <var>f</var>, with
base frame pointer <var>bp</var>
</descr>
<errors>
The file <var>f</var> must be opened for writing or an error will occur.
</errors>
<seealso>
<link id="get_caller_addr"/>
<link id="get_caller_frame"/>
<link id="get_frame"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="AddExitProc">
<short>Add an exit procedure to the exit procedure chain.</short>
<descr>
<var>AddExitProc</var> adds <var>Proc</var> to the exit procedure chain. At
program exit, all procedures added in this way will be called in reverse
order.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="ExitProc"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SysInitExceptions">
<short>Initialize exceptions.</short>
<descr>
<var>SysInitExceptions</var> initializes the exception system. This
procedure should never be called directly, it is taken care of by the RTL.
</descr>
</element>

<!-- procedure Visibility: default -->
<element name="SysInitStdIO">
<short>Initialize standard input and output.</short>
<descr>
<var>SysInitStdIO</var> initializes the standard input and output files:
<link id="Output"/>, <link id="Input"/> and <link id="StdErr"/>. This
routine is called by the initialization code of the system unit, there
should be no need to call it directly.
</descr>
</element>

<!-- procedure Visibility: default -->
<element name="SysResetFPU">
<short>Reset the floating point unit.</short>
<descr>
<var>SysResetFPU</var> resets the floating point unit. There should normally
be no need to call this unit; the compiler itself takes care of this.
</descr>
</element>

<!-- procedure Visibility: default -->
<element name="AbstractError">
<short>Generate an abstract error.</short>
<descr>
<var>AbstractError</var> generates an abstract error (run-time error 211).
If the <link id="AbstractErrorProc"/> constant is set, it will be called
instead.
</descr>
<errors>
This routine causes a run-time error 211.
</errors>
<seealso>
<link id="AbstractErrorProc"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysBackTraceStr">
<short>Format an address suitable for inclusion in a backtrace</short>
<descr>
<var>SysBackTraceStr</var> will create a string representation of the 
address <var>Addr</var>, suitable for inclusion in a stack backtrace.
</descr>
<errors>
None.
</errors>
</element>

<!-- procedure Visibility: default -->
<element name="SysAssert">
<short>Standard Assert failure implementation</short>
<descr>
<var>SysAssert</var> is the standard implementation of the assertion failed
code. It is the default value of the <var>AssertErrorProc</var> constant.
It will print the assert message <var>Msg</var> together with the filename
<var>FName</var> and linenumber <var>LineNo</var> to standard error output
(<var>StdErr</var>) and will halt the program with exit code 227.
The error address <var>ErrorAddr</var> is ignored.
</descr>
<seealso>
<link id="AssertErrorProc"/>
</seealso>
</element>

<!-- function type Visibility: default -->
<element name="TBackTraceStrFunc">
<short>Type for formatting of backtrace dump.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TErrorProc">
<short>Standard error handler procedural type.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TAbstractErrorProc">
<short>Abstract error handler procedural type.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="TAssertErrorProc">
<short>Assert error handler procedural type.</short>
</element>

<!-- constant Visibility: default -->
<element name="BackTraceStrFunc">
<short>Standard backtrace formatting routine</short>
<descr>
This handler is called to get a standard format for the backtrace routine.
</descr>
</element>

<!-- constant Visibility: default -->
<element name="ErrorProc">
<short>Custom error handling procedure.</short>
<descr>
<p>
If set, the <var>ErrorProc</var> constant is used when a run-time error
occurs. If it is not set, then the standard error handling is done: a stack
dump is performed, and the program exits with the indicated error code.
</p>
<p>
The <file>SysUtils</file> unit sets this procedure and raises an exception
in its handler.
</p>
</descr>
<seealso>
<link id="TErrorProc"/>
<link id="Halt"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AbstractErrorProc">
<short>Custom abstract error handling procedure</short>
<descr>
<p>
If set, the <var>AbstractErrorProc</var> constant is used when an abstract
error occurs. If it is not set, then the standard error handling is done:
A stack dump is performed, and the program exits with error code 211.
</p>
<p>
The <file>SysUtils</file> unit sets this procedure and raises an exception
in its handler.
</p>
</descr>
<seealso>
<link id="TAbstractErrorProc"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AssertErrorProc">
<short>Custom assert error handling procedure</short>
<descr>
<p>
If set, the <var>AbstractErrorProc</var> constant is used when an assert
error occurs. If it is not set, then the standard error handling is done:
The assertion error message is printed, together with the location of the
assertion, and A stack dump is performed, and the program exits with error code
227.
</p>
<p>
The <file>SysUtils</file> unit sets this procedure and raises an exception
in its handler.
</p>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="jmp_buf">
<short>Record type to store processor information.</short>
<seealso>
<link id="setjmp"/>
<link id="longjmp"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.ebx">
<short>EBX register.</short>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.esi">
<short>ESI register</short>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.edi">
<short>EDI register</short>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.bp">
<short>BP register</short>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.sp">
<short>SP register</short>
</element>

<!-- variable Visibility: default -->
<element name="jmp_buf.pc">
<short>PC register</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PJmp_buf">
<short>Pointer to <link id="jmp_buf"/> record</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtInstanceSize">
<short>VMT Layout: Location of class instance size in VMT</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtParent">
<short>VMT Layout: location of pointer to parent VMT.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtClassName">
<short>VMT Layout: location of class name.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtDynamicTable">
<short>VMT Layout: location of dynamic methods table.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtMethodTable">
<short>VMT Layout: Method table start.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtFieldTable">
<short>VMT Layout: Location of fields table.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtTypeInfo">
<short>VMT Layout: Location of class type information.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtInitTable">
<short>VMT Layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtAutoTable">
<short>VMT layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtIntfTable">
<short>VMT layout: Interface table</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtMsgStrPtr">
<short>VMT layout: message strings table.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtMethodStart">
<short>VMT layout: start of method table.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtDestroy">
<short>VMT Layout: Location of destructor pointer.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtNewInstance">
<short>VMT Layout: location of NewInstance method.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtFreeInstance">
<short>VMT Layout: location of FreeInstance method.</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtSafeCallException">
<short>VMT  Layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtDefaultHandler">
<short>VMT Layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtAfterConstruction">
<short>VMT Layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtBeforeDestruction">
<short>VMT Layout: ?</short>
</element>

<!-- constant Visibility: default -->
<element name="vmtDefaultHandlerStr">
<short>VMT Layout: ?</short>
</element>

<!-- alias type Visibility: default -->
<element name="TextFile">
<short>Alias for <var>Text</var> file type.</short>
</element>

<!-- object Visibility: default -->
<element name="TObject">
<short>Parent class for all classes.</short>
<descr>
<var>TObject</var> is used as the parent class for all class definitions.
It contains some standard methods that are available in all classes.
</descr>
<seealso>
<link id="TClass"/>
</seealso>
</element>

<!-- "class of" type Visibility: default -->
<element name="TClass">
<short>Class of <link id="TObject"/>.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PClass">
<short>Pointer to <link id="TClass"/></short>
</element>

<!-- record type Visibility: default -->
<element name="TMsgStrTable">
<short>Record used in string message handler table.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMsgStrTable.name">
<short>Message name</short>
</element>

<!-- variable Visibility: default -->
<element name="TMsgStrTable.method">
<short>Method to call</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PMsgStrTable">
<short>Pointer to array of <link id="TMsgStrTable"/> records.</short>
</element>

<!-- record type Visibility: default -->
<element name="TStringMessageTable">
<short>String message table container for class.</short>
<descr>
Record used to describe the string messages handled by a class.
It consists of a count, followed by an array of <link id="TMsgStrTable"/>
records.
</descr>
<seealso>
<link id="TMsgStrTable"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TStringMessageTable.count">
<short>Number of messages in the string table.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TStringMessageTable.msgstrtable">
<short>First <link id="TMsgStrTable"/> record.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pstringmessagetable">
<short>Pointer to <link id="TStringMessageTable"/> record.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PGuid">
<short>Pointer to <link id="TGUID"/> type. </short>
</element>

<!-- record type Visibility: default -->
<element name="TGuid">
<short>Standard GUID representation type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pinterfaceentry">
<short>Pointer to <link id="tinterfaceentry"/> record.</short>
</element>

<!-- record type Visibility: default -->
<element name="tinterfaceentry">
<short>Interfaces table entry.</short>
<descr>
<var>tinterfaceentry</var> is used to store the list of Interfaces of a
class. This list is stored as an array of <var>tinterfaceentry</var>
records.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="tinterfaceentry.IID">
<short>Unique GUID for this interface.</short>
</element>

<!-- variable Visibility: default -->
<element name="tinterfaceentry.VTable">
<short>Pointer to interface VTable.</short>
</element>

<!-- variable Visibility: default -->
<element name="tinterfaceentry.IOffset">
<short>Offset</short>
</element>

<!-- variable Visibility: default -->
<element name="tinterfaceentry.IIDStr">
<short>Pointer to GUID string. Always assigned for COM.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pinterfacetable">
<short>Pointer to <link id="tinterfacetable"/> record.</short>
</element>

<!-- record type Visibility: default -->
<element name="tinterfacetable">
<short>Record to store list of interfaces of a class.</short>
</element>

<!-- variable Visibility: default -->
<element name="tinterfacetable.EntryCount">
<short>Number of interfaces.</short>
</element>

<!-- variable Visibility: default -->
<element name="tinterfacetable.Entries">
<short>Array of <link id="tinterfaceentry"/> records.</short>
</element>

<!-- object Visibility: default -->
<element name="TObject">
<short>Base class of all classes.</short>
<descr>
<var>TObject</var> is the parent root class for all classes in Object
Pascal. If a class has no parent class explicitly declared, it is dependent
on <var>TObject</var>. <var>TObject</var> introduces class methods that deal
with the class' type information, and contains all necessary methods to
create an instance at runtime, and to dispatch messages to the correct
method (both string and integer messages).
</descr>
<seealso>
<link id="TClass"/>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TObject.Create">
<short><var>TObject</var> Constructor</short>
<descr>
<var>Create</var> creates a new instance of <var>TObject</var>. Currently it
does nothing. It is also not virtual, so there is in principle no need to
call it directly. 
</descr>
<seealso>
<link id="TObject.Destroy">Destroy</link>
</seealso>
</element>

<!-- destructor Visibility: public -->
<element name="TObject.Destroy">
<short><var>TObject</var> destructor.</short>
<descr>
<p>
<var>Destroy</var> is the destructor of <var>TObject</var>. 
It will clean up the memory assigned to the instance. Descendent classes
should override destroy if they want to do additional clean-up. No other
destructor should be implemented.
</p>
<p>
It is bad programming practice to call <var>Destroy</var> directly. It is
better to call the <link id="TObject.Free">Free</link> method, because that
one will check first if <var>Self</var> is different from <var>Nil</var>.
</p>
<p>
To clean up an instance and reset the refence to the instance, it is best to
use the <link id="#rtl.sysutils.freeandnil">FreeAndNil</link> function.
</p>
</descr>
<seealso>
<link id="TObject.Create">Create</link>
<link id="TObject.Free">Free</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.newinstance">
<short>Allocate memory on the heap for a new instance</short>
<descr>
<var>NewInstance</var> allocates memory on the heap for a new instance of
the current class. If the memory was allocated, the class will be
initialized by a call to <link id="TObject.InitInstance">InitInstance</link>.
The function returns the newly initialized instance.
</descr>
<errors>
If not enough memory is available, a <var>Nil</var> pointer may be returned, 
or an exception may be raised.
</errors>
<seealso>
<link id="TObject.Create">Create</link>
<link id="TObject.InitInstance">InitInstance</link>
<link id="TObject.InstanceSize">InstanceSize</link>
<link id="TObject.FreeInstance">FreeInstance</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.FreeInstance">
<short>Clean up instance and free the memory reserved for the instance.</short>
<descr>
<var>FreeInstance</var> cleans up an instance of the current class, and
releases the heap memory occupied by the class instance.
</descr>
<seealso>
<link id="TObject.Destroy">Destroy</link>
<link id="TObject.InitInstance">InitInstance</link>
<link id="TObject.NewInstance">NewInstance</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.SafeCallException">
<short>Handle exception object</short>
<descr>
<var>SafeCallException</var> should be overridden to handle exceptions in a
method marked with the savecall directive. The implementation in
<var>TObject</var> simply returns zero.
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.DefaultHandler">
<short>Default handler for integer message handlers.</short>
<descr>
<var>DefaultHandler</var> is the default handler for messages. If a message
has an unknown message ID (i.e. does not appear in the table with integer
message handlers), then it will be passed to
<var>DefaultHandler</var> by the <link id="TObject.Dispatch">Dispatch</link>
method.
</descr>
<errors>
</errors>
<seealso>
<link id="TObject.Dispatch">Dispatch</link>
<link id="TObject.DefaultHandlerStr">DefaultHandlerStr</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.Free">
<short>Check for <var>Nil</var> and call destructor.</short>
<descr>
<var>Free</var> will check the <var>Self</var> pointer and calls
<link id="TObject.Destroy">Destroy</link> if it is different from
<var>Nil</var>. This is a safer method than calling <var>Destroy</var>
directly. If a reference to the object must be reset as well (a recommended
technque), then the function <link id="#rtl.sysutils.freeandnil">FreeAndNil</link> should be called.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.Destroy">Destroy</link>
<link id="#rtl.sysutils.freeandnil">FreeAndNil</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.InitInstance">
<short>Initialize a new class instance.</short>
<descr>
<var>InitInstance</var> initializes the memory pointer to by
<var>Instance</var>. This means that the VMT is initialized, and the
interface pointers are set up correctly.
The function returns the newly initialized instance.
</descr>
<seealso>
<link id="TObject.NewInstance">NewInstance</link>
<link id="TObject.Create">Create</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.CleanupInstance">
<short>Finalize the class instance.</short>
<descr>
<p>
<var>CleanUpinstance</var> finalizes the instance, i.e. takes care of all
reference counted objects, by decreasing their reference count by 1, and
freeing them if their count reaches zero.
</p>
<p>
Normally, <var>CleanupInstance</var> should never be called, it is called
automatically when the object is freed with it's constructor.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.Destroy">Destroy</link>
<link id="TObject.Free">Free</link>
<link id="TObject.InitInstance">InitInstance</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.ClassInfo">
<short>Return a pointer to the type information for this class.</short>
<descr>
<var>ClassInfo</var> returns a pointer to the type information for this
class. This pointer can be used in the various type information routines.
</descr>
</element>

<!-- function Visibility: public -->
<element name="TObject.ClassType">
<short>Return a "class of" pointer for the current class</short>
<descr>
<var>ClassType</var> returns a <link id="TClass"/> class type reference for
the current class.
</descr>
<seealso>
<link id="TClass"/>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassName">ClassName</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.ClassName">
<short>Return the current class name.</short>
<descr>
<var>ClassName</var> returns the class name for the current class, in
all-uppercase letters. To check for the class name, use the <link
id="TObject.ClassNameIs">ClassNameIs</link> class method.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassType">ClassType</link>
<link id="TObject.ClassNameIs">ClassNameIs</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.ClassNameIs">
<short>Check whether the class name equals the given name.</short>
<descr>
<var>ClassNameIs</var> checks whether <var>Name</var> equals the class name.
It takes of case sensitivity, i.e. it converts both names to uppercase
before comparing.
</descr>
<seealso>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassType">ClassType</link>
<link id="TObject.ClassName">ClassName</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.ClassParent">
<short>Return the parent class.</short>
<descr>
<var>ClassParent</var> returns the class of the parent class of the current
class. This is always different from <var>Nil</var>, except for
<var>TObject</var>.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassType">ClassType</link>
<link id="TObject.ClassName">ClassNameIs</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.InstanceSize">
<short>Return the size of an instance.</short>
<descr>
<var>InstanceSize</var> returns the number of bytes an instance takes in
memory. This is Just the memory occupied by the class structure, and does
not take into account any additional memory that might be allocated by the
constructor of the class.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.InitInstance">InitInstance</link>
<link id="TObject.ClassName">ClassName</link>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassType">ClassType</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.InheritsFrom">
<short>Chck wether class is an ancestor.</short>
<descr>
<var>InheritsFrom</var> returns <var>True</var> if <var>AClass</var> is an
ancestor class from the current class, and returns false if it is not.
</descr>
<errors>
</errors>
<seealso>
<link id="TObject.ClassName">ClassName</link>
<link id="TObject.ClassInfo">ClassInfo</link>
<link id="TObject.ClassType">ClassType</link>
<link id="TClass"/>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.StringMessageTable">
<short>Return a pointer to the string message table.</short>
<descr>
<var>StringMessageTable</var> returns a pointer to the string message table,
which can be used to look up methods for dispatching a string message. It is
used by the <link id="TObject.DispatchStr">DispatchStr</link> method.
</descr>
<errors>
If there are no string message handlers, nil is returned.
</errors>
<seealso>
<link id="TObject.DispatchStr">DispatchStr</link>
<link id="TObject.Dispatch">Dispatch</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.Dispatch">
<short>Dispatch an integer message</short>
<descr>
<p>
<var>Dispatch</var> looks in the message handler table for a handler that
handles <var>message</var>. The message is identified by the first dword
(cardinal) in the message structure.
</p>
<p>
If no matching message handler is found, the message is passed to the
<link id="TObject.DefaultHandler">DefaultHandler</link> method, which can be
overridden by descendent classes to add custom handling of messages.
</p>
</descr>
<seealso>
<link id="TObject.DispatchStr">DispatchStr</link>
<link id="TObject.DefaultHandler">DefaultHandler</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.DispatchStr">
<short>Dispatch a string message.</short>
<descr>
<var>DispatchStr</var> extracts the message identifier from
<var>Message</var> and checks the message handler table to see if a handler
for the message is found, and calls the handler, passing along the message. 
If no handler is found, the default <link id="TObject.DefaultHandlerStr">DefaultHandlerStr</link> 
is called.
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.DefaultHandlerStr">DefaultHandlerStr</link>
<link id="TObject.Dispatch">Dispatch</link>
<link id="TObject.DefaultHandler">DefaultHandler</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.MethodAddress">
<short>Return the address of a method</short>
<descr>
<var>MethodAddress</var> returns the address of a method, searching the
method by its name. The <var>Name</var> parameter specifies which method
should be taken. The search is conducted in a case-insensitive manner.
</descr>
<errors>
If no matching method is found, <var>Nil</var> is returned.
</errors>
<seealso>
<link id="TObject.MethodName">MethodName</link>
<link id="TObject.FieldAddress">FieldAddress</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.MethodName">
<short>Return the name of a method.</short>
<descr>
<var>MethodName</var> searches the VMT for a method with the specified 
<var>address</var> and returns the name of the method.
</descr>
<errors>
If no method with the matching address is found, an empty string is
returned.
</errors>
<seealso>
<link id="TObject.MethodAddress">MethodAddress</link>
<link id="TObject.FieldAddress">FieldAddress</link>
</seealso>
</element>

<!-- function Visibility: public -->
<element name="TObject.FieldAddress">
<short>Return the address of a field.</short>
<descr>
<var>FieldAddress</var> returns the address of the field with name <var>name</var>. 
The address is the address of the field in the current class instance.
</descr>
<errors>
If no field with the specified name is found, <var>Nil</var> is returned.
</errors>
<seealso>
<link id="TObject.MethodAddress">MethodAddress</link>
<link id="TObject.MethodName">MethodName</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.AfterConstruction">
<short>Method called after the constructor was called.</short>
<descr>
<var>AfterConstruction</var> is a method called after the constructor was
called. It does nothing in the implementation of <var>TObject</var> and must
be overridden by descendent classes to provide specific behaviour that is
executed after the constructor has finished executing. (for instance, call
an event handler)
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.BeforeDestruction">BeforeDestruction</link>
<link id="TObject.Create">Create</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.BeforeDestruction">
<short>Method called before the destructor is called.</short>
<descr>
<var>BeforeDestruction</var> is a method called before the destructor is
called. It does nothing in the implementation of <var>TObject</var> and must
be overridden by descendent classes to provide specific behaviour that is
executed before the destructor has finished executing. (for instance, call
an event handler)
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TObject.AfterConstruction">AfterConstruction</link>
<link id="TObject.Destroy">Destroy</link>
<link id="TObject.Free">Free</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TObject.DefaultHandlerStr">
<short>Default handler for string messages.</short>
<descr>
<var>DefaultHandlerStr</var> is called for string messages which have no
handler associated with them in the string message handler table. The
implementation of <var>DefaultHandlerStr</var> in <var>TObject</var> does
nothing and mut be overridden by descendent classes to provide specific
message handling behaviour.
</descr>
<seealso>
<link id="TObject.DispatchStr">DispatchStr</link>
<link id="TObject.Dispatch">Dispatch</link>
<link id="TObject.DefaultHandler">DefaultHandler</link>
</seealso>
</element>

<!-- procedure type Visibility: default -->
<element name="TExceptProc">
<short>Exception handler procedural type</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PExceptObject">
<short>Pointer to Exception handler procedural type <link id="TExceptProc"/></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TExceptObject">
<short>Exception object</short>
<descr>
<var>TExceptObject</var> is the exception description record which is found
on the exception stack.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.FObject">
<short>Exception instance.</short>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.Addr">
<short>Address where exception occurred</short>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.Frame">
<short>Exception frame where exception occurred</short>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.Next">
<short>Next exception object on the stack.</short>
</element>

<!-- variable Visibility: default -->
<element name="TExceptObject.refcount">
<short>Reference count for this exception object</short>
</element>

<!-- constant Visibility: default -->
<element name="ExceptProc">
<short>Current exception handling procedure.</short>
<descr>
<p>
This constant points to the current exception handling procedure. 
This routine is called when an unhandled exception occurs, i.e. an exception
that is not stopped by a except block.
</p>
<p>
If the handler is not set, the RTL will emit a run-time error 217 when an
unhandler exception occurs.
</p>
<p>
It is set by the <link id="#rtl.sysutils">sysutils</link> unit. 
</p>
</descr>
</element>

<!-- constant Visibility: default -->
<element name="RaiseProc">
<short>Procedure to raise an exception.</short>
</element>

<!-- function Visibility: default -->
<element name="RaiseList">
<short>List of currently raised exceptions.</short>
<descr>
<var>RaiseList</var> returns a pointer to the list of currently raised
exceptions (i.e. a pointer to the first exception block.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="AcquireExceptionObject">
<short>Obtain a reference to the current exception object</short>
<descr>
<p>
<var>AcquireExceptionObject</var> returns the current exception object.
It raises the reference count of the exception object, so it will not be
freed.  Calling this method is only valid within an except block.
</p>
<p>
The effect of this function is countered by re-raising an exception
via <var>raise;</var>
</p>
<p>
To make sure that the exception object is released when it is no longer
needed, <link id="ReleaseExceptionObject"/> must be called when the 
reference is no longer needed.
</p>
</descr>
<errors>
If there is no current exception, a run-time error 231 will occur.
</errors>
<seealso>
<link id="ReleaseExceptionObject"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="ReleaseExceptionObject">
<short>Decrease the reference count of the current exception object.</short>
<descr>
<p>
<var>ReleaseExceptionObject</var> decreases the reference count of the
current exception object. This should be called whenever a reference to the
exception object was obtained via the <link id="AcquireExceptionObject"/>
call.
</p>
<p>
Calling this method is only valid within an except block.
</p>
</descr>
<errors>
If there is no current exception object, a run-time error 231 will occur.
</errors>
<seealso>
<link id="AcquireExceptionObject"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="vtInteger">
<short>TVarRec type: Integer</short>
</element>

<!-- constant Visibility: default -->
<element name="vtBoolean">
<short>TVarRec type: Boolean</short>
</element>

<!-- constant Visibility: default -->
<element name="vtChar">
<short>TVarRec type: Char</short>
</element>

<!-- constant Visibility: default -->
<element name="vtExtended">
<short>TVarRec type: Extended</short>
</element>

<!-- constant Visibility: default -->
<element name="vtString">
<short>TVarRec type: String</short>
</element>

<!-- constant Visibility: default -->
<element name="vtPointer">
<short>TVarRec type: pointer</short>
</element>

<!-- constant Visibility: default -->
<element name="vtPChar">
<short>TVarRec type: PChar</short>
</element>

<!-- constant Visibility: default -->
<element name="vtObject">
<short>TVarRec type: Object instance</short>
</element>

<!-- constant Visibility: default -->
<element name="vtClass">
<short>TVarRec type: Class type</short>
</element>

<!-- constant Visibility: default -->
<element name="vtWideChar">
<short>TVarRec type: Widechar</short>
</element>

<!-- constant Visibility: default -->
<element name="vtPWideChar">
<short>TVarRec type: PWideChar</short>
</element>

<!-- constant Visibility: default -->
<element name="vtAnsiString">
<short>TVarRec type: Ansistring</short>
</element>

<!-- constant Visibility: default -->
<element name="vtCurrency">
<short>TVarRec type: Currency</short>
</element>

<!-- constant Visibility: default -->
<element name="vtVariant">
<short>TVarRec type: Variant</short>
</element>

<!-- constant Visibility: default -->
<element name="vtInterface">
<short>TVarRec type: Interface</short>
</element>

<!-- constant Visibility: default -->
<element name="vtWideString">
<short>TVarRec type: WideString</short>
</element>

<!-- constant Visibility: default -->
<element name="vtInt64">
<short>TVarRec type: Int64 (signed 64-bit integer)</short>
</element>

<!-- constant Visibility: default -->
<element name="vtQWord">
<short>TVarRec type: QWord (unsigned 64-bit integer)</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PVarRec">
<short>Pointer to <link id="TVarRec"/> type.</short>
</element>

<!-- record type Visibility: default -->
<element name="TVarRec">
<short>Record describing an element in an array of const</short>
<descr>
<var>TVarRec</var> is a record generated by the compiler for each element in
a <var>array of const</var> call. The procedure that receives the constant
array receives an array of <var>TVarRec</var> elements, with lower bound zero
and high bound equal to the number of elements in the array minus one
(as returned by <var>High(Args)</var>)
</descr>
<seealso>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="tdynarrayindex">
<short>Type with the correct size for index into a dynamic array.</short>
<descr>
A variable of type <var>tdynarrayindex</var> will always have the correct
size, suitable for serving as an index in a dynamic array.
</descr>
</element>

<!-- pointer type Visibility: default -->
<element name="pdynarrayindex">
<short>Pointer to <link id="tdynarrayindex"/> type.</short>
</element>

<!-- array type Visibility: default -->
<element name="fpc_big_chararray" skip="1">
<short>Array of char.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="fpc_small_set" skip="1">
<short>Type with the size of a small set</short>
</element>

<!-- array type Visibility: default -->
<element name="fpc_normal_set" skip="1">
<short>Type with the size of a normal set</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PMemoryManager">
<short>Pointer to <link id="TMemoryManager"/> record</short>
</element>

<!-- record type Visibility: default -->
<element name="TMemoryManager">
<short>Record describing the current memory manager</short>
<descr>
<var>TMemoryManager</var> describes the memory manager. For more information
about the memory manager, see the programmer's reference. 
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.NeedLock">
<short>Does the memory manager require a lock</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.Getmem">
<short>Function called when memory must be allocated on the heap.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.Freemem">
<short>Function called when previously allocated memory can be freed again.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.FreememSize">
<short>Function called when previously allocated memory with a known size can be freed again.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.AllocMem">
<short>Same as getmem.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.ReAllocMem">
<short>Handler called when an allocated  memory block should be resized</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.MemSize">
<short>Return the size of a memory block.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryManager.GetHeapStatus">
<short>Handler called when the heap status must be reported.</short>
</element>

<element name="GetHeapStatus">
<short>Return the memory manager heap status.</short>
</element>

<!-- record type Visibility: default -->
<element name="TMemoryMutexManager">
<short>Record describing the mutex manager for the heap.</short>
<descr>
When the heapmanager needs a lock, then the mutex manager is used to handle
the lock.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryMutexManager.MutexInit">
<short>Initialize the mutex</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryMutexManager.MutexDone">
<short>Finalize (i.e. dispose of) the mutex.</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryMutexManager.MutexLock">
<short>Lock the mutex</short>
</element>

<!-- variable Visibility: default -->
<element name="TMemoryMutexManager.MutexUnlock">
<short>Unlock the mutex.</short>
</element>

<!-- procedure Visibility: default -->
<element name="SetMemoryMutexManager">
<short>Procedure to set the mutex manager.</short>
<descr>
<var>SetMemoryMutexManager</var> sets the mutex manager used by the memory
manager to <var>MutexMgr</var>. The current mutex manager is returned in
<var>MutexMgr</var>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="TMemoryMutexManager"/>
<link id="SetMemoryManager"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="growheapsizesmall">
<short>Fixed size small blocks grow rate</short>
</element>

<!-- constant Visibility: default -->
<element name="growheapsize1">
<short>Grow rate for block less than 256 Kb.</short>
</element>

<!-- constant Visibility: default -->
<element name="growheapsize2">
<short>Grow rate for block larger than 256 Kb.</short>
</element>

<!-- variable Visibility: default -->
<element name="ReturnNilIfGrowHeapFails">
<short>Describe behaviour if getmem fails.</short>
<descr>
<var>ReturnNilIfGrowHeapFails</var> describes what happens if there is no
more memory available from the operating system. if set to <var>True</var>
the memory manager will return <var>Nil</var>. If set to <var>False</var>
then a run-time error will occur.
</descr>
</element>

<!-- function Visibility: default -->
<element name="SysGetmem">
<short>System memory manager memory allocator.</short>
<descr>
<var>SysGetmem</var> is the system memory manager implementation for <link
id="GetMem"/> 
</descr>
<seealso>
<link id="GetMem"/>
<link id="GetMemory"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysFreemem">
<short>System memory manager free routine.</short>
<descr>
<var>SysFreeem</var> is the system memory manager implementation for <link id="FreeMem"/>
</descr>
<seealso>
<link id="FreeMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysFreememSize">
<short>System memory manager free routine.</short>
<descr>
<var>SysFreemSize</var> is the system memory manager implementation for <link
id="FreeMem"/>
</descr>
<seealso>
<link id="MemSize"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysMemSize">
<short>System memory manager: free size.</short>
<descr>
<var>SysFreemSize</var> is the system memory manager implementation for
<link id="MemSize"/>
</descr>
<seealso>
<link id="MemSize"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysAllocMem">
<short>System memory manager: Allocate memory</short>
<descr>
<var>SysFreemSize</var> is the system memory manager implementation for
<link id="AllocMem"/>
</descr>
<seealso>
<link id="AllocMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysTryResizeMem">
<short>System memory manager: attempt to resize memory.</short>
<descr>
<var>SysTryResizeMem</var> is a help routine for the system memory 
manager implementation for <link id="ReAllocMem"/>, <link
id="SysReAllocMem"/>
</descr>
<seealso>
<link id="SysReAllocMem"/>
<link id="ReAllocMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="SysReAllocMem">
<short>System memory manager: Reallocate memory</short>
<descr>
<var>SysReallocMem</var> is a help routine for the system memory
manager implementation for <link id="ReAllocMem"/>.
</descr>
<seealso>
<link id="ReAllocMem"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="Getmemory">
<short>Alias for <link id="GetMem"/></short>
<descr>
<var>Getmemory</var> is an alias for <link id="GetMem"/>.
</descr>
<seealso>
<link id="GetMem"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="Freememory">
<short>Alias for <link id="FreeMem"/></short>
<descr>
<var>FreeMemory</var> is an alias for <link id="FreeMem"/>.
</descr>
<seealso>
<link id="FreeMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="MemSize">
<short>Return the size of a memory block.</short>
<descr>
<var>MemSize</var> returns the size of a memory block on the heap.
</descr>
<errors>
Passing an invalid pointer may lead to run-time errors (access violations).
</errors>
<seealso>
<link id="GetMem"/>
<link id="FreeMem"/>
</seealso>
</element>

<element name="AllocMem">
<short>Alias for <link id="GetMem"/></short>
<descr>
<var>AllocMem</var> is an alias for <link id="GetMem"/>. 
</descr>
<seealso>
<link id="GetMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ReAllocMem">
<short>Re-allocate memory on the heap</short>
<descr>
<p>
<var>ReAllocMem</var> resizes the memory pointed to by <var>P</var> so it has size
<var>Size</var>. The value of <var>P</var> may change during this operation.
The contents of the memory pointed to by <var>P</var> (if any) will be copied to
the new location, but may be truncated if the newly allocated memory block
is smaller in size. If a larger block is allocated, only the used memory is
initialized, extra memory will not be zeroed out.
</p>
<p>
Note that <var>P</var> may be nil, in that case the behaviour of
<var>ReAllocMem</var> is equivalent to <var>Getmem</var>.
</p>
</descr>
<seealso>
<link id="GetMem"/>
<link id="FreeMem"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="ReAllocMemory">
<short>Alias for <link id="ReAllocMem"/></short>
<descr>
<var>ReAllocMemory</var> is an alias for <link id="ReAllocMem"/>.
</descr>
<seealso>
<link id="ReAllocMem"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="AsmGetmem">
<short>Routine that can be called from assembler routines to get memory.</short>
<descr>
<var>AsmGetmem</var> is a routine that can be called from assembler code to
get memory. The assembler reader cannot decide which overloaded <link
id="GetMem"/> call should be used. <var>AsmGetMem</var> provides a unique
name that can be called from assembler. Other than that it is completely
equivalent to <var>GetMem</var>.
</descr>
<seealso>
<link id="GetMem"/>
<link id="AsmFreeMem"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="AsmFreemem">
<short>Routine that can be called from assembler routines to release memory.</short>
<descr>
<var>AsmFreemem</var> is a routine that can be called from assembler code to
release previously alocated memory. The assembler reader cannot decide which 
overloaded <link id="FreeMem"/> call should be used. <var>AsmFreeMem</var> 
provides a unique name that can be called from assembler. Other than that it 
is completely equivalent to <var>FreeMem</var>.
</descr>
<seealso>
<link id="FreeMem"/>
<link id="AsmGetMem"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="THandle">
<short>Type alias.</short>
<descr>
This type should be considered opaque. It is used to describe file and other
handles.
</descr>
</element>

<!-- constant Visibility: default -->
<element name="LineEnding">
<short>Constant describing the current line ending character.</short>
<descr>
<p>
<var>LineEnding</var> is a constant which contains the current line-ending
character. This character is system dependent, and is initialized by the
system. It should not be set.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DriveSeparator"/>
<link id="DirectorySeparator"/>
<link id="LFNSupport"/>
<link id="PathSeparator"/>
<link id="sLineBreak"/>
<link id="FileNameCaseSensitive"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="LFNSupport">
<short>COnstant describing support for long filenames.</short>
<descr>
<p>
<var>LFNSupport</var> determines whether the current OS supports long file
names, i.e. filenames that are not of the form 8.3 as on ancient DOS
systems. If the value of this constant is <var>True</var> then long
filenames are supported. If it is false, then not.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<link id="DriveSeparator"/>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="PathSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="DefaultTextLineBreakStyle"/>
</element>

<!-- constant Visibility: default -->
<element name="DirectorySeparator">
<short>Character used to separate directory parts.</short>
<descr>
<p>
<var>DirectorySeparator</var> is the character used by the current operating
system to separate directory parts in a pathname. This constant is system
dependent, and should not be set.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DriveSeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="PathSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DriveSeparator">
<short>Character used to separate directory parts.</short>
<descr>
<p>
On systems that support driveletters, the <var>DriveSeparator</var> constant
denotes the character that separates the drive indicator from the directory
part in a filename path.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="PathSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="PathSeparator">
<short>Character used to separate paths in a search list</short>
<descr>
<p>
<var>PathSeparator</var> is the character used commonly on the current
operating system to separate paths in a list of paths, such as the 
<var>PATH</var> environment variable. 
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="DriveSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="FileNameCaseSensitive">
<short>OS treatment of filenames is case sensitive.</short>
<descr>
<p>
<var>FileNameCaseSensitive</var> is <var>True</var> if case is important
when using filenames on the current OS. In this case, the OS will treat 
files with different cased names as different files. Note that this may 
depend on the filesystem: Unix operating systems that access a DOS or
Windows partition will have this constant set to true, but when writing to
the DOS partition, the casing is ignored.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DriveSeparator"/>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="PathSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="sLineBreak">
<short>Alias for <link id="LineEnding"/></short>
<descr>
<p>
<var>sLineBreak</var> is an alias for <link id="LineEnding"/> and is
supplied for Delphi compatibility.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="DriveSeparator"/>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="PathSeparator"/>
<link id="FileNameCaseSensitive"/>
<link id="DefaultTextLineBreakStyle"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="DefaultTextLineBreakStyle">
<short>Default line ending style.</short>
<descr>
<p>
<var>DefaultTextLineBreakStyle</var> contains the default OS setting for the
<link id="TTextLineBreakStyle"/> type. It is initizliaed by the system unit,
and is used to determine the default line ending when writing to text files.
</p>
<p>
This constant is part of a set of constants that describe the OS
characteristics. These constants should be used instead of hardcoding 
OS characteristics.
</p>
</descr>
<seealso>
<link id="SetTextLineEnding"/>
<link id="TTextLineBreakStyle"/>
<link id="DriveSeparator"/>
<link id="DirectorySeparator"/>
<link id="LineEnding"/>
<link id="LFNSupport"/>
<link id="PathSeparator"/>
<link id="FileNameCaseSensitive"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="maxExitCode">
<short>Maximum exit code supported by the operating system.</short>
<descr>
<var>maxExitCode</var> is the maximum value for the <link id="Halt"/> call.
</descr>
<seealso>
<link id="Halt"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="UnusedHandle">
<short>Value indicating an unused file handle (as reported by the OS).</short>
</element>

<!-- constant Visibility: default -->
<element name="StdInputHandle">
<short>Value of the OS handle for the standard input file.</short>
</element>

<!-- constant Visibility: default -->
<element name="StdOutputHandle">
<short>Value of the OS handle for the standard output file.</short>
</element>

<!-- constant Visibility: default -->
<element name="StdErrorHandle">
<short>Value of the OS handle for the standard error-output file.</short>
</element>


<!-- variable Visibility: default -->
<element name="argc" skip="1">
<short>Number of command-line arguments.</short>
<descr>
<var>argc</var> contains the number of command-line arguments passed to
the program by the OS. It is not available on all systems.
</descr>
<seealso>
<link id="argv"/>
<link id="envp"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="argv">
<short>Pointer to the array of command-line arguments</short>
<descr>
<var>argp</var> contains a pointer to a <var>nil</var>-terminated 
array of null-terminated strings, containing the command-line 
arguments passed to the program by the OS. It is not available 
on all systems.
</descr>
<seealso>
<link id="argc"/>
<link id="envp"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="envp">
<short>Pointer to the array of environment variables</short>
<descr>
<var>envp</var> contains a pointer to a <var>nil</var>-terminated
array of null-terminated strings, containing the environment variables
passed to the program by the OS. It is not available on all systems.
</descr>
<seealso>
<link id="argc"/>
<link id="argv"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="SizeInt">
<short>Signed integer type which fits for sizes</short>
<seealso>
<link id="SizeUInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="SizeUInt">
<short>Unsigned Integer type which fits for sizes</short>
<seealso>
<link id="SizeInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="PtrInt">
<short>Signed integer type with same size as Pointer.</short>
<descr>
<var>PtrInt</var> is an integer type which has always the same size as a
pointer. When using integers which will be cast to pointers and vice versa,
use this type, never the regular integer type.
</descr>
<seealso>
<link id="PtrUInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="PtrUInt">
<short>Unsigned integer type with same size as Pointer.</short>
<descr>
<var>PtrUInt</var> is an unsigned integer type which has always the same size as a
pointer. When using integers which will be cast to pointers and vice versa,
use this type, never the regular Cardinal type.
</descr>
<seealso>
<link id="PtrInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="ValSInt">
<short>Val-Signed integer.</short>
<descr>
Integer with teh same size as the return code of the <link id="Val"/>
function.
</descr>
<seealso>
<link id="Val"/>
<link id="ValUInt"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="ValUInt">
<short>Val-unsigned integer</short>
<descr>
Integer with teh same size as the return code of the <link id="Val"/>
function.
</descr>
<seealso>
<link id="Val"/>
<link id="ValUInt"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PVariant">
<short>Pointer to <var>Variant</var> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="POleVariant">
<short>Pointer to <var>OleVariant</var> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PWideChar">
<short>Pointer to <link id="WChar"/>.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PPWideChar">
<short>Pointer to link id="PWideChar"> type.</short>
</element>

<!-- alias type Visibility: default -->
<element name="UCS2Char">
<short>UCS2 unicode character.</short>
</element>

<!-- alias type Visibility: default -->
<element name="PUCS2Char">
<short>Pointer to <link id="UCS2Char"/> character.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PText">
<short>Pointer to text file.</short>
</element>

<!-- variable Visibility: default -->
<element name="ErrOutput">
<short>Alias for <link id="StdErr"/></short>
<descr>
<var>ErrOutput</var> is provided for Delphi compatibility.
</descr>
<seealso>
<link id="StdErr"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_lo_word">
<short>FPC compiler internal procedure index: lo (word)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_hi_word">
<short>FPC compiler internal procedure index: hi (word)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_lo_long">
<short>FPC compiler internal procedure index: lo (long)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_hi_long">
<short>FPC compiler internal procedure index: hi (long)</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_ord_x">
<short>FPC compiler internal procedure index: ord </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_length_string">
<short>FPC compiler internal procedure index: length</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_chr_byte">
<short>FPC compiler internal procedure index: chr</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_write_x">
<short>FPC compiler internal procedure index: write</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_writeln_x">
<short>FPC compiler internal procedure index: writeln</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_read_x">
<short>FPC compiler internal procedure index: read</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_readln_x">
<short>FPC compiler internal procedure index: readln</short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_concat_x">
<short>FPC compiler internal procedure index: concat </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_assigned_x">
<short>FPC compiler internal procedure index: assigned </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_str_x_string">
<short>FPC compiler internal procedure index: str </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_ofs_x">
<short>FPC compiler internal procedure index: ofs </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_sizeof_x">
<short>FPC compiler internal procedure index: sizeof </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_typeof_x">
<short>FPC compiler internal procedure index: typeof </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_val_x">
<short>FPC compiler internal procedure index: val </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_reset_x">
<short>FPC compiler internal procedure index: reset </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_rewrite_x">
<short>FPC compiler internal procedure index: rewrite </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_low_x">
<short>FPC compiler internal procedure index: low </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_high_x">
<short>FPC compiler internal procedure index: high </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_seg_x">
<short>FPC compiler internal procedure index: seg </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_pred_x">
<short>FPC compiler internal procedure index: pred </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_succ_x">
<short>FPC compiler internal procedure index: succ </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_reset_typedfile">
<short>FPC compiler internal procedure index: reset </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_rewrite_typedfile">
<short>FPC compiler internal procedure index: rewrite </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_settextbuf_file_x">
<short>FPC compiler internal procedure index: settextbuf </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_inc_x">
<short>FPC compiler internal procedure index: inc </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_dec_x">
<short>FPC compiler internal procedure index: dec </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_include_x_y">
<short>FPC compiler internal procedure index:  include </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_exclude_x_y">
<short>FPC compiler internal procedure index: exclude </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_break">
<short>FPC compiler internal procedure index: break </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_continue">
<short>FPC compiler internal procedure index: continue </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_assert_x_y">
<short>FPC compiler internal procedure index: assert </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_addr_x">
<short>FPC compiler internal procedure index: addr </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_typeinfo_x">
<short>FPC compiler internal procedure index: typeinfo </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_setlength_x">
<short>FPC compiler internal procedure index: setlength </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_finalize_x">
<short>FPC compiler internal procedure index: finalize </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_new_x">
<short>FPC compiler internal procedure index: new </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_dispose_x">
<short>FPC compiler internal procedure index: dispose  </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_exit">
<short>FPC compiler internal procedure index: exit </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_copy_x">
<short>FPC compiler internal procedure index: copy  </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_initialize_x">
<short>FPC compiler internal procedure index: initialize </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_leave">
<short>FPC compiler internal procedure index: leave </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_cycle">
<short>FPC compiler internal procedure index: cycle </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_trunc">
<short>FPC compiler internal procedure index: trunc </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_round">
<short>FPC compiler internal procedure index: round </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_frac">
<short>FPC compiler internal procedure index: frac </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_abs">
<short>FPC compiler internal procedure index: abs </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_int">
<short>FPC compiler internal procedure index: int </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_sqr">
<short>FPC compiler internal procedure index: sqr </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_odd">
<short>FPC compiler internal procedure index: sqr </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_ptr">
<short>FPC compiler internal procedure index: sqr </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_swap_word">
<short>FPC compiler internal procedure index: swap (word) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_swap_long">
<short>FPC compiler internal procedure index: swap (long) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_pi">
<short>FPC compiler internal procedure index: pi </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_sqrt">
<short>FPC compiler internal procedure index: sqrt </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_arctan">
<short>FPC compiler internal procedure index: arctan </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_cos">
<short>FPC compiler internal procedure index: cos </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_exp">
<short>FPC compiler internal procedure index: exp </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_ln">
<short>FPC compiler internal procedure index: in </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_sin">
<short>FPC compiler internal procedure index: sin </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_lo_qword">
<short>FPC compiler internal procedure index: lo (qword)  </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_hi_qword">
<short>FPC compiler internal procedure index: hi (qword) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_cos_real">
<short>FPC compiler internal procedure index: cos (real) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_pi">
<short>FPC compiler internal procedure index: pi </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_abs_real">
<short>FPC compiler internal procedure index: abs (real) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_sqr_real">
<short>FPC compiler internal procedure index: sqr (real) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_sqrt_real">
<short>FPC compiler internal procedure index: sqrt (real) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_arctan_real">
<short>FPC compiler internal procedure index: arctan (real) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_ln_real">
<short>FPC compiler internal procedure index: ln (real) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_sin_real">
<short>FPC compiler internal procedure index: sin (real) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_const_swap_qword">
<short>FPC compiler internal procedure index: swap (qword) </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_prefetch_var">
<short>FPC compiler internal procedure index: prefetch  </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpeqb">
<short>FPC compiler internal procedure index: MMX </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpeqw">
<short>FPC compiler internal procedure index: MMX </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpeqd">
<short>FPC compiler internal procedure index: MMX </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpgtb">
<short>FPC compiler internal procedure index: MMX </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpgtw">
<short>FPC compiler internal procedure index: MMX </short>
</element>

<!-- constant Visibility: default -->
<element name="fpc_in_mmx_pcmpgtd">
<short>FPC compiler internal procedure index: MMX </short>
</element>

<!-- function Visibility: default -->
<element name="Align">
<short>Return aligned version of an address</short>
<descr>
<var>Align</var> returns <var>Address</var>, aligned to <var>Alignment</var>
bytes.
</descr>
<errors>
None.
</errors>
</element>

<element name="ArrayStringToPPchar">
<short>Concert an array of string to an array of null-terminated strings</short>
<descr>
<p>
<var>ArrayStringToPPchar</var> creates an array of null-terminated strings
that point to strings which are the same as the strings in the array
<var>S</var>. The function returns a pointer to this array. The array and
the strings it contains must be disposed of after being used, because it 
they are allocated on the heap.
</p>
<p>
The <var>ReserveEntries</var> parameter tells <var>ArrayStringToPPchar</var>
to allocate room at the end of the array for another <var>ReserveEntries</var>
entries.
</p>
</descr>
<errors>
If not enough memory is available, an error may occur.
</errors>
<seealso>
<link id="StringToPPChar"/>
</seealso>
</element>

<element name="StringToPPChar">
<short>Split string in list of null-terminated strings</short>
<descr>
<p>
<var>StringToPPChar</var> splits the string <var>S</var> in words, replacing any
whitespace with zero characters. It returns a pointer to an array of pchars
that point to the first letters of the words in <var>S</var>. This array is terminated
by a <var>Nil</var> pointer.
</p>
<p>
The function does <em> not</em> add a zero character to the end of the string
unless it ends on whitespace.
</p>
<p>
The function reserves memory on the heap to store the array of <var>PChar</var>;
The caller is responsible for freeing this memory. 
</p>
<p>
This function is only available on certain platforms.
</p>
</descr>
<errors>
None.
</errors>
<seealso>
<link id="ArrayStringToPPchar"/>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="varempty">
<short>Variant type: <var>Empty</var> variant</short>
</element>

<!-- constant Visibility: default -->
<element name="varnull">
<short>Variant type: <link id="Null"/> variant </short>
</element>

<!-- constant Visibility: default -->
<element name="varsmallint">
<short>Variant type: smallint (8 bit) </short>
</element>

<!-- constant Visibility: default -->
<element name="varinteger">
<short>Variant type: Integer (32-bit)</short>
</element>

<!-- constant Visibility: default -->
<element name="varsingle">
<short>Variant type: Single float </short>
</element>

<!-- constant Visibility: default -->
<element name="vardouble">
<short>Variant type: Double float </short>
</element>

<!-- constant Visibility: default -->
<element name="varcurrency">
<short>Variant type: Currency </short>
</element>

<!-- constant Visibility: default -->
<element name="vardate">
<short>Variant type: Date </short>
</element>

<!-- constant Visibility: default -->
<element name="varolestr">
<short>Variant type: OLE string (widestring) </short>
</element>

<!-- constant Visibility: default -->
<element name="vardispatch">
<short>Variant type: dispatch interface </short>
</element>

<!-- constant Visibility: default -->
<element name="varerror">
<short>Variant type: Error type </short>
</element>

<!-- constant Visibility: default -->
<element name="varboolean">
<short>Variant type: Boolean type </short>
</element>

<!-- constant Visibility: default -->
<element name="varvariant">
<short>Variant type: Variant (arrays only) </short>
</element>

<!-- constant Visibility: default -->
<element name="varunknown">
<short>Variant type: Unknown </short>
</element>

<!-- constant Visibility: default -->
<element name="vardecimal">
<short>Variant type: Decimal (BCD) </short>
</element>

<!-- constant Visibility: default -->
<element name="varshortint">
<short>Variant type: Shortint (16 bit) </short>
</element>

<!-- constant Visibility: default -->
<element name="varbyte">
<short>Variant type: Byte (8 bit) </short>
</element>

<!-- constant Visibility: default -->
<element name="varword">
<short>Variant type: Word (16 bit) </short>
</element>

<!-- constant Visibility: default -->
<element name="varlongword">
<short>Variant type: Word (32 bit) </short>
</element>

<!-- constant Visibility: default -->
<element name="varint64">
<short>Variant type: Integer (64-Bit) </short>
</element>

<!-- constant Visibility: default -->
<element name="varqword">
<short>Variant type: Word (64-bit) </short>
</element>

<!-- constant Visibility: default -->
<element name="varstrarg">
<short>Variant type: String </short>
</element>

<!-- constant Visibility: default -->
<element name="varstring">
<short>Variant type: String </short>
</element>

<!-- constant Visibility: default -->
<element name="varany">
<short>Variant type: Any </short>
</element>

<!-- constant Visibility: default -->
<element name="vartypemask">
<short>Variant type: Mask to extract type </short>
</element>

<!-- constant Visibility: default -->
<element name="vararray">
<short>Variant type: variant Array </short>
</element>

<!-- constant Visibility: default -->
<element name="varbyref">
<short>Variant type: By reference </short>
</element>

<!-- constant Visibility: default -->
<element name="varword64">
<short>Variant type: Word (64-bit) </short>
</element>

<!-- alias type Visibility: default -->
<element name="tvartype">
<short>Type with size of variant type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvararrayboundarray">
<short>Pointer to <link id="tvararrayboundarray"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvararraycoorarray">
<short>Pointer to <link id="tvararraycoorarray"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvararraybound">
<short>Pointer to <link id="tvararraybound"/> type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvararray">
<short>Pointer to <link id="TVarArray"/> type.</short>
</element>

<!-- record type Visibility: default -->
<element name="tvararraybound">
<short>Type describing variant array bounds.</short>
<descr>
<var>tvararraybound</var> is used to describe one dimension in a variant
array.
</descr>
<seealso>
<link id="tvararray"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tvararraybound.elementcount">
<short>Number of elements in this array dimension.</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararraybound.lowbound">
<short>Lower bound of this array dimension (index of first element).</short>
</element>

<!-- record type Visibility: default -->
<element name="tvararray">
<short>Type describing variant array</short>
<descr>
<var>tvararray</var> is a record describing a variant array. It contains
some general data, followed by a number of <link id="TVarArrayBound"/>
records equal to the number of dimensions in the array (<var>dimcoun</var>).
</descr>
<seealso>
<link id="TVarArrayBound"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.dimcount">
<short>Number of dimensions</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.flags">
<short>Array flags.</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.elementsize">
<short>Size of one element in the array.</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.lockcount">
<short>Lock (reference) count of the array.</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.data">
<short>Pointer to the array data.</short>
</element>

<!-- variable Visibility: default -->
<element name="tvararray.bounds">
<short>Array describing the bounds in the array.</short>
</element>

<!-- array type Visibility: default -->
<element name="tvararrayboundarray">
<short>array of <link id="tvararraybound"/> records.</short>
</element>

<!-- array type Visibility: default -->
<element name="tvararraycoorarray">
<short>Array of variant array coordinates</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="tvarop">
<short>Variant operation.</short>
<descr>
<var>tvarop</var> describes a variant operation. It is mainly used for the
variant manager to implement the various conversions and mathematical
operations on a variant.
</descr>
<seealso>
<link id="TVariantManager"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opadd">
<short>Variant operation: Addition.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opsubtract">
<short>Variant operation: Substraction</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opmultiply">
<short>Variant operation: multiplication</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opdivide">
<short>Variant operation: division</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opintdivide">
<short>Variant operation: integer divide</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opmodulus">
<short>Variant operation: Modulus</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opshiftleft">
<short>Variant operation: Shift left</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opshiftright">
<short>Variant operation: Shift right</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opand">
<short>Variant operation: Binary AND operation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opor">
<short>Variant operation: Binary OR operation</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opxor">
<short>Variant operation: binary XOR operation.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcompare">
<short>Variant operation: Compare</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opnegate">
<short>Variant operation: negation.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opnot">
<short>Variant operation: Binary NOT operation.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmpeq">
<short>Variant operation: Compare equal.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmpne">
<short>Variant operation: Compare not equal</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmplt">
<short>Variant operation: Compare less than.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmple">
<short>Variant operation: Compare less than or equal to</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmpgt">
<short>Variant operation: Compare larger than</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="tvarop.opcmpge">
<short>Variant operation: Compare larger than or equal</short>
</element>

<!-- record type Visibility: default -->
<element name="tvardata">
<short>Variant record.</short>
<descr>
<var>TVarData</var> is a record representation of a variant. It contains the
internal structure of a variant and is handled by the various variant
handling routines.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="tvardata.vtype">
<short>Type of variant.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvardata">
<short>Pointer to <link id="TVarData"/> record.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="pcalldesc">
<short>Pointer to <link id="TCallDesc"/> record.</short>
</element>

<!-- record type Visibility: default -->
<element name="tcalldesc">
<short>COM/OLE dispatch call argument description.</short>
<descr>
<var>tcalldesc</var> is used to encode the arguments to a dispatch call to 
an OLE dual interface. It is used on windows only. It describes the 
arguments to a call.
</descr>
</element>


<!-- variable Visibility: default -->
<element name="tcalldesc.calltype">
<short>Call type.</short>
</element>

<!-- variable Visibility: default -->
<element name="tcalldesc.argcount">
<short>Number of arguments to call.</short>
</element>

<!-- variable Visibility: default -->
<element name="tcalldesc.namedargcount">
<short>Number of named arguments in the call.</short>
</element>

<!-- variable Visibility: default -->
<element name="tcalldesc.argtypes">
<short>Types of arguments.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="tdispdesc">
<short>COM/OLE dispatch call description.</short>
<descr>
<var>tcalldesc</var> is used to encode a dispatch call to an OLE dispatch 
interface. It is used on windows only. It describes the dispath call call.
</descr>
<seealso>
<link id="tcalldesc"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="pdispdesc">
<short>Pointer to <link id="tdispdesc"/> record</short>
</element>

<!-- variable Visibility: default -->
<element name="tdispdesc.dispid">
<short>Dispatch ID</short>
</element>

<!-- variable Visibility: default -->
<element name="tdispdesc.restype">
<short>Result type.</short>
</element>

<!-- variable Visibility: default -->
<element name="tdispdesc.calldesc">
<short>Arguments description.</short>
</element>

<!-- record type Visibility: default -->
<element name="tvariantmanager">
<short>Record describing the variant manager.</short>
<descr>
<var>TVariantManager</var> describes the variant manager as expected by the
<link id="SetVariantManager"/> call.
</descr>
<seealso>
<link id="SetVariantManager"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartoint">
<short>Called to convert a variant to an integer value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartoint64">
<short>Called to convert a variant to an int64 value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartoword64">
<short>Called to convert a variant to a word64 value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartobool">
<short>Called to convert a variant to a boolean value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartoreal">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartocurr">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartopstr">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartolstr">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartowstr">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartointf">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartodisp">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vartodynarray">
<short>Called to convert a variant to a  value</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfrombool">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromint">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromint64">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromword64">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromreal">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfrompstr">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromlstr">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromwstr">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromintf">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromdisp">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varfromdynarray">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.olevarfrompstr">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.olevarfromlstr">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.olevarfromvar">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.olevarfromint">
<short>Called to convert a  value to a variant</short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varop">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.cmpop">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varneg">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varnot">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varinit">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varclear">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varaddref">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varcopy">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varcast">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.varcastole">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.dispinvoke">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vararrayredim">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vararrayget">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.vararrayput">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.writevariant">
<short>Called to perform a variant operation: </short>
</element>

<!-- variable Visibility: default -->
<element name="tvariantmanager.write0Variant">
<short>Called to perform a variant operation: </short>
</element>

<!-- pointer type Visibility: default -->
<element name="pvariantmanager">
<short>Pointer to <link id="TVariantManager"/> record.</short>
</element>

<!-- procedure Visibility: default -->
<element name="GetVariantManager">
<short>Return the current variant manager.</short>
<descr>
<var>GetVariantManager</var> returns the current variant manager in
<var>varmgr</var>.
</descr>
<seealso>
<link id="IsVariantManagerSet"/>
<link id="SetVariantManager"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetVariantManager">
<short>Set the current variant manager.</short>
<descr>
<var>SetVariantManager</var> sets the variant manager to <var>varmgr</var>.
</descr>
<seealso>
<link id="IsVariantManagerSet"/>
<link id="GetVariantManager"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IsVariantManagerSet">
<short>Determine if variant manager is currently set.</short>
<descr>
<p>
<var>IsVariantManagerSet</var> determines whether the variant manager was
set to a correct variant manager. It returns <var>True</var> if it is, 
or <var>False</var> if it is not.
</p>
<p>
The routine checks all variant operation handlers, they should all be set correctly.
</p>
</descr>
<seealso>
<link id="SetVariantManager"/>
<link id="GetVariantManager"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="VarDispProc">
<short>Callback to perform dispatch interface procedure call by name.</short>
<descr>
<p>
<var>VarDispProc</var> is called by the compiler if it needs to perform an
interface call from a variant. For instance, the following call:
</p>
<code>
Var
  V : OleVariant;
begin
  V.OpenDocument('c:\temp\mydoc.doc');
end;  
</code>
<p>
is encoded by the compiler and passed to <var>VarDispProc</var>.
</p>
<p>
This pointer must be set by a routine that calls the OS COM handling
routines.
</p>
</descr>
<seealso>
<link id="DispCallByIDProc"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="DispCallByIDProc">
<short>Callback to perform dispatch interface procedure call by ID.</short>
<descr>
<p>
<var>VarDispProc</var> is called by the compiler if it needs to perform an
interface call from a variant which contains a dispatch interface. 
For instance, the following call:
</p>
<code>
Var
  V : OleVariant;
begin
  (V as IWord).OpenDocument('c:\temp\mydoc.doc');
end;
</code>    
<p>
where <var>IWord</var> is a dispatch interface is encoded by the compiler and 
passed to <var>DispCallByIDProc</var>.
</p>
<p>
This pointer must be set by a routine that calls the OS COM handling
routines.
</p>
</descr>
<seealso>
<link id="VarDispProc"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="Null">
<short>Null variant</short>
</element>

<!-- variable Visibility: default -->
<element name="Unassigned">
<short>Unassigned variant.</short>
</element>

<!-- record type Visibility: default -->
<element name="THeapStatus">
<short>Record describing current heap status.</short>
<descr>
<var>THeapStatus</var> is the record describing the current heap status. It
is returned by the <link id="GetHeapStatus"/> call.
</descr>
<seealso>
<link id="GetHeapStatus"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.MaxHeapSize">
<short>Biggest heap size used.</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.MaxHeapUsed">
<short>Biggest used part of heap memory.</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.CurrHeapSize">
<short>Current heap size. </short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.CurrHeapUsed">
<short>Current size of used heap memory.</short>
</element>

<!-- variable Visibility: default -->
<element name="THeapStatus.CurrHeapFree">
<short>Current size of free heap memory.</short>
</element>

<!-- procedure Visibility: default -->
<element name="SysGetHeapStatus">
<short>System implementation of <link id="GetHeapStatus"/></short>
<descr>
<var>SysGetHeapStatus</var> is the system implementation of the <link
id="GetHeapStatus"/> call.
</descr>
<seealso>
<link id="GetHeapStatus"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="Heapsize">
<short>Current heap size</short>
<descr>
<var>HeapSize</var> returns the current heap size. The heap grows
dynamically (as allowed by the OS) and the <var>HeapSize</var> reflects the
current state of the heap.
</descr>
<seealso>
<link id="GetHeapStatus"/>
</seealso>
</element>


</module>
</package>
</fpdoc-descriptions>
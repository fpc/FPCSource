%
%   $Id$
%   This file is part of the FPC documentation.
%   Copyright (C) 2001, by Michael Van Canneyt
%
%   The FPC documentation is free text; you can redistribute it and/or
%   modify it under the terms of the GNU Library General Public License as
%   published by the Free Software Foundation; either version 2 of the
%   License, or (at your option) any later version.
%
%   The FPC Documentation is distributed in the hope that it will be useful,
%   but WITHOUT ANY WARRANTY; without even the implied warranty of
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%   Library General Public License for more details.
%
%   You should have received a copy of the GNU Library General Public
%   License along with the FPC documentation; see the file COPYING.LIB.  If not,
%   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
%   Boston, MA 02111-1307, USA.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The TYPINFO unit
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{The TYPINFO unit}
\FPCexampledir{typinfex}
The \file{TypeInfo} unit contains many routines which can be used for
the querying of the Run-Time Type Information (RTTI) which is generated
by the compiler for classes that are compiled under the \var{\{\$M+\}}
switch. This information can be used to retrieve or set property values
for published properties for totally unknown classes. In particular, it
can be used to stream classes. The \var{TPersistent} class in the 
\file{Classes} unit is compiled in the \var{\{\$M+\}} state and serves
as the base class for all classes that need to be streamed.

The unit should be compatible to the Delphi 5 unit with the same name. 
The only calls that are still missing are the Variant calls, since \fpc
does not support the variant type yet.

The examples in this chapter use a \file{rttiobj} file, which contains
an object that has a published property of all supported types. It also
contains some auxiliary routines and definitions.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Constants, Types and variables
\section{Constants, Types and variables}
\subsection{Constants}
The following constants are used in the implementation section of the unit.

\begin{verbatim}
BooleanIdents: array[Boolean] of String = ('False', 'True');
DotSep: String = '.';
\end{verbatim}
The following constants determine the access method for the \var{Stored} 
identifier of a property as used in the \var{PropProcs} field of the 
\var{TPropInfo} record:
\begin{verbatim}
ptField = 0;
ptStatic = 1;
ptVirtual = 2;
ptConst = 3;
\end{verbatim}
The following typed constants are used for easy selection of property types.
\begin{verbatim}
tkAny = [Low(TTypeKind)..High(TTypeKind)];
tkMethods = [tkMethod];
tkProperties = tkAny-tkMethods-[tkUnknown];
\end{verbatim}

\subsection{types}
The following pointer types are defined:
\begin{verbatim}
PShortString =^ShortString;
PByte        =^Byte;
PWord        =^Word;
PLongint     =^Longint;
PBoolean     =^Boolean;
PSingle      =^Single;
PDouble      =^Double;
PExtended    =^Extended;
PComp        =^Comp;
PFixed16     =^Fixed16;
Variant      = Pointer;
\end{verbatim}

The \var{TTypeKind} determines the type of a property:
\begin{verbatim}
TTypeKind = (tkUnknown,tkInteger,tkChar,tkEnumeration,
             tkFloat,tkSet,tkMethod,tkSString,tkLString,tkAString,
             tkWString,tkVariant,tkArray,tkRecord,tkInterface,
             tkClass,tkObject,tkWChar,tkBool,tkInt64,tkQWord,
             tkDynArray,tkInterfaceRaw);
tkString = tkSString;
\end{verbatim}
\var{tkString} is an alias that is introduced for Delphi compatibility.

If the property is and ordinal type, then \var{TTOrdType} determines the 
size and sign of the ordinal type:
\begin{verbatim}
TTOrdType = (otSByte,otUByte,otSWord,otUWord,otSLong,otULong);
\end{verbatim}
The size of a float type is determined by \var{TFloatType}:
\begin{verbatim}
TFloatType = (ftSingle,ftDouble,ftExtended,ftComp,ftCurr,
              ftFixed16,ftFixed32);
\end{verbatim}
A method property (e.g. an event) can have one of several types:
\begin{verbatim}
TMethodKind = (mkProcedure,mkFunction,mkConstructor,mkDestructor,
               mkClassProcedure, mkClassFunction);
\end{verbatim}
The kind of parameter to a method is determined by \var{TParamFlags}:
\begin{verbatim}
TParamFlags = set of (pfVar,pfConst,pfArray,pfAddress,pfReference,pfOut);
\end{verbatim}
Interfaces are described further with \var{TntfFlags}:
\begin{verbatim}
TIntfFlags = set of (ifHasGuid,ifDispInterface,ifDispatch);
\end{verbatim}
The following defines a set of \var{TTypeKind}:
\begin{verbatim}
TTypeKinds = set of TTypeKind;
\end{verbatim}
The \var{TypeInfo} function returns a pointer to a \var{TTypeInfo} record:
\begin{verbatim}
TTypeInfo = record
  Kind : TTypeKind;
  Name : ShortString;
end;
PTypeInfo = ^TTypeInfo;
PPTypeInfo = ^PTypeInfo;
\end{verbatim}
Note that the Name is stored with as much bytes as needed to store the name,
it is not padded to 255 characters. 
The type data immediatly follows the \var{TTypeInfo} record as a \var{TTypeData} record:
\begin{verbatim}
PTypeData = ^TTypeData;
TTypeData = packed record
case TTypeKind of
  tkUnKnown,tkLString,tkWString,tkAString,tkVariant:
    ();
  tkInteger,tkChar,tkEnumeration,tkWChar:
    (OrdType : TTOrdType;
     case TTypeKind of
       tkInteger,tkChar,tkEnumeration,tkBool,tkWChar : (
         MinValue,MaxValue : Longint;
         case TTypeKind of
           tkEnumeration: (
             BaseType : PTypeInfo;
             NameList : ShortString
           )
         );
       tkSet: (
             CompType : PTypeInfo
         )
     );
  tkFloat: (
    FloatType : TFloatType
    );
  tkSString:
    (MaxLength : Byte);
  tkClass:
    (ClassType : TClass;
     ParentInfo : PTypeInfo;
     PropCount : SmallInt;
     UnitName : ShortString
     );
  tkMethod:
    (MethodKind : TMethodKind;
     ParamCount : Byte;
     ParamList : array[0..1023] of Char
     {in reality ParamList is a array[1..ParamCount] of:
	  record
	    Flags : TParamFlags;
	    ParamName : ShortString;
	    TypeName : ShortString;
	  end;
	followed by
	  ResultType : ShortString}
    );
  tkInt64:
   (MinInt64Value, MaxInt64Value: Int64);
  tkQWord:
   (MinQWordValue, MaxQWordValue: QWord);
  tkInterface:
	();
end;
\end{verbatim}
If the typeinfo kind is \var{tkClass}, then the property 
information follows the \var{UnitName} string, as an array of \var{TPropInfo} records.

The \var{TPropData} record is not used, but is provided for completeness and
compatibility with Delphi.
\begin{verbatim}
TPropData = packed record
  PropCount : Word;
  PropList : record end;
end;
\end{verbatim}
The \var{TPropInfo} record describes one published property of a class:
\begin{verbatim}
PPropInfo = ^TPropInfo;
TPropInfo = packed record
  PropType : PTypeInfo;
  GetProc : Pointer;
  SetProc : Pointer;
  StoredProc : Pointer;
  Index : Integer;
  Default : Longint;
  NameIndex : SmallInt;
  PropProcs : Byte;
  Name : ShortString;
end;
\end{verbatim}
The \var{Name} field is stored not with 255 characters, but with just as many characters
as required to store the name.
\begin{verbatim}
TProcInfoProc = procedure(PropInfo : PPropInfo) of object;
\end{verbatim}
The following pointer and array types are used for typecasts:
\begin{verbatim}
PPropList = ^TPropList;
TPropList = array[0..65535] of PPropInfo;
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Functions and procedures by category
\section{Function list by category}
What follows is a listing of the available functions, grouped by category.
For each function there is a reference to the page where the function
can be found.

\subsection{Examining published property information}
Functions for retrieving or examining property information
\begin{funclist}
\funcref{FindPropInfo}{Getting property type information, With error checking.}
\funcref{GetPropInfo}{Getting property type information, No error checking.}
\funcref{GetPropInfos}{Find property information of a certain kind}
\funcref{GetObjectPropClass}{Return the declared class of an object property }
\funcref{GetPropList}{Get a list of all published properties}
\funcref{IsPublishedProp}{Is a property published}
\funcref{IsStoredProp}{Is a property stored}
\funcref{PropIsType}{Is a property of a certain kind}
\funcref{PropType}{Return the type of a property}
\end{funclist}

\subsection{Getting or setting property values}
Functions to set or set a property's value.
\begin{funclist}
\funcref{GetEnumProp}{Return the value of an enumerated type property}
\funcref{GetFloatProp}{Return the value of a float property}
\funcref{GetInt64Prop}{Return the value of an Int64 property}
\funcref{GetMethodProp}{Return the value of a procedural type property}
\funcref{GetObjectProp}{Return the value of an object property}
\funcref{GetOrdProp}{Return the value of an ordinal type property}
\funcref{GetPropValue}{Return the value of a property as a variant}
\funcref{GetSetProp}{Return the value of a set property}
\funcref{GetStrProp}{Return the value of a string property}
\funcref{GetVariantProp}{Return the value of a variant property}
\funcref{SetEnumProp}{Set the value of an enumerated type property}
\funcref{SetFloatProp}{Set the value of a float property}
\funcref{SetInt64Prop}{Set the value of an Int64 property}
\funcref{SetMethodProp}{Set the value of a procedural type property}
\funcref{SetObjectProp}{Set the value of an object property}
\funcref{SetOrdProp}{Set the value of an ordinal type property}
\funcref{SetPropValue}{Set the value of a property trhough a variant}
\funcref{SetSetProp}{Set the value of a set property}
\funcref{SetStrProp}{Set the value of a string property}
\funcref{SetVariantProp}{Set the value of a variant property}
\end{funclist}

\subsection{Auxiliary functions}
\begin{funclist}
\funcref{GetEnumName}{Get an enumerated type element name}
\funcref{GetEnumValue}{Get ordinal number of an enumerated tye, based on the
name.}
\funcref{GetTypeData}{Skip type name and return a pointer to the type data}
\funcref{SetToString}{Convert a set to its string representation}
\funcref{StringToSet}{Convert a string representation of a set to a set}
\end{funclist}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Functions and procedures
\section{Functions and Procedures}

\begin{function}{FindPropInfo}
\Declaration
Function FindPropInfo(AClass:TClass;const PropName: string): PPropInfo;\\
Function FindPropInfo(Instance: TObject; const PropName: string): PPropInfo;   
\Description
\var{FindPropInfo} examines the published property information of a class and
returns a pointer to the property information for property \var{PropName}.
The class to be examined can be specified in one of two ways:
\begin{description}
\item[AClass] a class pointer.
\item[Instance] an instance of the class to be investigated.
\end{description}
If the property does not exist, a \var{EPropertyError} exception will be
raised. The \seef{GetPropInfo} function has the same function as the
\var{FindPropInfo} function, but returns \var{Nil} if the property does not
exist.
\Errors
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception.
\SeeAlso
\seef{GetPropInfo}, \seef{GetPropList}, \seep{GetPropInfos}
\end{function}

\FPCexample{ex14}

\begin{function}{GetEnumName}
\Declaration
Function GetEnumName(TypeInfo : PTypeInfo;Value : Integer) : string;
\Description
\var{GetEnumName} scans the type information for the enumeration type
described by \var{TypeInfo} and returns the name of the enumeration 
constant for the element with ordinal value equal to \var{Value}.

If \var{Value} is out of range, the first element of the enumeration type
is returned. The result is lowercased, but this may change in the future.

This can be used in combination with \var{GetOrdProp} to stream a property
of an enumerated type.
\Errors
No check is done to determine whether \var{TypeInfo} really points to the 
type information for an enumerated type. 
\SeeAlso
\seef{GetOrdProp}, \seef{GetEnumValue}
\end{function}

\FPCexample{ex9}

\begin{function}{GetEnumProp}
\Declaration
Function GetEnumProp(Instance: TObject;const PropInfo: PPropInfo): string;\\
Function GetEnumProp(Instance: TObject;const PropName: string): string;       
\Description
\var{GetEnumProp} returns the value of an property of an enumerated type
and returns the name of the enumerated value for the objetc \var{Instance}. 
The property whose value must be returned can be specified by its property 
info in \var{PropInfo} or by its name in \var{PropName}
\Errors
No check is done to determine whether \var{PropInfo} really points to the 
property information for an enumerated type. 
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception.
\SeeAlso
\seep{SetEnumProp} \seef{GetOrdProp}, \seef{GetStrProp},
\seef{GetInt64Prop},\seef{GetMethodProp}, \seef{GetSetProp},
\seef{GetObjectProp}, \seef{GetEnumProp}
\end{function}

\FPCexample{ex2}

\begin{function}{GetEnumValue}
\Declaration
Function GetEnumValue(TypeInfo : PTypeInfo;const Name : string) : Integer;
\Description
\var{GetEnumValue} scans the type information for the enumeration type
described by \var{TypeInfor} and returns the ordinal value for the element
in the enumerated type that has identifier \var{Name}. The identifier is
searched in a case-insensitive manner.

This can be used to set the value of enumerated properties from a stream. 
\Errors
If \var{Name} is not found in the list of enumerated values, then -1 is
returned. No check is done whether \var{TypeInfo} points to the type information
for an enumerated type. 
\SeeAlso
\seef{GetEnumName}, \seep{SetOrdProp}
\end{function}

For an example, see \seef{GetEnumName}.

\begin{function}{GetFloatProp}
\Declaration
Function GetFloatProp(Instance : TObject;PropInfo : PPropInfo) : Extended;\\
Procedure SetFloatProp(Instance: TObject; const PropName: string; Value: Extended);
\Description
\var{GetFloatProp} returns the value of the float property described by 
\var{PropInfo} or with name \var{Propname} for the object \var{Instance}. 
All float types are converted
to extended.
\Errors
No checking is done whether \var{Instance} is non-nil, or whether
\var{PropInfo} describes a valid float property of \var{Instance}.
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception.
\SeeAlso
\seep{SetFloatProp}, \seef{GetOrdProp}, \seef{GetStrProp},
\seef{GetInt64Prop},\seef{GetMethodProp}, \seef{GetSetProp},
\seef{GetObjectProp}, \seef{GetEnumProp}
\end{function}

\FPCexample{ex4}

\begin{function}{GetInt64Prop}
\Declaration
Function GetInt64Prop(Instance: TObject; PropInfo: PPropInfo): Int64;\\
Function GetInt64Prop(Instance: TObject; const PropName: string): Int64;
\Description
{\em Publishing of Int64 properties is not yet supported by \fpc. This
function is provided for Delphi compatibility only at the moment.}

\var{GetInt64Prop} returns the value of the property of type
\var{Int64} that is described by \var{PropInfo} or with name \var{Propname} 
for the object \var{Instance}.

\Errors
No checking is done whether \var{Instance} is non-nil, or whether
\var{PropInfo} describes a valid \var{Int64} property of \var{Instance}.
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception
\SeeAlso
\seep{SetInt64Prop}, \seef{GetOrdProp}, \seef{GetStrProp},
\seef{GetFloatProp}, \seef{GetMethodProp}, \seef{GetSetProp},
\seef{GetObjectProp}, \seef{GetEnumProp}
\end{function}

\FPCexample{ex15}

\begin{function}{GetMethodProp}
\Declaration
Function GetMethodProp(Instance : TObject;PropInfo : PPropInfo) : TMethod;\\
Function GetMethodProp(Instance: TObject; const PropName: string): TMethod;
\Description
\var{GetMethodProp} returns the method the property described by
\var{PropInfo} or with name \var{Propname} for object \var{Instance}.
The return type \var{TMethod} is defined in the \file{SysUtils} unit as:
\begin{verbatim}
TMethod = packed record
  Code, Data: Pointer;
end;                                                                         
\end{verbatim}
\var{Data} points to the instance of the class with the method \var{Code}.

\Errors
No checking is done whether \var{Instance} is non-nil, or whether
\var{PropInfo} describes a valid method property of \var{Instance}.
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception
\SeeAlso
\seep{SetMethodProp}, \seef{GetOrdProp}, \seef{GetStrProp},
\seef{GetFloatProp}, \seef{GetInt64Prop}, \seef{GetSetProp},
\seef{GetObjectProp}, \seef{GetEnumProp}
\end{function}

\FPCexample{ex6}

\begin{function}{GetObjectProp}
\Declaration
Function GetObjectProp(Instance: TObject; const PropName: string): TObject;\\
Function GetObjectProp(Instance: TObject; const PropName: string; MinClass:TClass): TObject; \\
Function GetObjectProp(Instance: TObject; PropInfo: PPropInfo; MinClass: TClass):
TObject;\\
\Description
\var{GetObjectProp} returns the object which the property descroibed by
\var{PropInfo} with name \var{Propname} points to for object \var{Instance}.

If \var{MinClass} is specified, then if the object is not descendent of
class \var{MinClass}, then \var{Nil} is returned.

\Errors
No checking is done whether \var{Instance} is non-nil, or whether
\var{PropInfo} describes a valid method property of \var{Instance}. 
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception.
\SeeAlso
\seep{SetMethodProp}, \seef{GetOrdProp}, \seef{GetStrProp},
\seef{GetFloatProp}, \seef{GetInt64Prop}, \seef{GetSetProp},
\seef{GetObjectProp}, \seef{GetEnumProp}
\end{function}

\FPCexample{ex5}

\begin{function}{GetObjectPropClass}
\Declaration
Function GetObjectPropClass(Instance: TObject; const PropName: string): TClass;                                             
\Description
\var{GetObjectPropClass} returns the declared class of the property with name 
\var{PropName}. This may not be the actual class of the property value.
\Errors
No checking is done whether \var{Instance} is non-nil.
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception.
\SeeAlso
\seep{SetMethodProp}, \seef{GetOrdProp}, \seef{GetStrProp},
\seef{GetFloatProp}, \seef{GetInt64Prop}
\end{function}

For an example, see \seef{GetObjectProp}.

\begin{function}{GetOrdProp}
\Declaration
Function GetOrdProp(Instance : TObject;PropInfo : PPropInfo) : Longint;\\
Function GetOrdProp(Instance: TObject;const PropName: string): Longint;
\Description
\var{GetOrdProp} returns the value of the ordinal property described by
\var{PropInfo} or with name \var{PropName} for the object \var{Instance}. 
The value is returned as a longint, which should be typecasted to the 
needed type.

Ordinal properties that can be retrieved include:
\begin{description}
\item[Integers and subranges of integers] The value of the integer will be
returned.
\item[Enumerated types and subranges of enumerated types] The ordinal value
of the enumerated type will be returned.
\item[Sets] If the base type of the set has less than 31 possible values.
If a bit is set in the return value, then the corresponding element of the
base ordinal class of the set type must be included in the set.
\end{description}
\Errors
No checking is done whether \var{Instance} is non-nil, or whether
\var{PropInfo} describes a valid ordinal property of \var{Instance}
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception.
\SeeAlso
\seep{SetOrdProp}, \seef{GetStrProp}, \seef{GetFloatProp},
\seef{GetInt64Prop},\seef{GetMethodProp}, \seef{GetSetProp},
\seef{GetObjectProp}, \seef{GetEnumProp}
\end{function}

\FPCexample{ex1}

\begin{function}{GetPropInfo}
\Declaration
Function GetPropInfo(AClass: TClass; const PropName: string; AKinds: TTypeKinds) : PPropInfo;\\
Function GetPropInfo(AClass: TClass; const PropName: string): PPropInfo;\\
Function GetPropInfo(Instance: TObject; const PropName: string): PPropInfo;\\
Function GetPropInfo(Instance: TObject; const PropName: string; AKinds: TTypeKinds) : PPropInfo;\\
Function GetPropInfo(TypeInfo: PTypeInfo;const PropName: string) : PPropInfo;\\
Function GetPropInfo(TypeInfo: PTypeInfo;const PropName: string; AKinds : TTypeKinds) : PPropInfo;
\Description
\var{GetPropInfo} returns a pointer to the \var{TPropInfo} record for a the 
\var{PropName} property of a class. The class to examine can be specified 
in one of three ways:
\begin{description}
\item[Instance] An instance of the class.
\item[AClass] A class pointer to the class.
\item[TypeInfo] A pointer to the type information of the class.
\end{description}
In each of these three ways, if \var{AKinds} is specified, if the property 
has \var{TypeKind} which is not included in \var{Akinds}, \var{Nil} will be
returned.
\Errors
If the property \var{PropName} does not exist, \var{Nil} is returned.
\SeeAlso
\seep{GetPropInfos},\seef{GetPropList}
\end{function}

For an example, see most of the other functions.

\begin{procedure}{GetPropInfos}
\Declaration
Procedure GetPropInfos(TypeInfo: PTypeInfo;PropList: PPropList);
\Description
\var{GetPropInfos} stores pointers to the property information of all published
properties of a class with class info \var{TypeInfo} in the list pointed to by
\var{Proplist}. The \var{PropList} pointer must point to a memory location that
contains enough space to hold all properties of the class and its parent classes.
\Errors
No checks are done to see whether \var{PropList} points to a memory area that 
is big enough to hold all pointers.
\SeeAlso
\seef{GetPropInfo},\seef{GetPropList}
\end{procedure}

\FPCexample{ex12}

\begin{function}{GetPropList}
\Declaration
Function GetPropList(TypeInfo : PTypeInfo;
                     TypeKinds : TTypeKinds; 
                     PropList : PPropList) : Integer;
\Description
\var{GetPropList} stores pointers to property information of the class with class
info \var{TypeInfo} for properties of kind \var{TypeKinds} in the list pointed to
by \var{Proplist}. \var{PropList} must contain enough space to hold all properties.

The function returns the number of pointers that matched the criteria and were stored
in \var{PropList}.
\Errors
No checks are done to see whether \var{PropList} points to a memory area that is big enough
to hold all pointers.
\SeeAlso
\seep{GetPropInfos}, \seef{GetPropInfo}
\end{function}

\FPCexample{ex13}

\begin{function}{GetPropValue}
\Declaration
Function GetPropValue(Instance: TObject; const PropName: string): Variant;\\
Function GetPropValue(Instance: TObject; const PropName: string; PreferStrings: Boolean): Variant;
\Description
Due to missing \var{Variant} support, \var{GetPropValue} is not yet implemented. 
The declaration is provided for compatibility with Delphi.
\Errors
\SeeAlso
\end{function}

\begin{function}{GetSetProp}
\Declaration
Function GetSetProp(Instance: TObject; const PropInfo: PPropInfo; Brackets: Boolean):
string;\\
Function GetSetProp(Instance: TObject; const PropName: string): string;\\
Function GetSetProp(Instance: TObject; const PropName: string; Brackets: Boolean): string;                 
\Description
\var{GetSetProp} returns the contents of a set property as a string.
The property to be returned can be specified by it's name in \var{PropName}
or by its property information in \var{PropInfo}.

The returned set is a string representation of the elements in the set as
returned by \seef{SetToString}. The \var{Brackets} option can be used to 
enclose the string representation in square brackets.
\Errors
No checking is done whether \var{Instance} is non-nil, or whether
\var{PropInfo} describes a valid ordinal property of \var{Instance}
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception.                                                 
\SeeAlso
\seep{SetSetProp}, \seef{GetStrProp}, \seef{GetFloatProp},
\seef{GetInt64Prop},\seef{GetMethodProp}
\end{function}

\FPCexample{ex7}

\begin{function}{GetStrProp}
\Declaration
Function GetStrProp(Instance : TObject;
                    PropInfo : PPropInfo) : Ansistring;\\
Function GetStrProp(Instance: TObject; 
                    const PropName: string): string;
\Description
\var{GetStrProp} returns the value of the string property described by
\var{PropInfo} or with name \var{PropName} for object \var{Instance}. 
\Errors
No checking is done whether \var{Instance} is non-nil, or whether
\var{PropInfo} describes a valid string property of \var{Instance}.
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception.
\SeeAlso
\seep{SetStrProp}, \seef{GetOrdProp}, \seef{GetFloatProp},
\seef{GetInt64Prop},\seef{GetMethodProp}
\end{function}

\FPCexample{ex3}

\begin{function}{GetTypeData}
\Declaration
Function GetTypeData(TypeInfo : PTypeInfo) : PTypeData;
\Description
\var{GetTypeData} returns a pointer to the \var{TTypeData} record that
follows after the \var{TTypeInfo} record pointed to by \var{TypeInfo}.
It essentially skips the \var{Kind} and \var{Name} fields in the 
\var{TTypeInfo} record.
\Errors
None.
\SeeAlso
\end{function}

\begin{function}{GetVariantProp}
\Declaration
Function GetVariantProp(Instance : TObject;PropInfo : PPropInfo): Variant;
\Description
Due to mising Variant support, the \var{GetVariantProp} function is not 
yet implemented. Provided for Delphi compatibility only.
\Errors
\SeeAlso
\seep{SetVariantProp}
\end{function}

\begin{function}{IsPublishedProp}
\Declaration
Function IsPublishedProp(AClass: TClass; const PropName: string): Boolean;\\
Function IsPublishedProp(Instance: TObject; const PropName: string): Boolean;                              
\Description
\var{IsPublishedProp} returns true if a class has a published property with
name \var{PropName}. The class can be specfied in one of two ways:
\begin{description}
\item[AClass] A class pointer to the class.
\item[Instance] An instance of the class.
\end{description}
\Errors
No checks are done to ensure \var{Instance} or \var{AClass} are valid
pointers. Specifying an invalid property name in \var{PropName} will result
in an \var{EPropertyError} exception.                                                 
\SeeAlso
\seef{IsStoredProp}, \seef{PropIsType}
\end{function}

\FPCexample{ex10}

\begin{function}{IsStoredProp}
\Declaration
Function IsStoredProp(Instance : TObject;PropInfo : PPropInfo) : Boolean;\\
Function IsStoredProp(Instance: TObject; const PropName: string): Boolean; 
\Description
\var{IsStoredProp} returns \var{True} if the \var{Stored} modifier evaluates
to \var{True} for the property described by \var{PropInfo} or with name
\var{PropName} for object \var{Instance}. 
It returns \var{False} otherwise. If the function returns
\var{True}, this indicates that the property should be written when
streaming the object \var{Instance}.

If there was no \var{stored} modifier in the declaration of the property, 
\var{True} will be returned. 
\Errors
No checking is done whether \var{Instance} is non-nil, or whether
\var{PropInfo} describes a valid property of \var{Instance}.
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception.                                                 
\SeeAlso
\seef{IsPublishedProp}, \seef{PropIsType}
\end{function}

\FPCexample{ex11}

\begin{function}{PropIsType}
\Declaration
Function PropIsType(AClass: TClass; 
                    const PropName: string; TypeKind: TTypeKind): Boolean;\\
Function PropIsType(Instance: TObject; 
                    const PropName: string; TypeKind: TTypeKind): Boolean;              
\Description
\var{PropIsType} returns \var{True} if the property with name \var{PropName}
has type \var{TypeKind}. It returns \var{False} otherwise. The class to be
examined can be specified in one of two ways:
\begin{description}
\item[AClass] A class pointer. 
\item[Instance] An instance of the class.
\end{description}
\Errors
No checks are done to ensure \var{Instance} or \var{AClass} are valid
pointers.Specifying an invalid property name in \var{PropName} will result
in an \var{EPropertyError} exception.                                                 
\SeeAlso
\seef{IsPublishedProp}, \seef{IsStoredProp}, \seef{PropType}
\end{function}

\FPCexample{ex16}

\begin{function}{PropType}
\Declaration
Function PropType(AClass: TClass; const PropName: string): TTypeKind;\\
Function PropType(Instance: TObject; const PropName: string): TTypeKind;
\Description
\var{Proptype} returns the type of the property \var{PropName} for a class.
The class to be examined can be specified in one of 2 ways:
\begin{description}
\item[AClass] A class pointer. 
\item[Instance] An instance of the class.
\end{description}
\Errors
No checks are done to ensure \var{Instance} or \var{AClass} are valid
pointers. Specifying an invalid property name in \var{PropName} will result
in an \var{EPropertyError} exception.
\SeeAlso
\seef{IsPublishedProp}, \seef{IsStoredProp}, \seef{PropIsType}
\end{function}

\FPCexample{ex17}

\begin{procedure}{SetEnumProp}
\Declaration
Procedure SetEnumProp(Instance: TObject; const PropInfo: PPropInfo;
                      const Value: string);\\
Procedure SetEnumProp(Instance: TObject; const PropName: string;
                      const Value: string);                      
\Description
\var{SetEnumProp} sets the property described by \var{PropInfo} or with name
\var{PropName} to \var{Value}. \var{Value} must be a string with the name
of the enumerate value, i.e. it can be used as an argument to 
\seef{GetEnumValue}.
\Errors
No checks are done to ensure \var{Instance} or \var{PropInfo} are valid
pointers. Specifying an invalid property name in \var{PropName} will result
in an \var{EPropertyError} exception.                                           
\SeeAlso
\seef{GetEnumProp}, \seep{SetStrProp}, \seep{SetFloatProp},
\seep{SetInt64Prop},\seep{SetMethodProp}.
\end{procedure}

For an example, see \seef{GetEnumProp}.

\begin{procedure}{SetFloatProp}
\Declaration
Procedure SetFloatProp(Instance : TObject;
                       PropInfo : PPropInfo;
                       Value : Extended);\\
Procedure SetFloatProp(Instance: TObject; 
                       const PropName: string; 
                       Value: Extended);
\Description
\var{SetFloatProp} assigns \var{Value} to the property described by
\var{PropInfo} or with name \var{Propname} for the object \var{Instance}.
\Errors
No checking is done whether \var{Instance} is non-nil, or whether
\var{PropInfo} describes a valid float property of \var{Instance}.
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception.
\SeeAlso
\seef{GetFloatProp}, \seep{SetOrdProp}, \seep{SetStrProp},
\seep{SetInt64Prop},\seep{SetMethodProp}
\end{procedure}

For an example, see \seef{GetFloatProp}.


\begin{procedure}{SetInt64Prop}
\Declaration
Procedure SetInt64Prop(Instance: TObject; PropInfo: PPropInfo; const Value: Int64);\\
Procedure SetInt64Prop(Instance: TObject; const PropName: string; const Value: Int64);
\Description
\var{SetInt64Prop} assigns \var{Value} to the property of type
\var{Int64} that is described by \var{PropInfo} or with name \var{Propname} 
for the object \var{Instance}.
\Errors
No checking is done whether \var{Instance} is non-nil, or whether
\var{PropInfo} describes a valid \var{Int64} property of \var{Instance}.
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception.
\SeeAlso
\seef{GetInt64Prop}, \seef{GetMethodProp}, \seep{SetOrdProp}, \seep{SetStrProp},
\seep{SetFloatProp}
\end{procedure}

For an example, see \seef{GetInt64Prop}.


\begin{procedure}{SetMethodProp}
\Declaration
Procedure SetMethodProp(Instance : TObject;PropInfo : PPropInfo; const Value :
TMethod);\\
Procedure SetMethodProp(Instance: TObject; const PropName: string; const Value: TMethod);
\Description
\var{SetMethodProp} assigns \var{Value} to the method the property described 
by \var{PropInfo} or with name \var{Propname} for object \var{Instance}.

The type \var{TMethod} of the \var{Value} parameter is defined in the
\file{SysUtils} unit as:
\begin{verbatim}
TMethod = packed record
  Code, Data: Pointer;
end;                                                                         
\end{verbatim}
\var{Data} should point to the instance of the class with the method \var{Code}.

\Errors
No checking is done whether \var{Instance} is non-nil, or whether
\var{PropInfo} describes a valid method property of \var{Instance}.
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception.
\SeeAlso
\seef{GetMethodProp}, \seep{SetOrdProp}, \seep{SetStrProp},
\seep{SetFloatProp}, \seep{SetInt64Prop}
\end{procedure}

For an example, see \seef{GetMethodProp}.


\begin{procedure}{SetObjectProp}
\Declaration
Procedure SetObjectProp(Instance: TObject; 
                        PropInfo: PPropInfo; Value: TObject);\\
Procedure SetObjectProp(Instance: TObject; 
                        const PropName: string; Value: TObject);                        
\Description
\var{SetObjectProp} assigns \var{Value} to the the object property described by
\var{PropInfo} or with name \var{Propname} for the object \var{Instance}. 
\Errors
No checking is done whether \var{Instance} is non-nil, or whether
\var{PropInfo} describes a valid method property of \var{Instance}.
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception.
\SeeAlso
\seef{GetObjectProp}, \seep{SetOrdProp}, \seep{SetStrProp},
\seep{SetFloatProp}, \seep{SetInt64Prop}, \seep{SetMethodProp}
\end{procedure}

For an example, see \seef{GetObjectProp}.

\begin{procedure}{SetOrdProp}
\Declaration
Procedure SetOrdProp(Instance : TObject; PropInfo : PPropInfo; 
                     Value : Longint);\\
Procedure SetOrdProp(Instance: TObject; const PropName: string;
                     Value: Longint);
\Description
\var{SetOrdProp} assigns \var{Value} to the the ordinal property described by 
\var{PropInfo} or with name \var{Propname} for the object \var{Instance}. 

Ordinal properties that can be set include:
\begin{description}
\item[Integers and subranges of integers] The actual value of the integer must be 
passed.
\item[Enumerated types and subranges of enumerated types] The ordinal value
of the enumerated type must be passed.
\item[Subrange types] of integers or enumerated types. Here the ordinal
value must be passed.
\item[Sets] If the base type of the set has less than 31 possible values.
For each possible value; the corresponding bit of \var{Value} must be set.
\end{description}
\Errors
No checking is done whether \var{Instance} is non-nil, or whether
\var{PropInfo} describes a valid ordinal property of \var{Instance}. 
No range checking is performed.
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception.
\SeeAlso
\seef{GetOrdProp}, \seep{SetStrProp}, \seep{SetFloatProp},
\seep{SetInt64Prop},\seep{SetMethodProp}
\end{procedure}


For an example, see \seef{GetOrdProp}.


\begin{procedure}{SetPropValue}
\Declaration
Procedure SetPropValue(Instance: TObject; 
                       const PropName: string; const Value: Variant);                   
\Description
Due to missing Variant support, this function is not yet implemented;
it is provided for Delphi compatibility only.
\Errors
\SeeAlso
\end{procedure}

\begin{procedure}{SetSetProp}
\Declaration
Procedure SetSetProp(Instance: TObject; 
                     const PropInfo: PPropInfo; const Value: string);\\
Procedure SetSetProp(Instance: TObject;
                     const PropName: string; const Value: string);                      
\Description
\var{SetSetProp} sets the property specified by \var{PropInfo} or
\var{PropName} for object \var{Instance} to \var{Value}. \var{Value} is a
string which contains a comma-separated list of values, each value being a
string-representation of the enumerated value that should be included in
the set. The value should be accepted by the \seef{StringToSet} function.

The value can be formed using the \seef{SetToString} function.
\Errors
No checking is done whether \var{Instance} is non-nil, or whether
\var{PropInfo} describes a valid ordinal property of \var{Instance}.
No range checking is performed.
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception.                                                 
\SeeAlso
\seef{GetSetProp}, \seep{SetOrdProp}, \seep{SetStrProp}, \seep{SetFloatProp},
\seep{SetInt64Prop},\seep{SetMethodProp}, \seef{SetToString},
\seef{StringToSet}
\end{procedure}

For an example, see \seef{GetSetProp}.

\begin{procedure}{SetStrProp}
\Declaration
procedure SetStrProp(Instance : TObject; PropInfo : PPropInfo; 
                     const Value : Ansistring);\\
Procedure SetStrProp(Instance: TObject; const PropName: string; 
                     const Value: AnsiString);
\Description
\var{SetStrProp} assigns \var{Value} to the string property described by
\var{PropInfo} or with name \var{Propname} for object \var{Instance}. 

\Errors
No checking is done whether \var{Instance} is non-nil, or whether
\var{PropInfo} describes a valid string property of \var{Instance}.
Specifying an invalid property name in \var{PropName} will result in an
\var{EPropertyError} exception.
\SeeAlso
\seef{GetStrProp}, \seep{SetOrdProp}, \seep{SetFloatProp},
\seep{SetInt64Prop},\seep{SetMethodProp}
\end{procedure}

For an example, see \seef{GetStrProp}

\begin{function}{SetToString}
\Declaration
function SetToString(PropInfo: PPropInfo; 
                     Value: Integer) : String;\\
function SetToString(PropInfo: PPropInfo; 
                     Value: Integer; Brackets: Boolean) : String;
\Description
\var{SetToString} takes an integer representation of a set (as received e.g.
by \var{GetOrdProp}) and turns it into a string representing the elements in
the set, based on the type information found in the \var{PropInfo} property
information. By default, the string representation is not surrounded by
square brackets. Setting the \var{Brackets} parameter to \var{True} will 
surround the string representation with brackets.

The function returns the string representation of the set.
\Errors
No checking is done to see whether \var{PropInfo} points to valid property
information.
\SeeAlso
\seef{GetEnumName}, \seef{GetEnumValue}, \seef{StringToSet}
\end{function}

\FPCexample{ex18}

\begin{procedure}{SetVariantProp}
\Declaration
Procedure SetVariantProp(Instance : TObject;
                         PropInfo : PPropInfo;
                         Const Value: Variant);\\
Procedure SetVariantProp(Instance: TObject; 
                         const PropName: string; 
                         const Value: Variant);                 
\Description
Due to missing Variant support, this function is not yet implemented. 
Provided for Delphi compatibility only.
\Errors
\SeeAlso
\end{procedure}


\begin{function}{StringToSet}
\Declaration
function StringToSet(PropInfo: PPropInfo; const Value: string): Integer;
\Description
\var{StringToSet} converts the string representation of a set in \var{Value}
to a integer representation of the set, using the property information found
in \var{PropInfo}. This property information should point to the property
information of a set property. The function returns the integer
representation of the set. (i.e, the set value, typecast to an integer)

The string representation can be surrounded with square brackets, and must 
consist of the names of the elements of the base type of the set. The base
type of the set should be an enumerated type. The elements should be
separated by commas, and may be surrounded by spaces.
each of the names will be fed to the \seef{GetEnumValue} function.
\Errors
No checking is done to see whether \var{PropInfo} points to valid property
information. If a wrong name is given for an enumerated value, then an
\var{EPropertyError} will be raised.
\SeeAlso
\seef{GetEnumName}, \seef{GetEnumValue}, \seef{SetToString}
\end{function}

For an example, see \seef{SetToString}.